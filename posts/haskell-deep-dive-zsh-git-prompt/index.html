<!DOCTYPE html>
<html lang="en"><head>

  <meta name="generator" content="Hugo 0.71.1" />
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="author" content="Pang Yan Han"><meta name="keywords" content="haskell,zsh,zsh-git-prompt,deep dive"><meta property="og:title" content="Haskell deep dive: zsh-git-prompt" />
<meta property="og:description" content="In How To Become A Hacker, Eric S. Raymond gives the following golden advice:
 Learning to program is like learning to write good natural language. The best way to do it is to read some stuff written by masters of the form, write some things yourself, read a lot more, write a little more, read a lot more, write some more &hellip; and repeat until your writing begins to develop the kind of strength and economy you see in your models." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://yanhan.github.io/posts/haskell-deep-dive-zsh-git-prompt/" />
<meta property="article:published_time" content="2017-12-09T13:52:00+00:00" />
<meta property="article:modified_time" content="2017-12-09T13:52:00+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Haskell deep dive: zsh-git-prompt"/>
<meta name="twitter:description" content="In How To Become A Hacker, Eric S. Raymond gives the following golden advice:
 Learning to program is like learning to write good natural language. The best way to do it is to read some stuff written by masters of the form, write some things yourself, read a lot more, write a little more, read a lot more, write some more &hellip; and repeat until your writing begins to develop the kind of strength and economy you see in your models."/>

  <link rel="stylesheet" type="text/css" media="screen" href="https://yanhan.github.io/css/normalize.css" />
  <link rel="stylesheet" type="text/css" media="screen" href="https://yanhan.github.io/css/main.css" />
  <link rel="stylesheet" type="text/css" media="screen" href="https://yanhan.github.io/css/all.css" />
<link rel="stylesheet" type="text/css" media="screen" href="https://yanhan.github.io/css/custom.css" /><title>Haskell deep dive: zsh-git-prompt | Yan Han&#39;s blog</title></head>
<body><header>

  <div id="titletext"><h2 id="title"><a href="https://yanhan.github.io/">Yan Han&#39;s blog</a></h2></div>
  <div id="title-description"><p id="subtitle">On Computer Technology</p><div id=social>
    <nav>
      <ul><li><a href="https://github.com/yanhan"><i title="GitHub" class="icons fab fa-github"></i></a></li><li><a href="/index.xml"><i title="RSS" class="icons fas fa-rss"></i></a></li></ul>
    </nav>
  </div>
  </div>
  <div id="mainmenu">
    <nav>
      <ul>
        
        <li><a href="/">Home</a></li>
        
        <li><a href="/about">About</a></li>
        
        <li><a href="/bookshelf">Bookshelf</a></li>
        
        <li><a href="/posts">All Posts</a></li>
        
        <li><a href="/tags">Tags</a></li>
        
      </ul>
    </nav>
  </div>
</header>
<main><div class="post">
<div class="author">

</div>
<div class="post-header">

<div class="meta">

<div class="date">
<span class="day">09</span>
<span class="rest">Dec 2017</span>
</div>

</div>

<div class="matter">
<h1 class="title">Haskell deep dive: zsh-git-prompt</h1>
</div>
</div>

<div class="tags">









<table>
  <tbody>
    <tr>
      <td>
        <p>Tags</p>
      </td>
      <td class="tagvalues">
        <p>
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        <a href="/tags/deep-dive/"> deep-dive </a>
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        <a href="/tags/haskell/"> haskell </a>
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        <a href="/tags/zsh/"> zsh </a>
        
        
        
        
        
        
        
        <a href="/tags/zsh-git-prompt/"> zsh-git-prompt </a>
        
        
        
        
        
      </td>
    </tr>
  </tbody>
</table>
</div>





</div>

<div class="markdown">
<p>In <a href="http://www.catb.org/esr/faqs/hacker-howto.html">How To Become A Hacker</a>, Eric S. Raymond gives the following golden advice:</p>
<blockquote>
<p>Learning to program is like learning to write good natural language. The best way to do it is to read some stuff written by masters of the form, write some things yourself, read a lot more, write a little more, read a lot more, write some more &hellip; and repeat until your writing begins to develop the kind of strength and economy you see in your models.</p>
</blockquote>
<p>This year, when I decided to give another shot at learning Haskell again, I realized that I needed not just tutorials to study, but also actual code. The reason is, as much as tutorials help to illustrate concepts, it is in actual code that one learns how to compose things together and see some tricks that are not covered in tutorials. About 6 years ago, I was an active user of Arch Linux and wanted to contribute to their package manager, Pacman. Pacman was written in C, which was a language I was using rather heavily at that time. I thought I knew C, but it was a rather eye opening experience to study the Pacman source code and see some real world C code from a program that I used on a day to day basis. Heck, I even contributed slightly to pacman-key probably as a result of that.</p>
<p>Ok, enough with the stuff that doesn&rsquo;t concern anyone else.</p>
<p>After some serious searching, I found <a href="https://github.com/olivierverdier/zsh-git-prompt">zsh-git-prompt</a>. It is the probably the first serious Haskell program I&rsquo;ve studied and understood. What makes this codebase so good for a beginner are:</p>
<ul>
<li>It is pretty short. 464 lines to be precise for <code>.hs</code> files in the <code>src</code> dir based on the output of a find command</li>
<li>It is a real world program. At least for zsh users. What zsh-git-prompt does is, whenever you cd into a directory that is a git repository (and all subdirs in it), it will show you some information about the git repo. For instance, whether the git repo is clean, the number of staged changes, how many commits has it diverged from its tracking branch, etc</li>
<li>Once you install it, you see it all the time you are working with code. If you happen to be learning Haskell and happen to hit a wall and feel like giving up (happens to most people I believe), look at that shiny zsh-git-prompt showing you your git repo&rsquo;s status and you know that Haskell is capable of doing so much and the difference maker is the person that is between the chair and the keyboard. Extra motivation to work harder to eventually be able to write something useful in Haskell!</li>
</ul>
<h2 id="prerequisite-knowledge">Prerequisite knowledge</h2>
<p>As I was writing this post, I realized that there are a number of things that the reader must know to truly understand the code (even with my guidance) and that for me to explain those concepts in detail will make an already long post even longer.</p>
<p>This knowledge is often summarized by the phrase &ldquo;the first N chapters of LYAH&rdquo;, where <code>N</code> is usually 7 and LYAH is the <a href="http://learnyouahaskell.com/">Learn You a Haskell book</a>. I would say that the prereqs for understanding this post is pretty much the first 12 chapters of LYAH. Specifically, the following:</p>
<ul>
<li>Some knowledge of Monads</li>
<li>Definition of the Maybe monad and the List monad. Specifically, each of their definition of <code>&gt;&gt;=</code> and what it does in <code>do</code> notation</li>
</ul>
<p>Non Haskell related knowledge:</p>
<ul>
<li>Some knowledge of git and shell scripting</li>
</ul>
<h2 id="target-audience">Target Audience</h2>
<p>Haskell beginners who have some / all of the prereq knowledge above. You should also be willing to google to find out more information about concepts I didn&rsquo;t explain too well / skipped over.</p>
<p>If you have read LYAH or similar but you are finding it very hard to use your newfound knowledge to write a real world application, I believe that you will find this post helpful.</p>
<h2 id="software-required">Software required</h2>
<p>It is also highly recommended that you install zsh and zsh-git-prompt; you will doubly appreciate this post and what the zsh-git-prompt does. If you are a zsh user but just lack zsh-git-prompt, check out our <a href="/posts/how-to-install-zsh-git-prompt.html">blog post on how to install zsh-git-prompt</a>.</p>
<p>Alternatively, if you do not wish to go through the hassle of installing zsh and zsh-git-prompt on your system, you can head over to <a href="https://github.com/yanhan/zsh-git-prompt-docker">https://github.com/yanhan/zsh-git-prompt-docker</a> to pull / build our Docker image; simply follow the instructions in the README of that repo.</p>
<h2 id="version-we-are-covering">Version we are covering</h2>
<p>We will be going through tag <code>v0.5</code> of zsh-git-prompt. At the time of writing, it happens to be the HEAD of master branch. You can also go to <a href="https://github.com/olivierverdier/zsh-git-prompt/tree/v0.5">https://github.com/olivierverdier/zsh-git-prompt/tree/v0.5</a> and browse the files there.</p>
<p>Throughout this post, we will be referencing zsh-git-prompt source code on its GitHub repo that fall under the <code>v0.5</code> tag.</p>
<h2 id="finding-main">Finding main</h2>
<p>Looking at <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/stack.yaml#L7">stack.yaml</a>, we see:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yml" data-lang="yml"><span style="color:#66d9ef">packages</span>:
- <span style="color:#e6db74">&#39;src&#39;</span>
</code></pre></div><p>which tells us that we should look at the <code>src</code> directory. Listing that directory shows us there is a <code>.cabal</code> file in <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/git-prompt.cabal">git-prompt.cabal</a>. In the <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/git-prompt.cabal#L23"><code>executable</code> section</a>, we see the following:</p>
<pre><code>executable gitstatus
  hs-source-dirs:      app
  main-is:             Main.hs
  ghc-options:         -threaded -rtsopts -with-rtsopts=-N
  build-depends:       base, git-prompt, parsec &gt;=3.1, process&gt;=1.1.0.2, QuickCheck
  default-language:    Haskell2010
  ghc-options: -Wall -O2 -fno-warn-tabs -fno-warn-unused-do-bind
  cc-options: -O3
</code></pre><p>So the main function sits at <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/app/Main.hs">app/Main.hs</a> (within the top level <code>src</code> dir). As an aside, there are very few dependencies on third party libraries.</p>
<p>I have to admit that this is a rather roundabout way to find the main function. In practice, it is much easier to do a <code>git grep -n main</code>. But this process teaches us some stuff about Stack and Cabal.</p>
<h2 id="the-main-function">The main function</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">main</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">IO</span> ()
<span style="color:#a6e22e">main</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- IO</span>
  status <span style="color:#f92672">&lt;-</span> getContents
  mhash <span style="color:#f92672">&lt;-</span> unsafeInterleaveIO gitrevparse <span style="color:#75715e">-- defer the execution until we know we need the hash</span>
  <span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- Maybe</span>
    strings <span style="color:#f92672">&lt;-</span> stringsFromStatus mhash status
    return (unwords strings)
  putStr (fromMaybe <span style="color:#e6db74">&#34;&#34;</span> result)
</code></pre></div><p>Ok. This is short but not very straightforward at first glance. There are some functions that we may not be familiar with, so we turn to <a href="https://www.haskell.org/Hoogle/">Hoogle</a>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">getContents</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">IO</span> <span style="color:#66d9ef">String</span>
<span style="color:#75715e">-- The getContents operation returns all user input as a single string, which</span>
<span style="color:#75715e">-- is read lazily as it is needed (same as hGetContents stdin).</span>

<span style="color:#a6e22e">unsafeInterleaveIO</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">IO</span> a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">IO</span> a
<span style="color:#75715e">-- unsafeInterleaveIO allows an IO computation to be deferred lazily. When</span>
<span style="color:#75715e">-- passed a value of type IO a, the IO will only be performed when the value of</span>
<span style="color:#75715e">-- the a is demanded. This is used to implement lazy file reading, see</span>
<span style="color:#75715e">-- hGetContents.</span>

<span style="color:#a6e22e">unwords</span> <span style="color:#f92672">::</span> [<span style="color:#66d9ef">String</span>] <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">String</span>
<span style="color:#75715e">-- unwords is an inverse operation to words. It joins words with separating</span>
<span style="color:#75715e">-- spaces.</span>
</code></pre></div><p>Ok. The first question is, what is with the <code>status &lt;- getContents</code>? It is not like we are supplying any input via stdin to zsh-git-prompt; we simply see the zsh-git-prompt displayed on our terminal when we are in a git repo without having us to do anything. So this input must be coming from somewhere else.</p>
<p>Indeed, if we look at the <a href="https://github.com/olivierverdier/zsh-git-prompt/tree/v0.5#install">Install section of the README</a>, we see the following:</p>
<blockquote>
<p>Source the file zshrc.sh from your ~/.zshrc config file, and configure your prompt. So, somewhere in ~/.zshrc, you should have:</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">source path/to/zshrc.sh
<span style="color:#75715e"># an example prompt</span>
PROMPT<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;%B%m%~%b$(git_super_status) %# &#39;</span>
</code></pre></div><p>The magic lies with the <code>git_super_status</code> zsh function and the <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/zshrc.sh">zshrc.sh</a> script. We open that file and find the <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/zshrc.sh#L64">git_super_status</a> function. This is where the prompt gets constructed. Most notably, it starts with:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">git_super_status<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    precmd_update_git_vars
</code></pre></div><p>Here&rsquo;s the definition of the <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/zshrc.sh#L32">precmd_update_git_vars</a> function:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#66d9ef">function</span> precmd_update_git_vars<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> -n <span style="color:#e6db74">&#34;</span>$__EXECUTED_GIT_COMMAND<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span> <span style="color:#f92672">||</span> <span style="color:#f92672">[</span> ! -n <span style="color:#e6db74">&#34;</span>$ZSH_THEME_GIT_PROMPT_CACHE<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
        update_current_git_vars
        unset __EXECUTED_GIT_COMMAND
    <span style="color:#66d9ef">fi</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>which points to the <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/zshrc.sh#L43">update_current_git_vars</a> function as the likely workhorse:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#66d9ef">function</span> update_current_git_vars<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    unset __CURRENT_GIT_STATUS

    <span style="color:#66d9ef">if</span> <span style="color:#f92672">[[</span> <span style="color:#e6db74">&#34;</span>$GIT_PROMPT_EXECUTABLE<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;python&#34;</span> <span style="color:#f92672">]]</span>; <span style="color:#66d9ef">then</span>
        local gitstatus<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$__GIT_PROMPT_DIR<span style="color:#e6db74">/gitstatus.py&#34;</span>
        _GIT_STATUS<span style="color:#f92672">=</span><span style="color:#e6db74">`</span>python <span style="color:#e6db74">${</span>gitstatus<span style="color:#e6db74">}</span> 2&gt;/dev/null<span style="color:#e6db74">`</span>
    <span style="color:#66d9ef">fi</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">[[</span> <span style="color:#e6db74">&#34;</span>$GIT_PROMPT_EXECUTABLE<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;haskell&#34;</span> <span style="color:#f92672">]]</span>; <span style="color:#66d9ef">then</span>
        _GIT_STATUS<span style="color:#f92672">=</span><span style="color:#e6db74">`</span>git status --porcelain --branch &amp;&gt; /dev/null | $__GIT_PROMPT_DIR/src/.bin/gitstatus<span style="color:#e6db74">`</span>
    <span style="color:#66d9ef">fi</span>
     __CURRENT_GIT_STATUS<span style="color:#f92672">=(</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>(@s: :)_GIT_STATUS<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">)</span>
  GIT_BRANCH<span style="color:#f92672">=</span>$__CURRENT_GIT_STATUS<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span>
  GIT_AHEAD<span style="color:#f92672">=</span>$__CURRENT_GIT_STATUS<span style="color:#f92672">[</span>2<span style="color:#f92672">]</span>
  GIT_BEHIND<span style="color:#f92672">=</span>$__CURRENT_GIT_STATUS<span style="color:#f92672">[</span>3<span style="color:#f92672">]</span>
  GIT_STAGED<span style="color:#f92672">=</span>$__CURRENT_GIT_STATUS<span style="color:#f92672">[</span>4<span style="color:#f92672">]</span>
  GIT_CONFLICTS<span style="color:#f92672">=</span>$__CURRENT_GIT_STATUS<span style="color:#f92672">[</span>5<span style="color:#f92672">]</span>
  GIT_CHANGED<span style="color:#f92672">=</span>$__CURRENT_GIT_STATUS<span style="color:#f92672">[</span>6<span style="color:#f92672">]</span>
  GIT_UNTRACKED<span style="color:#f92672">=</span>$__CURRENT_GIT_STATUS<span style="color:#f92672">[</span>7<span style="color:#f92672">]</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>What should catch our attention is the following 3 lines:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">    <span style="color:#66d9ef">if</span> <span style="color:#f92672">[[</span> <span style="color:#e6db74">&#34;</span>$GIT_PROMPT_EXECUTABLE<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;haskell&#34;</span> <span style="color:#f92672">]]</span>; <span style="color:#66d9ef">then</span>
        _GIT_STATUS<span style="color:#f92672">=</span><span style="color:#e6db74">`</span>git status --porcelain --branch &amp;&gt; /dev/null | $__GIT_PROMPT_DIR/src/.bin/gitstatus<span style="color:#e6db74">`</span>
    <span style="color:#66d9ef">fi</span>
</code></pre></div><p>Suppose <code>GIT_PROMPT_EXECUTABLE</code> has the value <code>haskell</code>. Then <code>git status --porcelain --branch &amp;&gt;/dev/null | $__GIT_PROMPT_DIR/src/.bin/gitstatus</code> is executed. Despite some experience in Bash, the <code>&amp;&gt;</code> tripped me up because I didn&rsquo;t use it. So I did some googling and I found out that in Bash, the <code>&amp;&gt;</code> redirects both standard output and standard error to the same location, which in this case, is <code>/dev/null</code>.</p>
<p>That doesn&rsquo;t make sense. If both standard output and standard error are redirected to <code>/dev/null</code>, wouldn&rsquo;t the <code>$__GIT_PROMPT_DIR/src/.bin/gitstatus</code> program not get any input? Or, does that program not require any standard input and it will just work? To verify, I ran the following commands in a git repo:</p>
<pre><code>git status --porcelain --branch &amp;&gt;/dev/null | $__GIT_PROMPT_DIR/src/.bin/gitstatus
</code></pre><p>versus</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$__GIT_PROMPT_DIR/src/.bin/git status &lt;/dev/null
</code></pre></div><p>The first showed me:</p>
<pre><code>master 95 0 0 0 1 1
</code></pre><p>and the second did not output anything. So clearly, it was receiving standard input from the <code>git status --porcelain --branch</code> command!</p>
<p>At this point, I was wondering, what the hell was going on? If all output from the <code>git status --porcelain --branch</code> command was redirected to <code>/dev/null</code>, shouldn&rsquo;t it effectively be doing the same thing as supplying no standard input to the next program?</p>
<p>I tried a few other things but this one kind of blew my mind:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">git status --porcelain --branch &amp;&gt;/dev/null &gt;a &gt;o
</code></pre></div><p>Both <code>a</code> and <code>o</code> contained the output of the command! Seems like there is multiple output redirection going on. Something I didn&rsquo;t know was possible.</p>
<p>A google search for &ldquo;stdout redirect to multiple linux&rdquo; turned out the usual answers (most commonly using <code>tee</code>), but also <a href="https://unix.stackexchange.com/a/129184">this answer on Unix &amp; Linux Stack Exchange</a>:</p>
<blockquote>
<p>With zsh:</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">ls &gt; file1 &gt; file2
</code></pre></div><blockquote>
<p>(internally, zsh creates a pipe and spawns a process that reads from that pipe and writes to the two files as tee does. ls stdout is the other end of the pipe).</p>
</blockquote>
<p>and also the <a href="https://unix.stackexchange.com/a/345508">following answer</a>:</p>
<blockquote>
<p>As @jofel mentioned in a comment under the answer, this can be done natively in zsh:</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">echo foobar &gt;file1 &gt;file2 &gt;file3
</code></pre></div><blockquote>
<p>or, with brace expansion:</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">echo foobar &gt;file<span style="color:#f92672">{</span>1..3<span style="color:#f92672">}</span>
</code></pre></div><blockquote>
<p>Internally this works very similarly to the tee answers provided above. The shell connects the command&rsquo;s stdout to a process that pipes to multiple files; therefore, there isn&rsquo;t any compelling technical advantage to doing it this way (but it does look real good). See the zsh manual for more.</p>
</blockquote>
<p>And it links to the <a href="http://zsh.sourceforge.net/Doc/Release/Redirection.html">Redirection chapter of the zsh manual</a>. Turns out zsh has a feature known as Multios that allows multiple output redirection. That section opens with:</p>
<blockquote>
<p>If the user tries to open a file descriptor for writing more than once, the shell opens the file descriptor as a pipe to a process that copies its input to all the specified outputs, similar to tee, provided the MULTIOS option is set, as it is by default. Thus:</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">date &gt;foo &gt;bar
</code></pre></div><blockquote>
<p>writes the date to two files, named ‘foo’ and ‘bar’. Note that a pipe is an implicit redirection; thus</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">date &gt;foo | cat
</code></pre></div><blockquote>
<p>writes the date to the file ‘foo’, and also pipes it to cat.</p>
</blockquote>
<p>So we totally misunderstood the context. Our premise of reasoning about the behavior of the command in Bash is totally wrong because we are not using Bash but zsh!</p>
<p>Therefore</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">git status --porcelain --branch &amp;&gt;/dev/null | $__GIT_PROMPT_DIR/src/.bin/gitstatus
</code></pre></div><p>does indeed redirect the standard output of <code>git status --porcelain --branch</code> to the <code>$__GIT_PROMPT_DIR/src/.bin/gitstatus</code> program.</p>
<p>Looking at the <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/stack.yaml#L30">lines 30 to 34 of stack.yaml</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yml" data-lang="yml"><span style="color:#75715e"># Extra directories used by stack for building</span>
<span style="color:#75715e"># extra-include-dirs: [/path/to/dir]</span>
<span style="color:#75715e"># extra-lib-dirs: [/path/to/dir]</span>

<span style="color:#66d9ef">local-bin-path</span>: <span style="color:#e6db74">&#39;./src/.bin&#39;</span>
</code></pre></div><p>and <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/git-prompt.cabal#L23">line 23 of src/git-prompt.cabal</a>:</p>
<pre><code>executable gitstatus
</code></pre><p>We see that <code>stack install</code> will indeed build a program named <code>gitstatus</code> and place it in the <code>src/.bin</code> directory of the repo. So indeed our guess that something else is piping its output as standard input to the main function of the zsh-git-prompt Haskell program is correct. So we explained a grand total of&hellip; one truly meaningful line of Haskell code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">main</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">IO</span> ()
<span style="color:#a6e22e">main</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- IO</span>
  status <span style="color:#f92672">&lt;-</span> getContents
</code></pre></div><p>Nevertheless, we have learnt a lot more about how zsh-git-prompt works overall. Let&rsquo;s return to our main function:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">main</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">IO</span> ()
<span style="color:#a6e22e">main</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- IO</span>
  status <span style="color:#f92672">&lt;-</span> getContents
  mhash <span style="color:#f92672">&lt;-</span> unsafeInterleaveIO gitrevparse <span style="color:#75715e">-- defer the execution until we know we need the hash</span>
  <span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- Maybe</span>
    strings <span style="color:#f92672">&lt;-</span> stringsFromStatus mhash status
    return (unwords strings)
  putStr (fromMaybe <span style="color:#e6db74">&#34;&#34;</span> result)
</code></pre></div><p>The next line of code is:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">  mhash <span style="color:#f92672">&lt;-</span> unsafeInterleaveIO gitrevparse <span style="color:#75715e">-- defer the execution until we know we need the hash</span>
</code></pre></div><p>and from our Hoogle search above:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">unsafeInterleaveIO</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">IO</span> a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">IO</span> a
<span style="color:#75715e">-- unsafeInterleaveIO allows an IO computation to be deferred lazily. When</span>
<span style="color:#75715e">-- passed a value of type IO a, the IO will only be performed when the value of</span>
<span style="color:#75715e">-- the a is demanded. This is used to implement lazy file reading, see</span>
<span style="color:#75715e">-- hGetContents.</span>
</code></pre></div><p>So <code>unsafeInterleaveIO gitrevparse</code> will only call the <code>gitrevparse</code> function when necessary. As for why it is unsafe, please read <a href="https://stackoverflow.com/questions/13263692/when-is-unsafeinterleaveio-unsafe">this Stack Overflow question and its answers</a>. Truth to be told, I do not know enough to explain it and any explanation will make this already long post even longer.</p>
<p>The <code>gitrevparse</code> function is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/app/Main.hs#L20">defined in the src/app/Main.hs file</a> and is as follows:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">gitrevparse</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">IO</span> (<span style="color:#66d9ef">Maybe</span> <span style="color:#66d9ef">Hash</span>)
<span style="color:#a6e22e">gitrevparse</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- IO</span>
    mresult <span style="color:#f92672">&lt;-</span> safeRun <span style="color:#e6db74">&#34;git&#34;</span> [<span style="color:#e6db74">&#34;rev-parse&#34;</span>, <span style="color:#e6db74">&#34;--short&#34;</span>, <span style="color:#e6db74">&#34;HEAD&#34;</span>]
    <span style="color:#66d9ef">let</span> rev <span style="color:#f92672">=</span> <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- Maybe</span>
      result <span style="color:#f92672">&lt;-</span> mresult
      return (<span style="color:#66d9ef">MkHash</span> (init result))
    return rev
</code></pre></div><p>Here is the <code>safeRun</code> function, <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/app/Main.hs#L14">also in the src/app/Main.hs file</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">safeRun</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">String</span> <span style="color:#f92672">-&gt;</span> [<span style="color:#66d9ef">String</span>] <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">IO</span> (<span style="color:#66d9ef">Maybe</span> <span style="color:#66d9ef">String</span>)
<span style="color:#a6e22e">safeRun</span> command arguments <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- IO</span>
    output <span style="color:#f92672">&lt;-</span> readProcessWithExitCode command arguments <span style="color:#e6db74">&#34;&#34;</span>
    return (successOrNothing output)
</code></pre></div><p>Some relevant documentation for the <code>System.Process.readProcessWithExitCode</code> function:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">readProcessWithExitCode</span>
  <span style="color:#f92672">::</span> <span style="color:#66d9ef">FilePath</span>                         <span style="color:#75715e">-- Filename of the executable</span>
  <span style="color:#f92672">-&gt;</span> [<span style="color:#66d9ef">String</span>]                         <span style="color:#75715e">-- any arguments</span>
  <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">String</span>                           <span style="color:#75715e">-- standard input</span>
  <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">IO</span> (<span style="color:#66d9ef">ExitCode</span>, <span style="color:#66d9ef">String</span>, <span style="color:#66d9ef">String</span>)    <span style="color:#75715e">-- exitcode, stdout, stderr</span>

<span style="color:#75715e">-- readProcessWithExitCode is like readProcess but with two differences:</span>
<span style="color:#75715e">-- * it returns the ExitCode of the process, and does not throw any exception if</span>
<span style="color:#75715e">--   the code is not ExitSuccess</span>
<span style="color:#75715e">-- * it reads and returns the output from process&#39; standard error handle, rather</span>
<span style="color:#75715e">--   than the process inheriting the standard error handle.</span>
</code></pre></div><p>Some relevant documentation for the <code>System.Process.readProcess</code> function:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">readProcess</span>
  <span style="color:#f92672">::</span> <span style="color:#66d9ef">FilePath</span>     <span style="color:#75715e">-- Filename of the executable (see RawCommand for details)</span>
  <span style="color:#f92672">-&gt;</span> [<span style="color:#66d9ef">String</span>]     <span style="color:#75715e">-- any arguments</span>
  <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">String</span>       <span style="color:#75715e">-- standard input</span>
  <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">IO</span> <span style="color:#66d9ef">String</span>    <span style="color:#75715e">-- stdout</span>

<span style="color:#75715e">-- readProcess forks an external process, reads its standard output strictly,</span>
<span style="color:#75715e">-- blocking until the process terminates, and returns the output string. The</span>
<span style="color:#75715e">-- external process inherits the standard error.</span>
<span style="color:#75715e">--</span>
<span style="color:#75715e">-- If an asynchronous exception is thrown to the thread executing readProcess,</span>
<span style="color:#75715e">-- the forked process will be terminated and readProcess will wait (block) until</span>
<span style="color:#75715e">-- the process has been terminated.</span>
<span style="color:#75715e">--</span>
<span style="color:#75715e">-- Output is returned strictly, so this is not suitable for interactive</span>
<span style="color:#75715e">-- applications.</span>
</code></pre></div><p>Hence, the following code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">gitrevparse</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">IO</span> (<span style="color:#66d9ef">Maybe</span> <span style="color:#66d9ef">Hash</span>)
<span style="color:#a6e22e">gitrevparse</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- IO</span>
    mresult <span style="color:#f92672">&lt;-</span> safeRun <span style="color:#e6db74">&#34;git&#34;</span> [<span style="color:#e6db74">&#34;rev-parse&#34;</span>, <span style="color:#e6db74">&#34;--short&#34;</span>, <span style="color:#e6db74">&#34;HEAD&#34;</span>]
    <span style="color:#75715e">-- some code omitted</span>

<span style="color:#a6e22e">safeRun</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">String</span> <span style="color:#f92672">-&gt;</span> [<span style="color:#66d9ef">String</span>] <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">IO</span> (<span style="color:#66d9ef">Maybe</span> <span style="color:#66d9ef">String</span>)
<span style="color:#a6e22e">safeRun</span> command arguments <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- IO</span>
    output <span style="color:#f92672">&lt;-</span> readProcessWithExitCode command arguments <span style="color:#e6db74">&#34;&#34;</span>
    return (successOrNothing output)
</code></pre></div><p>is equivalent to running <code>git rev-parse --short HEAD</code> on the command line while supplying the empty string as stdin, waits for it to finish, then send the <code>(ExitCode, stdout, stderr)</code> 3-tuple to the <code>successOrNothing</code> function, which is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/app/Main.hs#L10">also defined in the src/app/Main.hs file</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">successOrNothing</span> <span style="color:#f92672">::</span> (<span style="color:#66d9ef">ExitCode</span>, a, b) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Maybe</span> a
<span style="color:#a6e22e">successOrNothing</span> (exitCode, output, <span style="color:#66d9ef">_</span>) <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">if</span> exitCode <span style="color:#f92672">==</span> <span style="color:#66d9ef">ExitSuccess</span> <span style="color:#66d9ef">then</span> <span style="color:#66d9ef">Just</span> output <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">Nothing</span>
</code></pre></div><p><code>successOrNothing</code> is pretty straightforward; if our <code>git rev-parse --short HEAD</code> command exited successfully, then it will return the standard output string wrapped in a <code>Just</code>. Otherwise, it returns a <code>Nothing</code>.</p>
<p>Going back to the <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/app/Main.hs#L20">gitrevparse function</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">gitrevparse</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">IO</span> (<span style="color:#66d9ef">Maybe</span> <span style="color:#66d9ef">Hash</span>)
<span style="color:#a6e22e">gitrevparse</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- IO</span>
    mresult <span style="color:#f92672">&lt;-</span> safeRun <span style="color:#e6db74">&#34;git&#34;</span> [<span style="color:#e6db74">&#34;rev-parse&#34;</span>, <span style="color:#e6db74">&#34;--short&#34;</span>, <span style="color:#e6db74">&#34;HEAD&#34;</span>]
    <span style="color:#66d9ef">let</span> rev <span style="color:#f92672">=</span> <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- Maybe</span>
      result <span style="color:#f92672">&lt;-</span> mresult
      return (<span style="color:#66d9ef">MkHash</span> (init result))
    return rev
</code></pre></div><p>we see the use of the Maybe monad. If <code>git rev-parse --short HEAD</code> ran successfully, then <code>mresult</code> will be a <code>Just String</code>. The <code>result &lt;- mresult</code> will then extract the standard output string, and <code>init result</code> will return everything except the last character, which in this case is a newline. If you run <code>git rev-parse --short HEAD</code> in a git repo, its standard output will be a short git commit SHA1 similar to <code>055f126c</code> and ending with a newline. This git commit SHA1 is then passed to the <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/Utils.hs#L9">MkHash data constructor</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">Hash</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">MkHash</span> {getHash <span style="color:#f92672">::</span> <span style="color:#66d9ef">String</span>}
</code></pre></div><p>which turns out to be a newtype wrapper. The <code>return</code> then wraps the whole thing in a <code>Just</code> again.</p>
<p>To summarize what the <code>gitrevparse</code> function does:</p>
<ul>
<li>It runs <code>git rev-parse --short HEAD</code> and if successful, returns a <code>Just (MkHash s)</code> where <code>s</code> is a <code>String</code> wrapped in a <code>Hash</code> newtype that represents the git commit SHA1 that the HEAD is on</li>
<li>If <code>git rev-parse --short HEAD</code> fails, then a <code>Nothing</code> is returned.</li>
</ul>
<p>Let us revisit the main function again:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">main</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">IO</span> ()
<span style="color:#a6e22e">main</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- IO</span>
  status <span style="color:#f92672">&lt;-</span> getContents
  mhash <span style="color:#f92672">&lt;-</span> unsafeInterleaveIO gitrevparse <span style="color:#75715e">-- defer the execution until we know we need the hash</span>
  <span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- Maybe</span>
    strings <span style="color:#f92672">&lt;-</span> stringsFromStatus mhash status
    return (unwords strings)
  putStr (fromMaybe <span style="color:#e6db74">&#34;&#34;</span> result)
</code></pre></div><p>Tying all that we know so far, we may or may not need the output of <code>git rev-parse --short HEAD</code>, hence the use of <code>unsafeInterleaveIO</code> to defer the computation. This deferred <code>IO (Maybe Hash)</code> action, along with <code>status</code> (which contains the output of <code>git status --porcelain --branch &amp;&gt;/dev/null</code>) are passed to the <code>stringsFromStatus</code> function, which seems to be doing the bulk of the work. We know this because a Hoogle search shows the following docs for <code>unwords</code> and <code>fromMaybe</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">unwords</span> <span style="color:#f92672">::</span> [<span style="color:#66d9ef">String</span>] <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">String</span>
<span style="color:#75715e">-- unwords is an inverse operation to words. It joins words with separating</span>
<span style="color:#75715e">-- spaces.</span>

<span style="color:#a6e22e">fromMaybe</span> <span style="color:#f92672">::</span> a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Maybe</span> a <span style="color:#f92672">-&gt;</span> a
<span style="color:#75715e">-- The fromMaybe function takes a default value and a Maybe value. If the Maybe</span>
<span style="color:#75715e">-- is a Nothing, it returns the default value; otherwise it returns the value</span>
<span style="color:#75715e">-- contained in the Maybe.</span>
</code></pre></div><p>So we pretty much covered the main function. Let&rsquo;s get to the <code>stringsFromStatus</code> function next.</p>
<h2 id="the-stringsfromstatus-function">The <code>stringsFromStatus</code> function</h2>
<p>We can find the <code>stringsFromStatus</code> function in <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/Utils.hs#L64">src/src/Utils.hs</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">stringsFromStatus</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Maybe</span> <span style="color:#66d9ef">Hash</span>
                  <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">String</span> <span style="color:#75715e">-- status</span>
                  <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Maybe</span> [<span style="color:#66d9ef">String</span>]
<span style="color:#a6e22e">stringsFromStatus</span> h status <span style="color:#f92672">=</span> <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- List</span>
    processed <span style="color:#f92672">&lt;-</span> processGitStatus (lines status)
    return (showGitInfo h processed)
</code></pre></div><p>The comment on line 67 is a mistake; this function lives inside the <code>Maybe</code> monad, not the <code>List</code> monad. Anyways. Here is some relevant documentation for <code>lines</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">lines</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">String</span> <span style="color:#f92672">-&gt;</span> [<span style="color:#66d9ef">String</span>]
<span style="color:#75715e">-- lines breaks a string up into a list of strings at newline characters. The</span>
<span style="color:#75715e">-- resulting strings do not contain newlines.</span>
<span style="color:#75715e">-- Note that after splitting the string at newline characters, the last part of</span>
<span style="color:#75715e">-- the string is considered a line even if it doesn&#39;t end with a newline.</span>
</code></pre></div><p>So <code>lines status</code> will break the output of <code>git status --porcelain --branch</code>, which can consist of multiple lines, into a list of <code>String</code>, with each element in the list being one line in the original string. This list of strings is then passed to <code>processGitStatus</code>, <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/Utils.hs#L21">defined as follows</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">processGitStatus</span> <span style="color:#f92672">::</span> [<span style="color:#66d9ef">String</span>] <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Maybe</span> <span style="color:#66d9ef">GitInfo</span>
<span style="color:#a6e22e">processGitStatus</span> <span style="color:#66d9ef">[]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">Nothing</span>
<span style="color:#a6e22e">processGitStatus</span> (branchLine<span style="color:#66d9ef">:</span>statusLines) <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- Maybe</span>
      mbranch <span style="color:#f92672">&lt;-</span> processBranch branchLine
      status <span style="color:#f92672">&lt;-</span> processStatus statusLines
      return (<span style="color:#66d9ef">MkGitInfo</span> mbranch status)
</code></pre></div><p>As its name suggests, <code>processGitStatus</code> handles output from <code>git status</code>. Specifically, <code>git status --porcelain --branch &amp;&gt;/dev/null</code>.</p>
<p>We will deal with the easy case first, where <code>processGitStatus</code> pattern matches its first argument against the empty list. In this case, a <code>Nothing</code> is returned. This case happens when <code>git status --porcelain --branch &amp;&gt;/dev/null</code> does not print anything to standard output, which occurs when we are not in a git repo. (Verify it!)</p>
<p>The other pattern match will lead us deeper into the code. It is a pattern match against a non-empty list. For this pattern match, we see that the author once again uses the <code>do</code> notation and we are inside the <code>Maybe</code> monad. First, the head of the list is bound to <code>branchLine</code> and passed to the <code>processBranch</code> function, which also lives inside the <code>Maybe</code> monad.</p>
<p>To understand the motivation behind this code, we have to know what the <code>git status --porcelain --branch</code> command is outputting. Here is the <a href="https://git-scm.com/docs/git-status/2.15.0#git-status---porcelainltversiongt">documentation for the <code>--porcelain</code> flag from the git status 2.15.0 manpage</a>:</p>
<blockquote>
<p>&ndash;porcelain[=&lt;version&gt;]</p>
<p>\ \ Give the output in an easy-to-parse format for scripts. This is similar to the short output, but will remain stable across Git versions and regardless of user configuration. See below for details.</p>
<p>\ \ The version parameter is used to specify the format version. This is optional and defaults to the original version v1 format.</p>
</blockquote>
<p>and <a href="https://git-scm.com/docs/git-status/2.15.0#git-status--b">documentation for the <code>--branch</code> flag</a>:</p>
<blockquote>
<p>-b</p>
<p>--branch</p>
<p>\ \ Show the branch and tracking info even in short-format.</p>
</blockquote>
<p>and the final part of the <a href="https://git-scm.com/docs/git-status/2.15.0#_short_format">docs explaining the short-format output</a>:</p>
<blockquote>
<p>If -b is used the short-format status is preceded by a line</p>
<p>\ \ ## branchname tracking info</p>
</blockquote>
<p>Armed with this information, we know that <code>git status --porcelain --branch</code>:</p>
<ul>
<li>is a form of git status whose output is easy to parse for scripts and is similar to the short-format output</li>
<li>uses the porcelain v1 format</li>
<li>will show the branch and tracking info as the first line. This line looks similar to <code>&quot;  ## branchname tracking info&quot;</code> and is precisely what the <code>processGitStatus</code> function passes to the <code>processBranch</code> function</li>
</ul>
<p>The <code>processBranch</code> function is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/Utils.hs#L18">defined in the same file</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">processBranch</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">String</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Maybe</span> <span style="color:#66d9ef">MBranchInfo</span>
<span style="color:#a6e22e">processBranch</span> <span style="color:#f92672">=</span> rightOrNothing <span style="color:#f92672">.</span> branchInfo
</code></pre></div><p>From <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/Utils.hs#L4">line 4 of the same file</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">import</span> BranchParse (<span style="color:#66d9ef">Branch</span>(<span style="color:#66d9ef">MkBranch</span>), <span style="color:#66d9ef">MBranchInfo</span>, <span style="color:#66d9ef">BranchInfo</span>(<span style="color:#66d9ef">MkBranchInfo</span>), <span style="color:#a6e22e">branchInfo</span>, <span style="color:#a6e22e">getDistance</span>, <span style="color:#a6e22e">pairFromDistance</span>, <span style="color:#66d9ef">Remote</span>)
</code></pre></div><p>we see that both the <code>MBranchInfo</code> type and the <code>branchInfo</code> function are defined in <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs">src/src/BranchParse.hs</a>. That is where we shall go to next.</p>
<h2 id="the-branchinfo-function">The <code>branchInfo</code> function</h2>
<p>The <code>branchInfo</code> function is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L150">defined at line 150 of src/src/BranchParse.hs</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">branchInfo</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">String</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Either</span> <span style="color:#66d9ef">ParseError</span> <span style="color:#66d9ef">MBranchInfo</span>
<span style="color:#a6e22e">branchInfo</span> <span style="color:#f92672">=</span> parse branchParser&#39; <span style="color:#e6db74">&#34;&#34;</span>
</code></pre></div><p>The <code>parse</code> function is from the <a href="https://hackage.haskell.org/package/parsec">Parsec library</a>. I am not the best guy to explain what Parsec does even though I know how to use it, but a simple explanation is, Parsec allows one to write parsers that look and work very much the same way as <a href="https://en.wikipedia.org/wiki/Context-free_grammar">Context Free Grammars</a>. Since Context Free Languages are a superset of Regular Languages, by extension, one can use Parsec to write Regular Expressions as well (even though they will look like CFGs) - do note that regexes in many languages are not truly regular and I am not certain how much of these non-regular features Parsec provides.</p>
<p>The docs for <code>parse</code> are slightly&hellip; difficult. But we will be needing its type signature, so here goes:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">parse</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Stream</span> s <span style="color:#66d9ef">Identity</span> t <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">Parsec</span> s () a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">SourceName</span> <span style="color:#f92672">-&gt;</span> s <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Either</span> <span style="color:#66d9ef">ParseError</span> a
</code></pre></div><p>The simpler way to explain it is, it takes in a <code>Parsec</code> &ldquo;object&rdquo; which is the parser, followed by a <code>String</code> (actually a type synonym named <code>SourceName</code> that is equivalent to <code>String</code>; usually I just use the empty string), followed by a <code>String</code> / <code>Text</code> / similar (in this case a <code>String</code>) containing the content we want to parse using the parser given in the first argument. Note that currying is used here because only 2 arguments were given to <code>parse</code> when it needs 3; that is reflected in the type signature of <code>branchInfo</code>, because it returns a function that takes in a <code>String</code> argument.</p>
<p>On success, <code>parse</code> returns a <code>Right a</code>. Based on the type signature of <code>branchInfo</code>, this <code>a</code> is an <code>MBranchInfo</code> - that is defined in the same file. On failure, <code>parse</code> returns a <code>Left ParseError</code>; a <code>ParseError</code> is a data type defined in the Parsec library that represents, well, a parse error.</p>
<p>Before we get into <code>branchParser'</code>, recall how we got here. We were in the <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/Utils.hs#L23">second half of processGitStatus</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">processGitStatus</span> (branchLine<span style="color:#66d9ef">:</span>statusLines) <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- Maybe</span>
      mbranch <span style="color:#f92672">&lt;-</span> processBranch branchLine
</code></pre></div><p>where we were handed the first line in the output of <code>git status --porcelain --branch</code>, which is bound to <code>branchLine</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">processBranch</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">String</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Maybe</span> <span style="color:#66d9ef">MBranchInfo</span>
<span style="color:#a6e22e">processBranch</span> <span style="color:#f92672">=</span> rightOrNothing <span style="color:#f92672">.</span> branchInfo
</code></pre></div><p>And <code>processBranch</code> calls <code>branchInfo</code> and hands <code>branchLine</code> to it. Which <code>branchInfo</code> will now attempt to parse using the <code>branchParser'</code> parser.</p>
<h2 id="parsing-the-branch-line">Parsing the branch line</h2>
<p><code>branchParser'</code> is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L122">defined in src/src/Branchparse.hs</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">branchParser&#39;</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Parser</span> <span style="color:#66d9ef">MBranchInfo</span>
<span style="color:#a6e22e">branchParser&#39;</span> <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- Parsec</span>
    string <span style="color:#e6db74">&#34;## &#34;</span>
    branchParser
</code></pre></div><p><code>Parser</code> is a type synonym for <code>Parsec String ()</code> and is defined in <code>Text.Parsec.String</code> of the Parsec library. <code>MBranchInfo</code> is a type synonym for <code>Maybe BranchInfo</code> and is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L63">defined on line 63 of src/src/BranchParse.hs</a>. <code>BranchInfo</code> is a type constructor <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L61">defined on line 61 of src/src/BranchParse.hs</a>. Hence, <code>Parser MBranchInfo</code> expands to <code>Parsec String () (Maybe BranchInfo)</code>. What this means is, if there are no parsing errors, we get a <code>Maybe BranchInfo</code>. (Not exactly but we&rsquo;ll get to that later).</p>
<p>The <code>string</code> function is from the Parsec library. It literally looks for the string supplied to it in the content it is supposed to parse. In this case, it looks for the <code>## </code> string (there is a trailing space but it doesn&rsquo;t show up in the HTML here) in the first line of <code>git status --porcelain --branch</code>. If that line starts with the given string, we move on to the next parser ,<code>branchParser</code>. Otherwise, a <code>ParseError</code> results and parsing stops.</p>
<p>Note that the <code>branchParser'</code> code uses <code>do</code> notation (once again) but this time we are in the <code>Parser</code> or equivalently <code>Parsec String ()</code> monad.</p>
<p>Here is the <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L114">definition of branchParser</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">branchParser</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Parser</span> <span style="color:#66d9ef">MBranchInfo</span>
<span style="color:#a6e22e">branchParser</span> <span style="color:#f92672">=</span>
      try noBranch
    <span style="color:#f92672">&lt;|&gt;</span> try newRepo
    <span style="color:#f92672">&lt;|&gt;</span> try branchRemoteTracking
    <span style="color:#f92672">&lt;|&gt;</span> try branchRemote
    <span style="color:#f92672">&lt;|&gt;</span> branchOnly
</code></pre></div><p>This consumes the remaining of the line after the <code>##</code> (with a trailing space). <code>try</code> and <code>&lt;|&gt;</code> are both defined in the Parsec library and they are often used together. The documentation for <code>&lt;|&gt;</code> is especially good:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">(<span style="color:#f92672">&lt;|&gt;</span>) <span style="color:#f92672">::</span> <span style="color:#66d9ef">ParsecT</span> s u m a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">ParsecT</span> s u m a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">ParsecT</span> s u m a
<span style="color:#75715e">-- This combinator implements choice. The parser p &lt;|&gt; q first applies p. If it</span>
<span style="color:#75715e">-- succeeds, the value of p is returned. If p fails without consuming any input,</span>
<span style="color:#75715e">-- parser q is tried. This combinator is defined equal to the mplus member of</span>
<span style="color:#75715e">-- the MonadPlus class and the (&lt;|&gt;) member of Alternative.</span>
</code></pre></div><p>The initial part of the documentation for the <code>try</code> function is pretty good too:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">try</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">ParsecT</span> s u m a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">ParsecT</span> s u m a
<span style="color:#75715e">-- The parser try p behaves like parser p, except that it pretends that it</span>
<span style="color:#75715e">-- hasn&#39;t consumed any input when an error occurs.</span>
<span style="color:#75715e">--</span>
<span style="color:#75715e">-- This combinator is used whenever arbitrary look ahead is needed. Since it</span>
<span style="color:#75715e">-- pretends that it hasn&#39;t consumed any input when p fails, the (&lt;|&gt;) combinator</span>
<span style="color:#75715e">-- will try its second alternative even when the first parser failed while</span>
<span style="color:#75715e">-- consuming input.</span>
</code></pre></div><p>Essentially, <code>branchParser</code> will first attempt to parse the input string using the <code>try noBranch</code> parser, then if that fails, the <code>try</code> will ensure that no input is consumed by <code>noBranch</code> - and because no input is consumed, the <code>&lt;|&gt;</code> will then move on to the next parser, which is <code>try newRepo</code>. And if that fails, no input will be consumed, and it moves on to <code>try branchRemoteTracking</code>, and so on, in the specified order. If there is any successful parse, the parsing halts. People with knowledge of CFGs will appreciate how this code looks.</p>
<p>To understand each of these parsers, we need to play around with some git repositories and observe the output of the <code>git status --porcelain --branch</code> command. In this process, we will also be learning more about Parsec.</p>
<h3 id="the-nobranch-parser">The <code>noBranch</code> parser</h3>
<p>First off the list, the <code>noBranch</code> parser (<a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L71">defined here</a>):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">noBranch</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Parser</span> <span style="color:#66d9ef">MBranchInfo</span>
<span style="color:#a6e22e">noBranch</span> <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- Parsec</span>
    manyTill anyChar (try (string <span style="color:#e6db74">&#34; (no branch)&#34;</span>))
    eof
    return <span style="color:#66d9ef">Nothing</span>
</code></pre></div><p>The <code>manyTill</code>, <code>anyChar</code> and <code>eof</code> parsers are new to us. They are defined in the Parsec library and pretty much do what they say.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">manyTill</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Stream</span> s m t <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">ParsecT</span> s u m a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">ParsecT</span> s u m end <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">ParsecT</span> s u m [a]
<span style="color:#75715e">-- manyTill p end applies parser p zero or more times until parser end succeeds.</span>
<span style="color:#75715e">-- Returns the list of values returned by p.</span>

<span style="color:#a6e22e">anyChar</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Stream</span> s m <span style="color:#66d9ef">Char</span> <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">ParsecT</span> s u m <span style="color:#66d9ef">Char</span>
<span style="color:#75715e">-- This parser succeeds for any character. Returns the parsed character.</span>

<span style="color:#a6e22e">eof</span> <span style="color:#f92672">::</span> (<span style="color:#66d9ef">Stream</span> s m t, <span style="color:#66d9ef">Show</span> t) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">ParsecT</span> s u m ()
<span style="color:#75715e">-- This parser only succeeds at the end of the input. This is not a primitive</span>
<span style="color:#75715e">-- but it is defined using notFollowedBy.</span>
</code></pre></div><p>So <code>manyTill anyChar (try (string &quot; (no branch)&quot;))</code> will apply the <code>anyChar</code> parser zero or more times until the <code>try (string &quot; (no branch)&quot;)</code> parser succeeds. On success, it returns a list of all the <code>Char</code> consumed by <code>anyChar</code>. We know that the <code>string &quot; (no branch)&quot;</code> parser expects and consumes the string <code>&quot; (no branch)&quot;</code>; wrapping it in a <code>try</code> allows us to avoid a parse error while it is used in conjunction with <code>manyTill anyChar</code>, as more and more characters are consumed by repeated applications of <code>anyChar</code> until we finally encounter the string <code>&quot; (no branch)&quot;</code>. Then the <code>manyTill anyChar (try (string &quot; (no branch)&quot;))</code> parser succeeds.</p>
<p>The <code>eof</code> parser then expects us to have reached the end of the input. Or in this case, the end of the first line of the output of <code>git status --porcelain --branch</code>. If everything goes well, a <code>Parser Nothing</code> is returned.</p>
<p>To put this in simpler terms, <code>noBranch</code> is expecting a single line that looks like <code>abcdefgh ijklm nopqrs (no branch)</code>. Notice how the list of characters accumulated by <code>manyTill anyChar</code> are discarded.</p>
<p>We can probably guess that <code>noBranch</code> is meant for parsing a branch line for a git repo that isn&rsquo;t on a branch. This happens in the detached HEAD state. To see what the line looks like, simply go to any of your git repos with at least 2 commits, make sure you have committed / stashed all your changes, then run the following commands:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">git checkout -b HEAD~
git status --porcelain --branch
</code></pre></div><p>The first line should look similar to the following:</p>
<pre><code>## HEAD (no branch)
</code></pre><p>and this will be happily parsed by <code>branchParser'</code> first with <code>string &quot;## &quot;</code> followed by <code>branchParser</code> using the <code>try noBranch</code> parser, returning a <code>Parser Nothing</code>. So now we know that if <code>branchParser'</code> returns a <code>Parser Nothing</code>, then the git repo is in the detached HEAD state. Nice.</p>
<h3 id="the-newrepo-parser">The <code>newRepo</code> parser</h3>
<p>The <code>try newRepo</code> parser will be used by <code>branchParser</code> if parsing using <code>try noBranch</code> fails.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">branchParser</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Parser</span> <span style="color:#66d9ef">MBranchInfo</span>
<span style="color:#a6e22e">branchParser</span> <span style="color:#f92672">=</span>
      try noBranch
    <span style="color:#f92672">&lt;|&gt;</span> try newRepo
    <span style="color:#f92672">&lt;|&gt;</span> try branchRemoteTracking
    <span style="color:#f92672">&lt;|&gt;</span> try branchRemote
    <span style="color:#f92672">&lt;|&gt;</span> branchOnly
</code></pre></div><p><a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L65">Its definition</a> is as follows:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">newRepo</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Parser</span> <span style="color:#66d9ef">MBranchInfo</span>
<span style="color:#a6e22e">newRepo</span> <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- Parsec</span>
    string <span style="color:#e6db74">&#34;Initial commit on &#34;</span>
    branchOnly
</code></pre></div><p>Based on the <code>string &quot;Initial commit on &quot;</code> parser alone, we can safely assume that this is for a new git repo. By now, we are quite familiar with what <code>string</code> does, so let&rsquo;s look at the <code>branchOnly</code> parser, <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L106">defined here</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">branchOnly</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Parser</span> <span style="color:#66d9ef">MBranchInfo</span>
<span style="color:#a6e22e">branchOnly</span> <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- Parsec</span>
    branch <span style="color:#f92672">&lt;-</span> many (noneOf <span style="color:#e6db74">&#34; &#34;</span>)
    eof
    <span style="color:#66d9ef">let</span> bi <span style="color:#f92672">=</span> <span style="color:#66d9ef">MkBranchInfo</span> (<span style="color:#66d9ef">MkBranch</span> branch) <span style="color:#66d9ef">Nothing</span>
    return (<span style="color:#66d9ef">Just</span> bi)
</code></pre></div><p>Documentation for the <code>noneOf</code> parser combinator:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">noneOf</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Stream</span> s m <span style="color:#66d9ef">Char</span> <span style="color:#f92672">=&gt;</span> [<span style="color:#66d9ef">Char</span>] <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">ParsecT</span> s u m <span style="color:#66d9ef">Char</span>
<span style="color:#75715e">-- As the dual of oneOf, noneOf cs succeeds if the current is character not in</span>
<span style="color:#75715e">-- the supplied list of characters cs. Returns the parsed character.</span>

<span style="color:#75715e">-- Example code:</span>
    consonant <span style="color:#f92672">=</span> noneOf <span style="color:#e6db74">&#34;aeiou&#34;</span>
</code></pre></div><p>When used with <code>many</code>, this will consume as many characters as possible, as long as they are not the space character, and return the list of characters consumed. Notice that this time, the author binds the list of characters consumed by <code>many (noneOf &quot; &quot;)</code> to <code>branch</code>. Immediately following that, an <code>eof</code> is expected. Therefore, <code>branchOnly</code> expects the input to consist of only non space characters.</p>
<p>I was expecting <code>newRepo</code> to handle the first line of <code>git status --porcelain --branch</code> for new git repositories but that was not the case. On git 2.15.0 for a new repo initialized using <code>git init</code> but with zero commits, I am getting the following output:</p>
<pre><code>## No commits yet on master
</code></pre><p>That is in the Porcelain v1 output format, which zsh-git-prompt expects. Porcelain v2 is in a different format and is not supported by zsh-git-prompt. I do not see anything on my zsh prompt that indicates this new directory I ran <code>git init</code> in is a git repo. Since this doesn&rsquo;t work for a git repo that was just created using <code>git init</code> and has zero commits, I added the initial commit and ran <code>git status --porcelain --branch</code> again and&hellip; it wasn&rsquo;t what we are expecting but is instead <code>## master</code>. Changing the commit message to <code>Initial commit</code> and similar does not change anything too.</p>
<p>The only explanation I can come up with is this: perhaps the <code>git status</code> Porcelain format changed since the last version of zsh-git-prompt? After all, at this time of writing, the most recent commit was on 15 Feb 2016 and for v0.5, which is what we are studying right now.</p>
<p>Regardless, let&rsquo;s go back to <code>branchOnly</code> and go through the final 2 lines:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">    <span style="color:#66d9ef">let</span> bi <span style="color:#f92672">=</span> <span style="color:#66d9ef">MkBranchInfo</span> (<span style="color:#66d9ef">MkBranch</span> branch) <span style="color:#66d9ef">Nothing</span>
    return (<span style="color:#66d9ef">Just</span> bi)
</code></pre></div><p><code>MkBranch</code> is a newtype wrapper <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L38">defined at line 38 of src/src/BranchParse.hs</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">Branch</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">MkBranch</span> <span style="color:#66d9ef">String</span> <span style="color:#66d9ef">deriving</span> (<span style="color:#66d9ef">Eq</span>)
</code></pre></div><p>while <code>MkBranchInfo</code> is a data constructor <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L61">defined at line 61 of the same file</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">BranchInfo</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">MkBranchInfo</span> <span style="color:#66d9ef">Branch</span> (<span style="color:#66d9ef">Maybe</span> <span style="color:#66d9ef">Remote</span>) <span style="color:#66d9ef">deriving</span> (<span style="color:#66d9ef">Eq</span>, <span style="color:#66d9ef">Show</span>)
</code></pre></div><p>We can see that <code>Branch</code> just wraps a <code>String</code> that is a git branch name. <code>BranchInfo</code> has the one <code>MkBranchInfo</code> data constructor which takes in 2 arguments: a <code>Branch</code> and a <code>Maybe Remote</code>. We shall not cover the <code>Remote</code> type for now. Essentially, this code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">    <span style="color:#66d9ef">let</span> bi <span style="color:#f92672">=</span> <span style="color:#66d9ef">MkBranchInfo</span> (<span style="color:#66d9ef">MkBranch</span> branch) <span style="color:#66d9ef">Nothing</span>
    return (<span style="color:#66d9ef">Just</span> bi)
</code></pre></div><p>Creates a representation for a git branch with a <code>Nothing</code> for the <code>Maybe Remote</code> part, then returns a <code>Just BranchInfo</code> if the parsing succeeds.</p>
<p>Putting everything together:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">newRepo</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Parser</span> <span style="color:#66d9ef">MBranchInfo</span>
<span style="color:#a6e22e">newRepo</span> <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- Parsec</span>
    string <span style="color:#e6db74">&#34;Initial commit on &#34;</span>
    branchOnly

<span style="color:#a6e22e">branchOnly</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Parser</span> <span style="color:#66d9ef">MBranchInfo</span>
<span style="color:#a6e22e">branchOnly</span> <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- Parsec</span>
    branch <span style="color:#f92672">&lt;-</span> many (noneOf <span style="color:#e6db74">&#34; &#34;</span>)
    eof
    <span style="color:#66d9ef">let</span> bi <span style="color:#f92672">=</span> <span style="color:#66d9ef">MkBranchInfo</span> (<span style="color:#66d9ef">MkBranch</span> branch) <span style="color:#66d9ef">Nothing</span>
    return (<span style="color:#66d9ef">Just</span> bi)
</code></pre></div><p>We see that the <code>newRepo</code> parser expects a string similar to:</p>
<pre><code>Initial commit on some-branch-name
</code></pre><p>and on a successful parse, returns a <code>Just BranchInfo</code> which represents a git branch.</p>
<h3 id="the-branchremotetracking-parser">The <code>branchRemoteTracking</code> parser</h3>
<p>If both <code>try noBranch</code> and <code>try newRepo</code> fail, then <code>branchParser</code> tries the <code>try branchRemoteTracking</code> parser.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">branchParser</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Parser</span> <span style="color:#66d9ef">MBranchInfo</span>
<span style="color:#a6e22e">branchParser</span> <span style="color:#f92672">=</span>
      try noBranch
    <span style="color:#f92672">&lt;|&gt;</span> try newRepo
    <span style="color:#f92672">&lt;|&gt;</span> try branchRemoteTracking
    <span style="color:#f92672">&lt;|&gt;</span> try branchRemote
    <span style="color:#f92672">&lt;|&gt;</span> branchOnly
</code></pre></div><p>The <code>branchRemoteTracking</code> parser is the most complicated of the bunch, at line 84 of <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L84">src/src/BranchParse.hs</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">branchRemoteTracking</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Parser</span> <span style="color:#66d9ef">MBranchInfo</span>
<span style="color:#a6e22e">branchRemoteTracking</span> <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- Parsec</span>
    branch <span style="color:#f92672">&lt;-</span> trackedBranch
    tracking <span style="color:#f92672">&lt;-</span> many (noneOf <span style="color:#e6db74">&#34; &#34;</span>)
    char <span style="color:#e6db74">&#39; &#39;</span>
    behead <span style="color:#f92672">&lt;-</span> inBrackets
    <span style="color:#66d9ef">let</span> remote <span style="color:#f92672">=</span> <span style="color:#66d9ef">MkRemote</span> (<span style="color:#66d9ef">MkBranch</span> tracking) (<span style="color:#66d9ef">Just</span> behead)
    <span style="color:#66d9ef">let</span> bi <span style="color:#f92672">=</span> <span style="color:#66d9ef">MkBranchInfo</span> branch  (<span style="color:#66d9ef">Just</span> remote)
    return (<span style="color:#66d9ef">Just</span> bi)
</code></pre></div><p>Definition of <code>trackedBranch</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">trackedBranch</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Parser</span> <span style="color:#66d9ef">Branch</span>
<span style="color:#a6e22e">trackedBranch</span> <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- Parsec</span>
      b <span style="color:#f92672">&lt;-</span> manyTill anyChar (try (string <span style="color:#e6db74">&#34;...&#34;</span>))
      return (<span style="color:#66d9ef">MkBranch</span> b)
</code></pre></div><p>Our experience with Parsec tells us that <code>trackedBranch</code> will consume as many characters as possible until it hits the string <code>...</code>. The list of characters consumed is bound to <code>b</code> and then wrapped in the <code>MkBranch</code> newtype wrapper and returned.</p>
<p>Following that (still in <code>branchRemoteTracking</code>), <code>tracking &lt;- many (noneOf &quot; &quot;)</code> will consume as many characters as possible until it hits the space character. The list of characters consumed is bound to <code>tracking</code>. Subsequently, <code>char ' '</code> expects a single space character and consumes and discards it.</p>
<p><code>inBrackets</code> is defined as follows, <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L128">on line 128</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">inBrackets</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Parser</span> <span style="color:#66d9ef">Distance</span>
<span style="color:#a6e22e">inBrackets</span> <span style="color:#f92672">=</span> between (char <span style="color:#e6db74">&#39;[&#39;</span>) (char <span style="color:#e6db74">&#39;]&#39;</span>) (behind <span style="color:#f92672">&lt;|&gt;</span> try aheadBehind <span style="color:#f92672">&lt;|&gt;</span> ahead)
</code></pre></div><p>The <code>Distance</code> type constructor is defined at <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L21">line 21</a>, but I will be showing the comments from <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L11">lines 11 to 19</a> as well because they pretty much describe what we will be covering next:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#75715e">{-
</span><span style="color:#75715e"> The idea is to parse the first line of the git status command.
</span><span style="color:#75715e"> Such a line may look like:
</span><span style="color:#75715e">  ## master
</span><span style="color:#75715e">or
</span><span style="color:#75715e">  ## master...origin/master
</span><span style="color:#75715e">or
</span><span style="color:#75715e">  ## master...origin/master [ahead 3, behind 4]
</span><span style="color:#75715e"> -}</span>

<span style="color:#66d9ef">data</span> <span style="color:#66d9ef">Distance</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">Ahead</span> <span style="color:#66d9ef">Int</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">Behind</span> <span style="color:#66d9ef">Int</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">AheadBehind</span> <span style="color:#66d9ef">Int</span> <span style="color:#66d9ef">Int</span> <span style="color:#66d9ef">deriving</span> (<span style="color:#66d9ef">Eq</span>)
</code></pre></div><p>So <code>Distance</code> represents how many commits the current branch is ahead and/or behind its remote tracking branch; its data constructors are all aptly named.</p>
<p>Going back to <code>inBrackets</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">inBrackets</span> <span style="color:#f92672">=</span> between (char <span style="color:#e6db74">&#39;[&#39;</span>) (char <span style="color:#e6db74">&#39;]&#39;</span>) (behind <span style="color:#f92672">&lt;|&gt;</span> try aheadBehind <span style="color:#f92672">&lt;|&gt;</span> ahead)
</code></pre></div><p><code>between</code> is a function defined in the Parsec library. Documentation as follows:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">between</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Stream</span> s m t <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">ParsecT</span> s u m open <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">ParsecT</span> s u m close <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">ParsecT</span> s u m a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">ParsecT</span> s u m a
<span style="color:#75715e">-- between open close p parses open, followed by p and close. Returns the value returned by p.</span>
</code></pre></div><p>So essentially, <code>inBrackets</code> expects some string that satisfies one of <code>behind</code>, <code>try aheadBehind</code> or <code>ahead</code> in between a <code>[</code> and <code>]</code>. There is a subtlety with the use of <code>try</code> in <code>try aheadBehind</code> that we will explain later. Now, let&rsquo;s talk a look at <code>behind</code>, <code>aheadBehind</code> and <code>ahead</code>.</p>
<p><code>behind</code> is defined at <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L140">line 140 of src/src/BranchParse.hs</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">behind</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Parser</span> <span style="color:#66d9ef">Distance</span>
<span style="color:#a6e22e">behind</span> <span style="color:#f92672">=</span> makeAheadBehind <span style="color:#e6db74">&#34;behind&#34;</span> <span style="color:#66d9ef">Behind</span>
</code></pre></div><p>Recall that <code>Behind</code> is one of the data constrcutors of <code>Distance</code>. <code>makeAheadBehind</code> is defined at <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L131">line 131 of the same file</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">makeAheadBehind</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">String</span> <span style="color:#f92672">-&gt;</span> (<span style="color:#66d9ef">Int</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Distance</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Parser</span> <span style="color:#66d9ef">Distance</span>
<span style="color:#a6e22e">makeAheadBehind</span> name constructor <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- Parsec</span>
    string (name <span style="color:#f92672">++</span> <span style="color:#e6db74">&#34; &#34;</span>)
    dist <span style="color:#f92672">&lt;-</span> many1 digit
    return (constructor (read dist))
</code></pre></div><p>Documentation for <code>many1</code> and <code>digit</code>, both in the Parsec library:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">many1</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Stream</span> s m t <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">ParsecT</span> s u m a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">ParsecT</span> s u m [a]
<span style="color:#75715e">-- many1 p applies the parser p one or more times. Returns a list of the</span>
<span style="color:#75715e">-- returned values of p.</span>

<span style="color:#a6e22e">digit</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Stream</span> s m <span style="color:#66d9ef">Char</span> <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">ParsecT</span> s u m <span style="color:#66d9ef">Char</span>
<span style="color:#75715e">-- Parses a digit. Returns the parsed character.</span>
</code></pre></div><p>We see that <code>behind = makeAheadBehind &quot;behind&quot; Behind</code>. This will first consume the string <code>&quot;behind &quot;</code> (and discard it), then consume 1 or more digits and bind the list of digits to <code>dist</code>. Since <code>constructor</code> has type <code>Int -&gt; Distance</code>, <code>read dist</code> will convert the list of digits into an <code>Int</code>, then pass it to <code>constructor</code> to create a <code>Distance</code>. In this case, the <code>constructor</code> is the <code>Behind</code> data constructor, which takes in 1 <code>Int</code> and creates a <code>Distance</code>.</p>
<p>The <code>behind</code> parser wants to parse a string similar to <code>behind 5</code> and returns a <code>Behind n</code>. <code>inBrackets</code> can therefore consume a string similar to <code>[behind 5]</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">inBrackets</span> <span style="color:#f92672">=</span> between (char <span style="color:#e6db74">&#39;[&#39;</span>) (char <span style="color:#e6db74">&#39;]&#39;</span>) (behind <span style="color:#f92672">&lt;|&gt;</span> try aheadBehind <span style="color:#f92672">&lt;|&gt;</span> ahead)
</code></pre></div><p>The other possibility that <code>inBrackets</code> can go down is <code>try aheadBehind</code>. Let&rsquo;s look at the <code>aheadBehind</code> parser, <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L142">defined at line 142 of src/src/BranchParse.hs</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">aheadBehind</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Parser</span> <span style="color:#66d9ef">Distance</span>
<span style="color:#a6e22e">aheadBehind</span> <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- Parsec</span>
    <span style="color:#66d9ef">Ahead</span> aheadBy <span style="color:#f92672">&lt;-</span> ahead
    string <span style="color:#e6db74">&#34;, &#34;</span>
    <span style="color:#66d9ef">Behind</span> behindBy <span style="color:#f92672">&lt;-</span> behind
    return (<span style="color:#66d9ef">AheadBehind</span> aheadBy behindBy)
</code></pre></div><p><code>ahead</code> is defined at <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L138">line 138 of the same file</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">ahead</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Parser</span> <span style="color:#66d9ef">Distance</span>
<span style="color:#a6e22e">ahead</span> <span style="color:#f92672">=</span> makeAheadBehind <span style="color:#e6db74">&#34;ahead&#34;</span> <span style="color:#66d9ef">Ahead</span>
</code></pre></div><p><code>aheadBehind</code> will first call <code>ahead</code>, which calls <code>makeAheadBehind</code>, which consumes the string <code>&quot;ahead &quot;</code> (and discard it), then consume 1 or more digits and creates an <code>Ahead Int</code>. The <code>string &quot;, &quot;</code> will consume the string <code>&quot;, &quot;</code>. Next, <code>behind</code> springs into action (we covered that above) and consumes <code>&quot;behind &quot;</code> followed by 1 or more digits. Note that pattern matching is done to get the <code>Int</code> in the <code>Behind</code> so that the <code>Int</code> is bound to <code>behindBy</code>. Finally, an <code>AheadBehind Int Int</code> is created. All in all, <code>inBrackets</code> that goes down the route of <code>aheadBehind</code> consumes a string similar to the following:</p>
<pre><code>[ahead 13, behind 7]
</code></pre><p>Returning to <code>inBrackets</code> once again:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">inBrackets</span> <span style="color:#f92672">=</span> between (char <span style="color:#e6db74">&#39;[&#39;</span>) (char <span style="color:#e6db74">&#39;]&#39;</span>) (behind <span style="color:#f92672">&lt;|&gt;</span> try aheadBehind <span style="color:#f92672">&lt;|&gt;</span> ahead)
</code></pre></div><p>We see that the final possible branch is <code>ahead</code>. We have already covered this while going through <code>aheadBehind</code>. For completeness, if <code>inBrackets</code> goes down the route of <code>ahead</code>, a string similar to <code>[ahead 10]</code> is desired.</p>
<p>Earlier, we mentioned a subtlety in the use of <code>try</code> in <code>try aheadBehind</code> for the <code>inBrackets</code> parser. One might ask, why only wrap <code>aheadBehind</code> in a <code>try</code>? Why not wrap <code>behind</code> and <code>ahead</code> in <code>try</code> as well?</p>
<p>We do not have to wrap the <code>behind</code> parser in a <code>try</code>, because it uses the <code>string &quot;behind &quot;</code> parser to consume the string <code>&quot;behind &quot;</code>. Notice that the string <code>&quot;behind &quot;</code> and the string <code>&quot;ahead &quot;</code> differ in the first character (<code>b</code> vs. <code>a</code>) - this causes the <code>behind</code> parser to fail immediately <strong>without consuming any input</strong>. Since it does not consume any input, the <code>&lt;|&gt;</code> ensures that it will go on to try the next parser in <code>try aheadBehind</code>.</p>
<p>We see this fine print in the documentation for <code>(&lt;|&gt;)</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">(<span style="color:#f92672">&lt;|&gt;</span>) <span style="color:#f92672">::</span> <span style="color:#66d9ef">ParsecT</span> s u m a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">ParsecT</span> s u m a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">ParsecT</span> s u m a
<span style="color:#75715e">-- This combinator implements choice. The parser p &lt;|&gt; q first applies p. If it</span>
<span style="color:#75715e">-- succeeds, the value of p is returned. If p fails without consuming any input,</span>
<span style="color:#75715e">-- parser q is tried. This combinator is defined equal to the mplus member of</span>
<span style="color:#75715e">-- the MonadPlus class and the (&lt;|&gt;) member of Alternative.</span>
</code></pre></div><p>Specifically, the part that says <code>If p fails without consuming any input, parser q is tried.</code></p>
<p>There is overlap between strings that <code>aheadBehind</code> and <code>ahead</code> parse. <code>aheadBehind</code> expects strings of the form <code>ahead M, behind N</code>, while <code>ahead</code> expects a string similar to <code>ahead M</code>, with <code>M</code> and <code>N</code> being non negative integers. If we were to rearrange things and use <code>behind &lt;|&gt; ahead &lt;|&gt; try aheadBehind</code>, then for the input string <code>ahead 7, behind 9</code>, the <code>behind</code> parser will fail without consuming any input, then <code>&lt;|&gt;</code> will use the <code>ahead</code> parser to consume the string <code>&quot;ahead 7&quot;</code> and stop there. The <code>(behind &lt;|&gt; ahead &lt;|&gt; try aheadBehind)</code> parser succeeds, but <code>between (char '[') (char ']') (behind &lt;|&gt; try aheadBehind &lt;|&gt; ahead)</code> will fail because the next character is not a <code>]</code> but a <code>,</code>. Hence, <code>aheadBehind</code> must be attempted before <code>ahead</code>.</p>
<p>So we have established that <code>aheadBehind</code> must be attempted before <code>ahead</code>. Minimally, we have to use <code>behind &lt;|&gt; aheadBehind &lt;|&gt; ahead</code>. Now for the <code>try</code>. What happens if <code>behind &lt;|&gt; aheadBehind &lt;|&gt; ahead</code> parses the string <code>&quot;ahead 5&quot;</code> (which is valid for a git branch that is only ahead but not behind its remote tracking branch)? The <code>behind</code> parser fails without consuming any input, so <code>&lt;|&gt;</code> tries <code>aheadBehind</code>, which consumes the entire <code>&quot;ahead 5&quot;</code> but then that expects a <code>&quot;, &quot;</code>, so parsing fails. Because input was consumed, the next <code>&lt;|&gt;</code> does not try the <code>ahead</code> parser. Hence we need to wrap <code>aheadBehind</code> in a <code>try</code> so it will not consume any input on parse failure and chaining it with <code>&lt;|&gt; ahead</code> will move on to try the <code>ahead</code> parser.</p>
<p>Now that we know what the <code>inBrackets</code> parser does, we go back to what brought us here in the first place, <code>branchRemoteTracking</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">branchRemoteTracking</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Parser</span> <span style="color:#66d9ef">MBranchInfo</span>
<span style="color:#a6e22e">branchRemoteTracking</span> <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- Parsec</span>
    branch <span style="color:#f92672">&lt;-</span> trackedBranch
    tracking <span style="color:#f92672">&lt;-</span> many (noneOf <span style="color:#e6db74">&#34; &#34;</span>)
    char <span style="color:#e6db74">&#39; &#39;</span>
    behead <span style="color:#f92672">&lt;-</span> inBrackets
    <span style="color:#66d9ef">let</span> remote <span style="color:#f92672">=</span> <span style="color:#66d9ef">MkRemote</span> (<span style="color:#66d9ef">MkBranch</span> tracking) (<span style="color:#66d9ef">Just</span> behead)
    <span style="color:#66d9ef">let</span> bi <span style="color:#f92672">=</span> <span style="color:#66d9ef">MkBranchInfo</span> branch  (<span style="color:#66d9ef">Just</span> remote)
    return (<span style="color:#66d9ef">Just</span> bi)
</code></pre></div><p>Because <code>inBrackets</code> took a while to explain, if necessary, you might want to read what we previously covered for <code>branchRemoteTracking</code> to refresh your knowledge before carrying on.</p>
<p>To understand the data structures involved, we have to know what we are trying to do here. <code>branchRemoteTracking</code> is trying to parse a string where the current git branch that has a remote tracking branch and falls under one of the 3 cases:</p>
<ol>
<li>it is some commits ahead of its remote tracking branch</li>
<li>it is some commits behind its remote tracking branch</li>
<li>it is some commits ahead AND some commits behind its remote tracking branch</li>
</ol>
<p>An example of a string that satisfies case 3 is:</p>
<pre><code>master...origin/feat [ahead 5, behind 3]
</code></pre><p>Armed with this information, we know that</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">    <span style="color:#66d9ef">let</span> remote <span style="color:#f92672">=</span> <span style="color:#66d9ef">MkRemote</span> (<span style="color:#66d9ef">MkBranch</span> tracking) (<span style="color:#66d9ef">Just</span> behead)
</code></pre></div><p>Captures the information about the remote tracking branch in <code>MkBranch tracking</code> and the number of commits the current branch is ahead and/or behind the remote tracking branch in <code>Just behead</code>.</p>
<p>The <code>Remote</code> type constructor and the <code>MkRemote</code> data constructor are <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L56">defined at line 56 of src/src/BranchParse.hs</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">Remote</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">MkRemote</span> <span style="color:#66d9ef">Branch</span> (<span style="color:#66d9ef">Maybe</span> <span style="color:#66d9ef">Distance</span>) <span style="color:#66d9ef">deriving</span> (<span style="color:#66d9ef">Eq</span>, <span style="color:#66d9ef">Show</span>)
</code></pre></div><p>There is only 1 data constructor, <code>MkRemote</code>. We see that a remote represents a remote tracking branch (the <code>Branch</code> parameter) and the number of commits the current branch is ahead and/or behind this remote tracking branch (the <code>Maybe Distance</code> parameter). It is possible that the current branch and its remote tracking branch are in sync and <code>Maybe Distance</code> allows us to use <code>Nothing</code> to represent that.</p>
<p>The remaining lines in <code>branchRemoteTracking</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">    <span style="color:#66d9ef">let</span> bi <span style="color:#f92672">=</span> <span style="color:#66d9ef">MkBranchInfo</span> branch  (<span style="color:#66d9ef">Just</span> remote)
    return (<span style="color:#66d9ef">Just</span> bi)
</code></pre></div><p>creates a <code>BranchInfo</code> object using its single data constructor <code>MkBranchInfo</code>, passing in the current branch (in <code>branch</code>) and information about the remote tracking branch (in <code>Just remote</code>). Then it wraps the <code>BranchInfo</code> inside a <code>Just</code> and uses <code>return</code> on it.</p>
<p>Here&rsquo;s the definition for the <code>BranchInfo</code> type constructor:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">BranchInfo</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">MkBranchInfo</span> <span style="color:#66d9ef">Branch</span> (<span style="color:#66d9ef">Maybe</span> <span style="color:#66d9ef">Remote</span>) <span style="color:#66d9ef">deriving</span> (<span style="color:#66d9ef">Eq</span>, <span style="color:#66d9ef">Show</span>)
</code></pre></div><p>Earlier when we covered the <code>branchOnly</code> parser, we mentioned we will explain the <code>Maybe Remote</code> part in <code>MkBranchInfo</code>. See how <code>branchOnly</code> also uses <code>MkBranchInfo</code> but passes in a <code>Nothing</code> for the <code>Maybe Remote</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">branchOnly</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Parser</span> <span style="color:#66d9ef">MBranchInfo</span>
<span style="color:#a6e22e">branchOnly</span> <span style="color:#f92672">=</span>
    <span style="color:#75715e">-- omitted</span>
    <span style="color:#66d9ef">let</span> bi <span style="color:#f92672">=</span> <span style="color:#66d9ef">MkBranchInfo</span> (<span style="color:#66d9ef">MkBranch</span> branch) <span style="color:#66d9ef">Nothing</span>
    <span style="color:#75715e">-- omitted</span>
</code></pre></div><p>The <code>Nothing</code> indicates that there is no remote tracking branch for the current branch.</p>
<p>To summarize, the <code>branchRemoteTracking</code> parser wants to consume a string similar to one of the three variants below:</p>
<pre><code>master...origin/feat [ahead 7]
bourbon...origin/rice-noodles [ahead 10, behind 4]
fix-a-pesky-bug...workplace/nice-feature-work [behind 2]
</code></pre><p>In other words, a branch that has a remote tracking branch and is some commits ahead and/or behind that remote tracking branch.</p>
<h3 id="the-branchremote-parser">The <code>branchRemote</code> parser</h3>
<p>In the event that <code>try noBranch</code>, <code>try newRepo</code> and <code>try branchRemoteTracking</code> all fail, <code>branchParser</code> attempts the <code>try branchRemote</code> parser.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">branchParser</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Parser</span> <span style="color:#66d9ef">MBranchInfo</span>
<span style="color:#a6e22e">branchParser</span> <span style="color:#f92672">=</span>
      try noBranch
    <span style="color:#f92672">&lt;|&gt;</span> try newRepo
    <span style="color:#f92672">&lt;|&gt;</span> try branchRemoteTracking
    <span style="color:#f92672">&lt;|&gt;</span> try branchRemote
    <span style="color:#f92672">&lt;|&gt;</span> branchOnly
</code></pre></div><p>The <code>branchRemote</code> parser is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L96">defined at line 96 of src/src/BranchParse.hs</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">branchRemote</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Parser</span> <span style="color:#66d9ef">MBranchInfo</span>
<span style="color:#a6e22e">branchRemote</span> <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- Parsec</span>
    branch <span style="color:#f92672">&lt;-</span> trackedBranch
    tracking <span style="color:#f92672">&lt;-</span> many (noneOf <span style="color:#e6db74">&#34; &#34;</span>)
    eof
    <span style="color:#66d9ef">let</span> remote <span style="color:#f92672">=</span> <span style="color:#66d9ef">MkRemote</span> (<span style="color:#66d9ef">MkBranch</span> tracking) <span style="color:#66d9ef">Nothing</span>
    <span style="color:#66d9ef">let</span> bi <span style="color:#f92672">=</span> <span style="color:#66d9ef">MkBranchInfo</span> branch (<span style="color:#66d9ef">Just</span> remote)
    return (<span style="color:#66d9ef">Just</span> bi)
</code></pre></div><p>Its definition is eerily similar to that of <code>branchRemoteTracking</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">branchRemoteTracking</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Parser</span> <span style="color:#66d9ef">MBranchInfo</span>
<span style="color:#a6e22e">branchRemoteTracking</span> <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- Parsec</span>
    branch <span style="color:#f92672">&lt;-</span> trackedBranch
    tracking <span style="color:#f92672">&lt;-</span> many (noneOf <span style="color:#e6db74">&#34; &#34;</span>)
    char <span style="color:#e6db74">&#39; &#39;</span>
    behead <span style="color:#f92672">&lt;-</span> inBrackets
    <span style="color:#66d9ef">let</span> remote <span style="color:#f92672">=</span> <span style="color:#66d9ef">MkRemote</span> (<span style="color:#66d9ef">MkBranch</span> tracking) (<span style="color:#66d9ef">Just</span> behead)
    <span style="color:#66d9ef">let</span> bi <span style="color:#f92672">=</span> <span style="color:#66d9ef">MkBranchInfo</span> branch  (<span style="color:#66d9ef">Just</span> remote)
    return (<span style="color:#66d9ef">Just</span> bi)
</code></pre></div><p>Except that in terms of parsers, these 2 are not there:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">    char <span style="color:#e6db74">&#39; &#39;</span>
    behead <span style="color:#f92672">&lt;-</span> inBrackets
</code></pre></div><p>but are instead replaced by the <code>eof</code> parser, which expects there to be no more input.</p>
<p>With what we have covered for <code>branchRemoteTracking</code>, it should not be difficult to see that <code>branchRemote</code> expects a string similar to:</p>
<pre><code>refactoring...origin/refactoring
</code></pre><p>which is a git branch that has a remote tracking branch and is perfectly in sync with it. From</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">    <span style="color:#66d9ef">let</span> remote <span style="color:#f92672">=</span> <span style="color:#66d9ef">MkRemote</span> (<span style="color:#66d9ef">MkBranch</span> tracking) <span style="color:#66d9ef">Nothing</span>
    <span style="color:#66d9ef">let</span> bi <span style="color:#f92672">=</span> <span style="color:#66d9ef">MkBranchInfo</span> branch (<span style="color:#66d9ef">Just</span> remote)
</code></pre></div><p>we see that the 2nd argument to <code>MkRemote</code> is a <code>Nothing</code>, which indicates that the git branch and its remote tracking branch are perfectly in sync.</p>
<p>Due to the overlap between the strings that <code>branchRemoteTracking</code> and <code>branchRemote</code> parsers consume, specifically, that <code>branchRemoteTracking</code> will consume what <code>branchRemote</code> consumes and more, therefore, <code>try branchRemoteTracking</code> has to be attempted before <code>try branchRemote</code>.</p>
<h3 id="the-branchonly-parser">The <code>branchOnly</code> parser</h3>
<p>The final parser the <code>branchParser</code> will use, when all else fails, is the <code>branchOnly</code> parser:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">branchParser</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Parser</span> <span style="color:#66d9ef">MBranchInfo</span>
<span style="color:#a6e22e">branchParser</span> <span style="color:#f92672">=</span>
      try noBranch
    <span style="color:#f92672">&lt;|&gt;</span> try newRepo
    <span style="color:#f92672">&lt;|&gt;</span> try branchRemoteTracking
    <span style="color:#f92672">&lt;|&gt;</span> try branchRemote
    <span style="color:#f92672">&lt;|&gt;</span> branchOnly
</code></pre></div><p>Notice that it is not wrapped in a <code>try</code>, because this is the final parser in the chain and we do not need to care about whether input is consumed upon failure and we can just let it fail.</p>
<p><code>branchOnly</code> is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L106">defined at line 106 of src/src/BranchParse.hs</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">branchOnly</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Parser</span> <span style="color:#66d9ef">MBranchInfo</span>
<span style="color:#a6e22e">branchOnly</span> <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- Parsec</span>
    branch <span style="color:#f92672">&lt;-</span> many (noneOf <span style="color:#e6db74">&#34; &#34;</span>)
    eof
    <span style="color:#66d9ef">let</span> bi <span style="color:#f92672">=</span> <span style="color:#66d9ef">MkBranchInfo</span> (<span style="color:#66d9ef">MkBranch</span> branch) <span style="color:#66d9ef">Nothing</span>
    return (<span style="color:#66d9ef">Just</span> bi)
</code></pre></div><p>We have covered it when we went through the <code>newRepo</code> parser, so we shall not cover it here again. In short, <code>branchOnly</code> consumes a string containing just a branch name and has no remote tracking branch. To see this in an actual git repo, simply do a <code>git checkout -b some-crazy-weird-branch-name</code> and run <code>git status --porcelain --branch</code>. This first line in the output will look similar to:</p>
<pre><code>## some-crazy-weird-branch-name
</code></pre><p>Because this overlaps with what the <code>try branchRemoteTracking</code> and <code>try branchRemote</code> parsers consume, we have to attempt those before the <code>branchOnly</code> parser.</p>
<p>With that, we have completed our coverage of <code>branchParser</code>.</p>
<h2 id="summary-of-branchparser">Summary of <code>branchParser'</code></h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">branchParser&#39;</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Parser</span> <span style="color:#66d9ef">MBranchInfo</span>
<span style="color:#a6e22e">branchParser&#39;</span> <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- Parsec</span>
    string <span style="color:#e6db74">&#34;## &#34;</span>
    branchParser

<span style="color:#a6e22e">branchParser</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Parser</span> <span style="color:#66d9ef">MBranchInfo</span>
<span style="color:#a6e22e">branchParser</span> <span style="color:#f92672">=</span>
      try noBranch
    <span style="color:#f92672">&lt;|&gt;</span> try newRepo
    <span style="color:#f92672">&lt;|&gt;</span> try branchRemoteTracking
    <span style="color:#f92672">&lt;|&gt;</span> try branchRemote
    <span style="color:#f92672">&lt;|&gt;</span> branchOnly
</code></pre></div><p>To summarize <code>branchParser'</code>, below, we give one example on each line for each of the parsers that <code>branchParser</code> can use:</p>
<pre><code>## HEAD (no branch)
## Initial commit on something-that-doesnt-seem-to-work-for-git-2-15-0
## localbranch...remote/remote-tracking-branch [ahead 5, behind 5]
## localbranch...remote-two/another-remote-tracking-branch
## just-a-local-branch
</code></pre><h2 id="going-back-to-the-caller-of-branchparser">Going back to the caller of <code>branchParser'</code></h2>
<p>Now that we are done with <code>branchParser</code> (and <code>branchParser'</code>), we go back to what led us down this path:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">branchInfo</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">String</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Either</span> <span style="color:#66d9ef">ParseError</span> <span style="color:#66d9ef">MBranchInfo</span>
<span style="color:#a6e22e">branchInfo</span> <span style="color:#f92672">=</span> parse branchParser&#39; <span style="color:#e6db74">&#34;&#34;</span>

<span style="color:#a6e22e">processBranch</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">String</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Maybe</span> <span style="color:#66d9ef">MBranchInfo</span>
<span style="color:#a6e22e">processBranch</span> <span style="color:#f92672">=</span> rightOrNothing <span style="color:#f92672">.</span> branchInfo
</code></pre></div><p>On parse success, <code>branchInfo</code> returns a <code>Right MBranchInfo</code>. On parse failure, <code>branchInfo</code> returns a <code>Left ParseError</code>. Its calling function <code>processBranch</code> uses <code>rightOrNothing</code>, <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/Utils.hs#L15">defined at line 15 of src/src/Utils.hs</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">rightOrNothing</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Either</span> a b <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Maybe</span> b
<span style="color:#a6e22e">rightOrNothing</span> <span style="color:#f92672">=</span> either (const <span style="color:#66d9ef">Nothing</span>) <span style="color:#66d9ef">Just</span>
</code></pre></div><p>to convert a <code>Left ParseError</code> into a <code>Nothing</code>, and convert a <code>Right MBranchInfo</code> into a <code>Just MBranchInfo</code>. The <code>either</code> function is from the <code>Data.Either</code> module:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">either</span> <span style="color:#f92672">::</span> (a <span style="color:#f92672">-&gt;</span> c) <span style="color:#f92672">-&gt;</span> (b <span style="color:#f92672">-&gt;</span> c) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Either</span> a b <span style="color:#f92672">-&gt;</span> c
<span style="color:#75715e">-- Case analysis for the Either type. If the value is Left a, apply the first</span>
<span style="color:#75715e">-- function to a; if it is Right b, apply the second function to b.</span>
</code></pre></div><p>while the <code>const</code> function should be a familiar staple:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">const</span> <span style="color:#f92672">::</span> a <span style="color:#f92672">-&gt;</span> b <span style="color:#f92672">-&gt;</span> a
<span style="color:#75715e">-- const x is a unary function which evaluates to x for all inputs.</span>
<span style="color:#75715e">-- For instance,</span>
<span style="color:#75715e">-- &gt;&gt;&gt; map (const 42) [0..3]</span>
<span style="color:#75715e">-- [42, 42, 42, 42]</span>
</code></pre></div><p>Notice that <code>rightOrNothing</code> will discard the <code>ParseError</code> that is embedded in the <code>Left</code> on a parse failure. In other applications, the <code>ParseError</code> may be used to display a meaningful error message giving some hints as to why parsing failed. But in this case, we do not care for that.</p>
<p><code>processBranch</code> is invoked by <code>processGitStatus</code>, <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/Utils.hs#L21">defined at line 21 of src/src/Utils.hs</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">processGitStatus</span> <span style="color:#f92672">::</span> [<span style="color:#66d9ef">String</span>] <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Maybe</span> <span style="color:#66d9ef">GitInfo</span>
<span style="color:#a6e22e">processGitStatus</span> <span style="color:#66d9ef">[]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">Nothing</span>
<span style="color:#a6e22e">processGitStatus</span> (branchLine<span style="color:#66d9ef">:</span>statusLines) <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- Maybe</span>
      mbranch <span style="color:#f92672">&lt;-</span> processBranch branchLine
      status <span style="color:#f92672">&lt;-</span> processStatus statusLines
      return (<span style="color:#66d9ef">MkGitInfo</span> mbranch status)
</code></pre></div><p>On a successful parse of <code>branchLine</code> by <code>processBranch</code>, <code>mbranch</code> will be a <code>MBranchInfo</code>. Do note that we are in the <code>Maybe</code> monad. On an unsuccessful parse, <code>processBranch branchLine</code> will result in <code>Nothing</code> and the rest of the computations in <code>processGitStatus</code> will not be performed and a <code>Nothing</code> will be its return value.</p>
<p>We shall move on to <code>processStatus</code>, the next major piece of this program.</p>
<h2 id="the-processstatus-function">The <code>processStatus</code> function</h2>
<p><code>processStatus</code> is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/StatusParse.hs#L50">defined at line 50 of src/src/StatusParse.hs</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">processStatus</span> <span style="color:#f92672">::</span> [<span style="color:#66d9ef">String</span>] <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Maybe</span> (<span style="color:#66d9ef">Status</span> <span style="color:#66d9ef">Int</span>)
<span style="color:#a6e22e">processStatus</span> statLines <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- Maybe</span>
    statList <span style="color:#f92672">&lt;-</span> for statLines extractMiniStatus
    return (countStatus statList)
</code></pre></div><p>This function parses all the lines from 2nd line to the final line of the output of <code>git status --porcelain --branch</code>. The function <code>for</code> is defined in the <code>Data.Traversable</code> module:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">for</span> <span style="color:#f92672">::</span> (<span style="color:#66d9ef">Traversable</span> t, <span style="color:#66d9ef">Applicative</span> f) <span style="color:#f92672">=&gt;</span> t a <span style="color:#f92672">-&gt;</span> (a <span style="color:#f92672">-&gt;</span> f b) <span style="color:#f92672">-&gt;</span> f (t b)
<span style="color:#75715e">-- for is traverse with its arguments flipped. For a version that ignores the</span>
<span style="color:#75715e">-- results see for_</span>

<span style="color:#a6e22e">traverse</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Applicative</span> f <span style="color:#f92672">=&gt;</span> (a <span style="color:#f92672">-&gt;</span> f b) <span style="color:#f92672">-&gt;</span> t a <span style="color:#f92672">-&gt;</span> f (t b)
<span style="color:#75715e">-- Map each element of a structure to an action, evaluate these actions from</span>
<span style="color:#75715e">-- left to right, and collect the results. For a version that ignores the</span>
<span style="color:#75715e">-- results see traverse_</span>
</code></pre></div><p><code>traverse</code> is part of the <code>Traversable</code> type class. We include it here because <code>for</code> is defined in terms of <code>traverse</code>.</p>
<p>When we fit <code>for statLines extractMiniStatus</code> to the type signature of <code>for</code>, we get:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">for</span> <span style="color:#f92672">::</span> (<span style="color:#66d9ef">Applicative</span> f) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">[]</span> <span style="color:#66d9ef">String</span> <span style="color:#f92672">-&gt;</span> (<span style="color:#66d9ef">String</span> <span style="color:#f92672">-&gt;</span> f b) <span style="color:#f92672">-&gt;</span> f (<span style="color:#66d9ef">[]</span> b)
</code></pre></div><p>The <code>Traversable</code> here is the <code>[]</code> constructor (not to be confused with the empty list). <code>extractMiniStatus</code> is the <code>String -&gt; f b</code> function. It is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/StatusParse.hs#L45">defined at line 45 of src/src/StatusParse.hs</a> and has the following type signature:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">extractMiniStatus</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">String</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Maybe</span> <span style="color:#66d9ef">MiniStatus</span>
</code></pre></div><p><code>Maybe</code> is an Applicative, and we see that our <code>b</code> is <code>MiniStatus</code>. Using this new found information about the types, we have:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">for</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">[]</span> <span style="color:#66d9ef">String</span> <span style="color:#f92672">-&gt;</span> (<span style="color:#66d9ef">String</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Maybe</span> <span style="color:#66d9ef">MiniStatus</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Maybe</span> (<span style="color:#66d9ef">[]</span> <span style="color:#66d9ef">MiniStatus</span>)
</code></pre></div><p>Hence, <code>statList</code> in:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">statList</span> <span style="color:#f92672">&lt;-</span> for statLines extractMiniStatus
</code></pre></div><p>has type <code>[MiniStatus]</code>.</p>
<p><code>MiniStatus</code> is a type constructor <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/StatusParse.hs#L14">defined at line 14 of the same file</a>. To better explain things, we include the comment above it as well:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#75715e">{- The two characters starting a git status line: -}</span>
<span style="color:#66d9ef">data</span> <span style="color:#66d9ef">MiniStatus</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">MkMiniStatus</span> <span style="color:#66d9ef">Char</span> <span style="color:#66d9ef">Char</span>
</code></pre></div><p>Here is the definition of <code>extractMiniStatus</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">extractMiniStatus</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">String</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Maybe</span> <span style="color:#66d9ef">MiniStatus</span>
<span style="color:#a6e22e">extractMiniStatus</span> <span style="color:#66d9ef">[]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">Nothing</span>
<span style="color:#a6e22e">extractMiniStatus</span> [<span style="color:#66d9ef">_</span>] <span style="color:#f92672">=</span> <span style="color:#66d9ef">Nothing</span>
<span style="color:#a6e22e">extractMiniStatus</span> (index<span style="color:#66d9ef">:</span>work<span style="color:#66d9ef">:</span><span style="color:#66d9ef">_</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">Just</span> (<span style="color:#66d9ef">MkMiniStatus</span> index work)
</code></pre></div><p>We see that if a string has less than 2 characters, it returns a <code>Nothing</code>. Otherwise, it uses pattern matching to extract the first 2 characters and pass them to the <code>MkMiniStatus</code> data constructor. The author uses <code>index</code> and <code>work</code> for the name bindings for the first and second characters respectively, which is a hint that this has something to do with the git index and the work tree.</p>
<p>To understand the behavior of <code>for</code>, we look at <a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/src/Data.Traversable.html#for">its definition</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">for</span> <span style="color:#f92672">=</span> flip traverse
</code></pre></div><p>It is as the documentation says. This is not very meaningful, so we have to look at the <a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/src/Data.Traversable.html#line-235">definition of traverse for lists</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">instance</span> <span style="color:#66d9ef">Traversable</span> <span style="color:#66d9ef">[]</span> <span style="color:#66d9ef">where</span>
    <span style="color:#75715e">{-# INLINE traverse #-}</span> <span style="color:#75715e">-- so that traverse can fuse</span>
    traverse f <span style="color:#f92672">=</span> <span style="color:#66d9ef">List</span><span style="color:#f92672">.</span>foldr cons_f (pure <span style="color:#66d9ef">[]</span>)
      <span style="color:#66d9ef">where</span> cons_f x ys <span style="color:#f92672">=</span> liftA2 (<span style="color:#66d9ef">:</span>) (f x) ys
</code></pre></div><p>In our case, <code>extractMiniStatus</code> is the <code>f</code>. Notice the <code>liftA2 (:) (f x) ys</code>. If <code>f x</code> returns a <code>Nothing</code> at some point, then we have:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">liftA2</span> (<span style="color:#66d9ef">:</span>) <span style="color:#66d9ef">Nothing</span> ys
</code></pre></div><p>which should stay a <code>Nothing</code> for the remaining of the computation and there is no escape from it. But let us verify whether this is the case, by looking at <a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/src/GHC.Base.html#line-716">the definition of <code>liftA2</code> in the <code>Applicative</code> instance of <code>Maybe</code></a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">instance</span> <span style="color:#66d9ef">Applicative</span> <span style="color:#66d9ef">Maybe</span> <span style="color:#66d9ef">where</span>
    pure <span style="color:#f92672">=</span> <span style="color:#66d9ef">Just</span>

    <span style="color:#66d9ef">Just</span> f  <span style="color:#f92672">&lt;*&gt;</span> m       <span style="color:#f92672">=</span> fmap f m
    <span style="color:#66d9ef">Nothing</span> <span style="color:#f92672">&lt;*&gt;</span> _m      <span style="color:#f92672">=</span> <span style="color:#66d9ef">Nothing</span>

    liftA2 f (<span style="color:#66d9ef">Just</span> x) (<span style="color:#66d9ef">Just</span> y) <span style="color:#f92672">=</span> <span style="color:#66d9ef">Just</span> (f x y)
    liftA2 <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">_</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">Nothing</span>

    <span style="color:#66d9ef">Just</span> _m1 <span style="color:#f92672">*&gt;</span> m2      <span style="color:#f92672">=</span> m2
    <span style="color:#66d9ef">Nothing</span>  <span style="color:#f92672">*&gt;</span> _m2     <span style="color:#f92672">=</span> <span style="color:#66d9ef">Nothing</span>
</code></pre></div><p><code>liftA2 (:) Nothing ys</code> is covered by the case</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">    liftA2 <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">_</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">Nothing</span>
</code></pre></div><p>Therefore, once we get a <code>Nothing</code> in <code>traverse</code>, this definition of <code>liftA2</code> ensures that we will always get a <code>Nothing</code>. Which means that <code>extractMiniStatus</code> is banking on its final pattern match:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">extractMiniStatus</span> (index<span style="color:#66d9ef">:</span>work<span style="color:#66d9ef">:</span><span style="color:#66d9ef">_</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">Just</span> (<span style="color:#66d9ef">MkMiniStatus</span> index work)
</code></pre></div><p>for any meaningful computation to be done. The other pattern matches (which return <code>Nothing</code>) all indicate failure.</p>
<p>If the 2nd till the final line of <code>git status --porcelain --branch</code> <strong>all</strong> pattern match against the final pattern match in <code>extractMiniStatus</code>, then <code>for statusList extractMiniStatus</code> returns a <code>Just [MiniStatus]</code>. If even one line doesn&rsquo;t pattern match against the final pattern match, then <code>for statusList extractMiniStatus</code> returns a <code>Nothing</code>.</p>
<p>To understand what <code>extractMiniStatus</code> is pattern matching on, we quote some relevant documentation from the <a href="https://git-scm.com/docs/git-status/2.15.0#_short_format">short format section of the git status manpage for git 2.15.0</a>:</p>
<pre><code>In the short-format, the status of each path is shown as

    XY PATH1 -&gt; PATH2

where PATH1 is the path in the HEAD, and the &quot; -&gt; PATH 2&quot; part is shown only
when PATH1 corresponds to a different path in the index/worktree (i.e. the file
is renamed). The XY is a two-letter status code.

For paths with merge conflicts, X and Y show the modification states of each
side of the merge. For paths that do not have merge conflicts, X shows the
status of the index, and Y shows the status of the work tree. For untracked
paths, XY are ??. Other status codes can be interpreted as follows:

...omitted...
</code></pre><p>Indeed the first character of each line shows the state of the file in the index, while the second character shows the state of the file in the work tree. Notice how <code>extractMiniStatus</code> does not care about the rest of the characters on each line.</p>
<p>The final line of <code>processStatus</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">    return (countStatus statList)
</code></pre></div><p>calls the <code>countStatus</code> on the <code>[MiniStatus]</code> gathered, assuming all went well. If <code>for statusList extractMiniStatus</code> returns <code>Nothing</code>, then <code>processStatus</code> also returns a <code>Nothing</code>. Let us look at the <code>countStatus</code> function next.</p>
<h3 id="the-countstatus-function">The <code>countStatus</code> function</h3>
<p>The <code>countStatus</code> function is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/StatusParse.hs#L36">defined at line 36 of src/src/StatusParse.hs</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">countStatus</span> <span style="color:#f92672">::</span> [<span style="color:#66d9ef">MiniStatus</span>] <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Status</span> <span style="color:#66d9ef">Int</span>
<span style="color:#a6e22e">countStatus</span> l <span style="color:#f92672">=</span> <span style="color:#66d9ef">MakeStatus</span>
  {
  staged<span style="color:#f92672">=</span>countByType isStaged l,
  conflict<span style="color:#f92672">=</span>countByType isConflict l,
  changed<span style="color:#f92672">=</span>countByType isChanged l,
  untracked<span style="color:#f92672">=</span>countByType isUntracked l
  }
</code></pre></div><p>It returns a <code>Status Int</code>. The <code>Status</code> type constructor is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/StatusParse.hs#L7">defined at line 7 of the same file</a>. But we include the comment at line 6 as well:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#75715e">{- Full status information -}</span>
<span style="color:#66d9ef">data</span> <span style="color:#66d9ef">Status</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">MakeStatus</span> {
  staged <span style="color:#f92672">::</span> a,
  conflict <span style="color:#f92672">::</span> a,
  changed <span style="color:#f92672">::</span> a,
  untracked <span style="color:#f92672">::</span> a} <span style="color:#66d9ef">deriving</span> (<span style="color:#66d9ef">Eq</span>, <span style="color:#66d9ef">Show</span>)
</code></pre></div><p>With <code>Status Int</code>, all the fields in <code>MakeStatus</code> will be <code>Int</code>. This seems to be used to count the number of files in the git repo that are not in a &ldquo;clean&rdquo; state.</p>
<p>We see that the <code>countStatus</code> function uses the <code>countByType</code> function to compute each of the fields in <code>MakeStatus</code>. The <code>countByType</code> function is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/StatusParse.hs#L33">defined at line 33 of the same file</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">countByType</span> <span style="color:#f92672">::</span> (<span style="color:#66d9ef">MiniStatus</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Bool</span>) <span style="color:#f92672">-&gt;</span> [<span style="color:#66d9ef">MiniStatus</span>] <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Int</span>
<span style="color:#a6e22e">countByType</span> isType <span style="color:#f92672">=</span> length <span style="color:#f92672">.</span> filter isType
</code></pre></div><p><code>countByType</code> counts the number of lines in the <code>[MiniStatus]</code> computed by <code>for statusList extractMiniStatus</code> that fulfil the <code>isType</code> predicate. Based on the usage of <code>countByType</code> that we see in the <code>MakeStatus</code> data constructor, the <code>isStaged</code>, <code>isConflict</code>, <code>isChanged</code> and <code>isUntracked</code> predicates are used as the <code>isType</code> argument to <code>countByType</code>. Let&rsquo;s take a look at <code>isStaged</code>, <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/StatusParse.hs#L21">defined at line 21 of src/src/StatusParse.hs</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">isStaged</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">MiniStatus</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Bool</span>
<span style="color:#a6e22e">isStaged</span> (<span style="color:#66d9ef">MkMiniStatus</span> index work) <span style="color:#f92672">=</span>
    (index `elem` <span style="color:#e6db74">&#34;MRC&#34;</span>) <span style="color:#f92672">||</span> (index <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;D&#39;</span> <span style="color:#f92672">&amp;&amp;</span> work <span style="color:#f92672">/=</span> <span style="color:#e6db74">&#39;D&#39;</span>) <span style="color:#f92672">||</span> (index <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;A&#39;</span> <span style="color:#f92672">&amp;&amp;</span> work <span style="color:#f92672">/=</span> <span style="color:#e6db74">&#39;A&#39;</span>)
</code></pre></div><p>There are 3 distinct cases where <code>isStaged</code> returns <code>True</code>:</p>
<ol>
<li>First character of a status line is one of <code>M</code>, <code>R</code>, <code>C</code></li>
<li>First character of a status line is <code>D</code> and the second character is not <code>D</code></li>
<li>First character of a status line is <code>A</code> and the second character is not <code>A</code></li>
</ol>
<p>The code is simple enough, but what exactly do these characters stand for? To find out, we consult the <a href="https://git-scm.com/docs/git-status/2.15.0#_short_format">documentation for the short-format of <code>git status</code></a>:</p>
<pre><code>In the short-format, the status of each path is shown as

    XY PATH1 -&gt; PATH2

where PATH1 is the path in the HEAD, and the &quot; -&gt; PATH 2&quot; part is shown only
when PATH1 corresponds to a different path in the index/worktree (i.e. the file
is renamed). The XY is a two-letter status code.

For paths with merge conflicts, X and Y show the modification states of each
side of the merge. For paths that do not have merge conflicts, X shows the
status of the index, and Y shows the status of the work tree. For untracked
paths, XY are ??. Other status codes can be interpreted as follows:

- '' = unmodified
- M = modified
- A = added
- D = deleted
- R = renamed
- C = copied
- U = updated but unmerged

Ignored files are not listed, unless --ignored option is in effect, in which
case XY are !!.

X          Y     Meaning
-------------------------------------------------
          [MD]   not updated
M        [ MD]   updated in index
A        [ MD]   added to index
D         [ M]   deleted from index
R        [ MD]   renamed in index
C        [ MD]   copied in index
[MARC]           index and work tree matches
[ MARC]     M    work tree changed since index
[ MARC]     D    deleted in work tree
-------------------------------------------------
D           D    unmerged, both deleted
A           U    unmerged, added by us
U           D    unmerged, deleted by them
U           A    unmerged, added by them
D           U    unmerged, deleted by us
A           A    unmerged, both added
U           U    unmerged, both modified
-------------------------------------------------
?           ?    untracked
!           !    ignored
-------------------------------------------------
</code></pre><p>The table on the codes for <code>X</code> and <code>Y</code> are very useful to us and allows us to show some of the cases covered by the <code>isStaged</code> function.</p>
<p><code>index `elem` &quot;MRC&quot;</code> covers these cases:</p>
<pre><code>M        [ MD]   updated in index
R        [ MD]   renamed in index
C        [ MD]   copied in index
[MARC]           index and work tree matches
</code></pre><p><code>(index == 'D' &amp;&amp; work /= 'D')</code> covers these cases:</p>
<pre><code>D         [ M]   deleted from index
D           U    unmerged, deleted by us
</code></pre><p>while <code>(index == 'A' &amp;&amp; work /= 'A')</code> covers these cases:</p>
<pre><code>A        [ MD]   added to index
[MARC]           index and work tree matches
[ MARC]     M    work tree changed since index
[ MARC]     D    deleted in work tree
A           U    unmerged, added by us
</code></pre><p>But based on first principles, <code>index `elem` &quot;MRC&quot;</code> covers the case where the file in the index has been modified, renamed, or copied, relative to HEAD. Starting from a clean repository, <code>M</code> can be achieved by making a change to a file tracked by git and then using <code>git add</code> on that file. <code>R</code> can be achieved by using <code>git mv</code>. I have no idea how we can get a <code>C</code> but I am guessing it might have something to do with one of <code>git rebase</code>, <code>git merge</code>, <code>git am</code> and similar.</p>
<p>One way to satisfy <code>(index == 'D' &amp;&amp; work /= 'D')</code> is to use <code>git rm</code> on a tracked file. To be precise, that shows a <code>&quot;D &quot;</code> for the first character and a space for the second character. If the table is exhaustive, it seems that we are ok with every entry that has a <code>D</code> in the first character, except for this one case:</p>
<pre><code>D           D    unmerged, both deleted
</code></pre><p>which seems that it will only arise during a git merge when there&rsquo;s a merge conflict in another file that&rsquo;s awaiting the user to resolve manually or a similar situation involving some merge conflict - this is just a guess and I am not certain if I am correct.</p>
<p>One way to satisfy <code>(index == 'A' &amp;&amp; work /= 'A')</code> is to <code>git add</code> a previously untracked file. That gives us a <code>&quot;A &quot;</code> to be precise. It seems that we are trying to avoid this case:</p>
<pre><code>A           A    unmerged, both added
</code></pre><p>which once again seems that it will only arise during a merge conflict pending human resolution.</p>
<p>Whether these cases covered by the <code>isStaged</code> function are exhaustive, they all indicate that the file has changed in the index, relative to HEAD, except for in the case of merge conflicts.</p>
<p>We shall do a quick walkthrough of <code>isConflict</code>, <code>isChanged</code> and <code>isUntracked</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">isConflict</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">MiniStatus</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Bool</span>
<span style="color:#a6e22e">isConflict</span> (<span style="color:#66d9ef">MkMiniStatus</span> index work) <span style="color:#f92672">=</span>
    index <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;U&#39;</span> <span style="color:#f92672">||</span> work <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;U&#39;</span> <span style="color:#f92672">||</span> (index <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;A&#39;</span> <span style="color:#f92672">&amp;&amp;</span> work <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;A&#39;</span>) <span style="color:#f92672">||</span> (index <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;D&#39;</span> <span style="color:#f92672">&amp;&amp;</span> work <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;D&#39;</span>)
</code></pre></div><p>As its name suggests, <code>isConflict</code> covers the case where a file has a merge conflict.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">isChanged</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">MiniStatus</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Bool</span>
<span style="color:#a6e22e">isChanged</span> (<span style="color:#66d9ef">MkMiniStatus</span> index work) <span style="color:#f92672">=</span>
    work <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;M&#39;</span> <span style="color:#f92672">||</span> (work <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;D&#39;</span> <span style="color:#f92672">&amp;&amp;</span> index <span style="color:#f92672">/=</span> <span style="color:#e6db74">&#39;D&#39;</span>)
</code></pre></div><p><code>isChanged</code> takes care of files which are modified in the work tree relative to HEAD (<code>work == 'M'</code>) and files deleted from the work tree but not deleted in the index (can be gotten by using <code>rm</code> to remove a tracked file).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">isUntracked</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">MiniStatus</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Bool</span>
<span style="color:#a6e22e">isUntracked</span> (<span style="color:#66d9ef">MkMiniStatus</span> index <span style="color:#66d9ef">_</span>) <span style="color:#f92672">=</span>
    index <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;?&#39;</span>
</code></pre></div><p>and finally, <code>isUntracked</code> takes care of files which are not tracked by git.</p>
<p>Returning to <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/StatusParse.hs#L50">processStatus</a> and <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/StatusParse.hs#L36">countStatus</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">processStatus</span> <span style="color:#f92672">::</span> [<span style="color:#66d9ef">String</span>] <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Maybe</span> (<span style="color:#66d9ef">Status</span> <span style="color:#66d9ef">Int</span>)
<span style="color:#a6e22e">processStatus</span> statLines <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- Maybe</span>
    statList <span style="color:#f92672">&lt;-</span> for statLines extractMiniStatus
    return (countStatus statList)

<span style="color:#a6e22e">countStatus</span> <span style="color:#f92672">::</span> [<span style="color:#66d9ef">MiniStatus</span>] <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Status</span> <span style="color:#66d9ef">Int</span>
<span style="color:#a6e22e">countStatus</span> l <span style="color:#f92672">=</span> <span style="color:#66d9ef">MakeStatus</span>
  {
  staged<span style="color:#f92672">=</span>countByType isStaged l,
  conflict<span style="color:#f92672">=</span>countByType isConflict l,
  changed<span style="color:#f92672">=</span>countByType isChanged l,
  untracked<span style="color:#f92672">=</span>countByType isUntracked l
  }
</code></pre></div><p>we see that <code>for statLines extractMiniStatus</code> computes a list of <code>MkMiniStatus</code> from the output of <code>git status --porcelain --branch</code>. Then, <code>countStatus</code> is used to create a <code>Status</code> with 4 fields that counts the number of files which are modified in the index relative to the work tree (staged), in a merge conflict, modified in the work tree relative to HEAD (changed) and untracked. This <code>Status</code> is then wrapped in a <code>Just</code> and returned by <code>processStatus</code>.</p>
<p>In the event that some line in the output of <code>git status --porcelain --branch</code> has less than 2 characters, <code>for statLines extractMiniStatus</code> results in a <code>Nothing</code> and it is returned by <code>processStatus</code>, without running <code>return (countStats statList)</code>, because we are inside the <code>Maybe</code> monad.</p>
<p>That finishes our coverage of <code>processStatus</code>.</p>
<h2 id="going-back-to-processgitstatus">Going back to <code>processGitStatus</code></h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">processGitStatus</span> <span style="color:#f92672">::</span> [<span style="color:#66d9ef">String</span>] <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Maybe</span> <span style="color:#66d9ef">GitInfo</span>
<span style="color:#a6e22e">processGitStatus</span> <span style="color:#66d9ef">[]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">Nothing</span>
<span style="color:#a6e22e">processGitStatus</span> (branchLine<span style="color:#66d9ef">:</span>statusLines) <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- Maybe</span>
      mbranch <span style="color:#f92672">&lt;-</span> processBranch branchLine
      status <span style="color:#f92672">&lt;-</span> processStatus statusLines
      return (<span style="color:#66d9ef">MkGitInfo</span> mbranch status)
</code></pre></div><p>In the final line, <code>MkGitInfo mbranch status</code> constructs a <code>GitInfo</code> (<a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/Utils.hs#L11">defined at line 11 of src/src/Utils.hs</a>):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">GitInfo</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">MkGitInfo</span> <span style="color:#66d9ef">MBranchInfo</span> (<span style="color:#66d9ef">Status</span> <span style="color:#66d9ef">Int</span>)
</code></pre></div><p>which wraps over the <code>MBranchInfo</code> from <code>processBranch branchLine</code> and the <code>Status Int</code> from <code>processStatus statusLines</code>. Assuming everything went smoothly and both <code>processBranch</code> and <code>processStatus</code> returned <code>Just</code>s, the <code>GitInfo</code> itself will be wrapped inside <code>Just</code>. Otherwise, <code>processGitStatus</code> returns a <code>Nothing</code>.</p>
<p>The <code>GitInfo</code> value captures all the information obtained from the output of <code>git status --porcelain --branch</code>.</p>
<h2 id="going-back-to-stringsfromstatus">Going back to <code>stringsFromStatus</code></h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">stringsFromStatus</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Maybe</span> <span style="color:#66d9ef">Hash</span>
                  <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">String</span> <span style="color:#75715e">-- status</span>
                  <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Maybe</span> [<span style="color:#66d9ef">String</span>]
<span style="color:#a6e22e">stringsFromStatus</span> h status <span style="color:#f92672">=</span> <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- List</span>
    processed <span style="color:#f92672">&lt;-</span> processGitStatus (lines status)
    return (showGitInfo h processed)
</code></pre></div><p><code>stringsFromStatus</code> lives inside the <code>Maybe</code> monad. <code>processGitStatus</code> returns either a <code>Just GitStatus</code> or a <code>Nothing</code>. If it is a <code>Nothing</code>, everything else is skipped and <code>stringsFromStatus</code> returns a <code>Nothing</code>. If it is a <code>Just GitStatus</code>, the <code>GitStatus</code> is bound to <code>processed</code>. That, along with <code>h</code>, is passed to <code>showGitInfo</code>, <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/Utils.hs#L57">defined at line 57 of src/src/Utils.hs</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">showGitInfo</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Maybe</span> <span style="color:#66d9ef">Hash</span>
      <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">GitInfo</span>
      <span style="color:#f92672">-&gt;</span> [<span style="color:#66d9ef">String</span>]
<span style="color:#a6e22e">showGitInfo</span> mhash (<span style="color:#66d9ef">MkGitInfo</span> bi stat) <span style="color:#f92672">=</span> branchInfoString <span style="color:#f92672">++</span> showStatusNumbers stat
  <span style="color:#66d9ef">where</span>
    branchInfoString <span style="color:#f92672">=</span> showBranchInfo (branchOrHashWith <span style="color:#e6db74">&#39;:&#39;</span> mhash bi)
</code></pre></div><p>This pattern matches the <code>GitInfo</code> argument using its only <code>MkGitInfo</code> constructor and binds its 2 components to the names <code>bi</code> and <code>stat</code>.</p>
<p>Because the return type of <code>ShowGitInfo</code> is <code>[String]</code> and a <code>++</code> is used to concatenate <code>branchInfoString</code> and <code>showStatusNumbers stat</code>, this means that <code>branchInfoString</code> is a <code>[String]</code>.</p>
<p>Let&rsquo;s look at the <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/Utils.hs#L50">definition of <code>branchOrHashWith</code>, along with its comment at line 50</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#75715e">{- Combine status info, branch info and hash -}</span>

<span style="color:#a6e22e">branchOrHashWith</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Char</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Maybe</span> <span style="color:#66d9ef">Hash</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Maybe</span> <span style="color:#66d9ef">BranchInfo</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">BranchInfo</span>
<span style="color:#a6e22e">branchOrHashWith</span> <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">_</span> (<span style="color:#66d9ef">Just</span> bi) <span style="color:#f92672">=</span> bi
<span style="color:#a6e22e">branchOrHashWith</span> c (<span style="color:#66d9ef">Just</span> hash) <span style="color:#66d9ef">Nothing</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">MkBranchInfo</span> (<span style="color:#66d9ef">MkBranch</span> (c <span style="color:#66d9ef">:</span> getHash hash)) <span style="color:#66d9ef">Nothing</span>
<span style="color:#a6e22e">branchOrHashWith</span> <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">Nothing</span> <span style="color:#66d9ef">_</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">MkBranchInfo</span> (<span style="color:#66d9ef">MkBranch</span> <span style="color:#e6db74">&#34;&#34;</span>) <span style="color:#66d9ef">Nothing</span>
</code></pre></div><p>The first pattern match ignores the first 2 arguments and tries to pattern match against the <code>MBranchInfo</code> inside the <code>GitInfo</code>. Recall that this is the result of the <code>processBranch</code> function and captures all the important information about the current git branch. Also recall that <code>MBranchInfo</code> is a type synonym for <code>Maybe BranchInfo</code>. If this is a <code>Just</code>, then <code>branchOrHashWith</code> simply returns the <code>BranchInfo</code> value that&rsquo;s wrapped inside the <code>Just</code>.</p>
<p>The second pattern match covers the case where the return value from <code>processBranch</code> is a <code>Nothing</code>. This happens when parsing the branch line fails and we have no information on the current git branch. The second argument passed to <code>branchOrHashWith</code> is originally from the <code>main</code> function:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">main</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- IO</span>
  status <span style="color:#f92672">&lt;-</span> getContents
    mhash <span style="color:#f92672">&lt;-</span> unsafeInterleaveIO gitrevparse <span style="color:#75715e">-- defer the execution until we know we need the hash</span>
    <span style="color:#75715e">-- omitted</span>

<span style="color:#a6e22e">gitrevparse</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">IO</span> (<span style="color:#66d9ef">Maybe</span> <span style="color:#66d9ef">Hash</span>)
<span style="color:#a6e22e">gitrevparse</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- IO</span>
    mresult <span style="color:#f92672">&lt;-</span> safeRun <span style="color:#e6db74">&#34;git&#34;</span> [<span style="color:#e6db74">&#34;rev-parse&#34;</span>, <span style="color:#e6db74">&#34;--short&#34;</span>, <span style="color:#e6db74">&#34;HEAD&#34;</span>]
    <span style="color:#66d9ef">let</span> rev <span style="color:#f92672">=</span> <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- Maybe</span>
      result <span style="color:#f92672">&lt;-</span> mresult
      return (<span style="color:#66d9ef">MkHash</span> (init result))
    return rev
</code></pre></div><p>to be exact, it is the result of <code>unsafeInterleaveIO gitrevparse</code>, which is a deferred run of <code>git rev-parse --short HEAD</code>. This command shows the git commit SHA1 of the top most commit on the current git branch. We covered this early on and noted that the result of <code>unsafeInterleaveIO gitrevparse</code> will be a <code>Just Hash</code> if the <code>git rev-parse --short HEAD</code> runs successfully and a <code>Nothing</code> otherwise. So we finally see the purpose of this deferred computation: it allows us to obtain a git commit SHA1 as a fallback in the event that we cannot obtain any information about the git branch. The <code>unsafeInterleaveIO</code> will prevent it from running until it is actually needed.</p>
<p>Returning to the second pattern match of <code>branchOrHashWith</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">branchOrHashWith</span> c (<span style="color:#66d9ef">Just</span> hash) <span style="color:#66d9ef">Nothing</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">MkBranchInfo</span> (<span style="color:#66d9ef">MkBranch</span> (c <span style="color:#66d9ef">:</span> getHash hash)) <span style="color:#66d9ef">Nothing</span>
</code></pre></div><p>The <code>(Just hash)</code> will only pattern match on a successful executation of <code>git rev-parse --short HEAD</code>. The <code>c</code> here is a colon character. The <code>getHash</code> function is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/Utils.hs#L9">defined at line 9 of src/src/Utils.hs</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">Hash</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">MkHash</span> {getHash <span style="color:#f92672">::</span> <span style="color:#66d9ef">String</span>}
</code></pre></div><p><code>getHash hash</code> extracts the <code>String</code> that is wrapped by the <code>MkHash</code> newtype constructor, which is used by the <code>gitrevparse</code> function to wrap around the git commit SHA1 (except for the newline character).</p>
<p>Overall, this second pattern match of <code>branchOrHashWith</code> returns a <code>BranchInfo</code> value whose <code>Branch</code> component is the git commit SHA1 prepended with a colon character, and whose <code>Maybe Remote</code> component is a <code>Nothing</code>.</p>
<p>The third and final pattern match of <code>branchOrHashWith</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">branchOrHashWith</span> <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">Nothing</span> <span style="color:#66d9ef">_</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">MkBranchInfo</span> (<span style="color:#66d9ef">MkBranch</span> <span style="color:#e6db74">&#34;&#34;</span>) <span style="color:#66d9ef">Nothing</span>
</code></pre></div><p>covers the case where both parsing the branch line failed and the command <code>git rev-parse --short HEAD</code> failed. In this case, a <code>BranchInfo</code> object is created with the <code>Branch</code> component being a <code>MkBranch &quot;&quot;</code> and whose <code>Maybe Remote</code> component is a <code>Nothing</code>.</p>
<p>Going back to <code>showGitInfo</code>, we see that the <code>BranchInfo</code> returned by <code>branchOrHasWith</code> is passed to <code>showBranchInfo</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">    branchInfoString <span style="color:#f92672">=</span> showBranchInfo (branchOrHashWith <span style="color:#e6db74">&#39;:&#39;</span> mhash bi)
</code></pre></div><p>which is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/Utils.hs#L47">defined at line 47 of src/src/Utils.hs</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">showBranchInfo</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">BranchInfo</span> <span style="color:#f92672">-&gt;</span> [<span style="color:#66d9ef">String</span>]
<span style="color:#a6e22e">showBranchInfo</span> (<span style="color:#66d9ef">MkBranchInfo</span> branch mremote) <span style="color:#f92672">=</span> show branch <span style="color:#66d9ef">:</span> showRemoteNumbers mremote
</code></pre></div><p>This first runs <code>show branch</code> to convert the <code>Branch</code> value within <code>MkBranchInfo</code> into a <code>String</code>. The <code>Show</code> instance of <code>Branch</code> is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L40">defined at line 40 of src/src/BranchParse.hs</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">instance</span> <span style="color:#66d9ef">Show</span> <span style="color:#66d9ef">Branch</span> <span style="color:#66d9ef">where</span>
    show (<span style="color:#66d9ef">MkBranch</span> b) <span style="color:#f92672">=</span> b
</code></pre></div><p>Because <code>Branch</code> is just a newtype wrapper over <code>String</code>, this is essentially just returns the <code>String</code> that is being wrapped. The value of this <code>String</code> can be the current git branch name or if parsing the branch line fails, the current git commit SHA1 prepended by a colon, or if that fails, it will be the empty string.</p>
<p>This <code>String</code> is prepended to the <code>[String]</code> created by <code>showRemoteNumbers mremote</code>. The <code>showRemoteNumbers</code> function is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/Utils.hs#L35">defined at line 35 of src/src/Utils.hs</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">showRemoteNumbers</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Maybe</span> <span style="color:#66d9ef">Remote</span> <span style="color:#f92672">-&gt;</span> [<span style="color:#66d9ef">String</span>]
<span style="color:#a6e22e">showRemoteNumbers</span> mremote <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- List</span>
      ab <span style="color:#f92672">&lt;-</span> [ahead, behind]
      return (show ab)
  <span style="color:#66d9ef">where</span>
    (ahead, behind) <span style="color:#f92672">=</span> fromMaybe (<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>) distance  <span style="color:#75715e">-- the script needs some value, (0,0) means no display</span>
    distance <span style="color:#f92672">=</span> <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- Maybe</span>
      remote <span style="color:#f92672">&lt;-</span> mremote
      dist <span style="color:#f92672">&lt;-</span> getDistance remote
      return (pairFromDistance dist)
</code></pre></div><p>And it makes use of the list monad. The idea is simple. <code>ahead</code> and <code>behind</code> will each be bound to <code>ab</code> (one at a time) and then <code>show ab</code> converts it to a <code>String</code>, which will be in the resulting <code>[String]</code>. Hence the return value of <code>showRemoteNumbers</code> will always be a list of 2 strings.</p>
<p><code>ahead</code> and <code>behind</code> are defined in the <code>where</code> clause by <code>fromMaybe (0,0) distance</code>. The <code>fromMaybe</code> function is part of the <code>Data.Maybe</code> module. We covered it earlier but to refresh our memory, here is its documentation:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">fromMaybe</span> <span style="color:#f92672">::</span> a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Maybe</span> a <span style="color:#f92672">-&gt;</span> a
<span style="color:#75715e">-- The fromMaybe function takes a default value and a Maybe value. If the Maybe</span>
<span style="color:#75715e">-- is a Nothing, it returns the default values; otherwise, it returns the value</span>
<span style="color:#75715e">-- contained in the Maybe.</span>
</code></pre></div><p>If <code>distance</code> is a <code>Just _</code>, then we will be taking <code>(ahead, behind)</code> from inside it. Otherwise, <code>ahead</code> and <code>behind</code> will both be 0. <code>distance</code> is defined as follows:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">    distance <span style="color:#f92672">=</span> <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- Maybe</span>
      remote <span style="color:#f92672">&lt;-</span> mremote
      dist <span style="color:#f92672">&lt;-</span> getDistance remote
      return (pairFromDistance dist)
</code></pre></div><p>It lives in the <code>Maybe</code> monad. The <code>mremote</code> is the <code>Maybe Remote</code> part of the bigger <code>BranchInfo</code> value passed to <code>showBranchInfo</code>. If it is a <code>Nothing</code>, all bets are off and <code>fromMaybe (0,0) distance</code> will return <code>(0,0)</code>. This applies for the case where there is no information on the number of commits the current branch is ahead and/or behind its remote tracking branch, or perhaps the current branch does not have a remote tracking branch.</p>
<p>If there is a <code>Remote</code> value, it is bound to the name <code>remote</code> and passed to the <code>getDistance</code> function, <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L58">defined at line 58 of src/src/BranchParse.hs</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">getDistance</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Remote</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Maybe</span> <span style="color:#66d9ef">Distance</span>
<span style="color:#a6e22e">getDistance</span> (<span style="color:#66d9ef">MkRemote</span> <span style="color:#66d9ef">_</span> md) <span style="color:#f92672">=</span> md
</code></pre></div><p>Here is the definition of the <code>Remote</code> data type:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">Remote</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">MkRemote</span> <span style="color:#66d9ef">Branch</span> (<span style="color:#66d9ef">Maybe</span> <span style="color:#66d9ef">Distance</span>) <span style="color:#66d9ef">deriving</span> (<span style="color:#66d9ef">Eq</span>, <span style="color:#66d9ef">Show</span>)
</code></pre></div><p>so <code>getDistance</code> is essentially extracting the <code>Maybe Distance</code> part. This will only be a <code>Just</code> if parsing the branch line was successful and it is one of the following variants:</p>
<pre><code>## master...origin/feat [ahead 7]
## bourbon...origin/rice-noodles [ahead 10, behind 4]
## fix-a-pesky-bug...workplace/nice-feature-work [behind 2]
</code></pre><p>which will be parsed by the <code>branchParser'</code> parser using the <code>branchParser</code> parser which goes down the route of the <code>branchRemoteTracking</code> parser, all of which we covered earlier.</p>
<p>The <code>Distance</code> type is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L21">defined at line 21 of src/src/BranchParse.hs</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">Distance</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">Ahead</span> <span style="color:#66d9ef">Int</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">Behind</span> <span style="color:#66d9ef">Int</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">AheadBehind</span> <span style="color:#66d9ef">Int</span> <span style="color:#66d9ef">Int</span> <span style="color:#66d9ef">deriving</span> (<span style="color:#66d9ef">Eq</span>)
</code></pre></div><p>If <code>getDistance</code> extracts a <code>Just Distance</code> value, the <code>Distance</code> value is bound to the name <code>dist</code>, which is then passed to the <code>pairFromDistance</code> function, <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L153">defined at line 153 of src/src/BranchParse.hs</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">pairFromDistance</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Distance</span> <span style="color:#f92672">-&gt;</span> (<span style="color:#66d9ef">Int</span>, <span style="color:#66d9ef">Int</span>)
<span style="color:#a6e22e">pairFromDistance</span> (<span style="color:#66d9ef">Ahead</span> n) <span style="color:#f92672">=</span> (n,<span style="color:#ae81ff">0</span>)
<span style="color:#a6e22e">pairFromDistance</span> (<span style="color:#66d9ef">Behind</span> n) <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span>,n)
<span style="color:#a6e22e">pairFromDistance</span> (<span style="color:#66d9ef">AheadBehind</span> m n) <span style="color:#f92672">=</span> (m,n)
</code></pre></div><p>which covers all the different data constructors of <code>Distance</code>. It returns a 2 tuple, with each element being the number of commits the current branch is ahead or behind of its remote tracking branch, respectively.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">showRemoteNumbers</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Maybe</span> <span style="color:#66d9ef">Remote</span> <span style="color:#f92672">-&gt;</span> [<span style="color:#66d9ef">String</span>]
<span style="color:#a6e22e">showRemoteNumbers</span> mremote <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- List</span>
      ab <span style="color:#f92672">&lt;-</span> [ahead, behind]
      return (show ab)
  <span style="color:#66d9ef">where</span>
    (ahead, behind) <span style="color:#f92672">=</span> fromMaybe (<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>) distance  <span style="color:#75715e">-- the script needs some value, (0,0) means no display</span>
    distance <span style="color:#f92672">=</span> <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- Maybe</span>
      remote <span style="color:#f92672">&lt;-</span> mremote
      dist <span style="color:#f92672">&lt;-</span> getDistance remote
      return (pairFromDistance dist)
</code></pre></div><p>With our newfound knowledge, what <code>showRemoteNumbers</code> does is pretty obvious. It returns a list of 2 strings indicating how many commits the current branch is ahead or behind its remote tracking branch respectively, if applicable. Otherwise, both elements will be <code>&quot;0&quot;</code>.</p>
<p>Backtracking to <code>showBranchInfo</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">showBranchInfo</span> (<span style="color:#66d9ef">MkBranchInfo</span> branch mremote) <span style="color:#f92672">=</span> show branch <span style="color:#66d9ef">:</span> showRemoteNumbers mremote
</code></pre></div><p>We see that it returns a list of 3 strings:</p>
<ul>
<li>the current git branch / SHA1 / the empty string</li>
<li>the number of commits the current git branch is ahead of its remote tracking branch</li>
<li>the number of commits the current git branch is behind its remote tracking branch</li>
</ul>
<p>And backtracking to <code>showGitInfo</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">showGitInfo</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Maybe</span> <span style="color:#66d9ef">Hash</span>
      <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">GitInfo</span>
      <span style="color:#f92672">-&gt;</span> [<span style="color:#66d9ef">String</span>]
<span style="color:#a6e22e">showGitInfo</span> mhash (<span style="color:#66d9ef">MkGitInfo</span> bi stat) <span style="color:#f92672">=</span> branchInfoString <span style="color:#f92672">++</span> showStatusNumbers stat
  <span style="color:#66d9ef">where</span>
    branchInfoString <span style="color:#f92672">=</span> showBranchInfo (branchOrHashWith <span style="color:#e6db74">&#39;:&#39;</span> mhash bi)
</code></pre></div><p>After having generated the list of 3 strings in <code>branchInfoString</code>, we concatenate it with the result of <code>showStatusNumbers stat</code>, <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/Utils.hs#L29">defined at line 29 of src/src/Utils.hs</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">showStatusNumbers</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Status</span> <span style="color:#66d9ef">Int</span> <span style="color:#f92672">-&gt;</span> [<span style="color:#66d9ef">String</span>]
<span style="color:#a6e22e">showStatusNumbers</span> (<span style="color:#66d9ef">MakeStatus</span> s x c t) <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- List</span>
      nb <span style="color:#f92672">&lt;-</span> [s, x, c, t]
      return (show nb)
</code></pre></div><p>Looking at the definition of the <code>Status</code> data type:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#75715e">{- Full status information -}</span>
<span style="color:#66d9ef">data</span> <span style="color:#66d9ef">Status</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">MakeStatus</span> {
  staged <span style="color:#f92672">::</span> a,
  conflict <span style="color:#f92672">::</span> a,
  changed <span style="color:#f92672">::</span> a,
  untracked <span style="color:#f92672">::</span> a} <span style="color:#66d9ef">deriving</span> (<span style="color:#66d9ef">Eq</span>, <span style="color:#66d9ef">Show</span>)
</code></pre></div><p>we see that <code>showStatusNumbers</code> extracts the number of staged, conflicted, changed and untracked files, converts each of them to <code>String</code>, then packs them into a list.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">showGitInfo</span> mhash (<span style="color:#66d9ef">MkGitInfo</span> bi stat) <span style="color:#f92672">=</span> branchInfoString <span style="color:#f92672">++</span> showStatusNumbers stat
</code></pre></div><p>and <code>showGitInfo</code> combines all the information into one list of 7 elements, which are <code>String</code> versions of the following:</p>
<ul>
<li>the branch name / git commit sha1 / the empty string</li>
<li>the number of commits the current git branch is ahead of its remote tracking branch</li>
<li>the number of commits the current git branch is behind its remote tracking branch</li>
<li>the number of files that are modified in the index relative to HEAD</li>
<li>the number of files that are in a merge conflict</li>
<li>the number of files that are modified in the work tree relative to HEAD</li>
<li>the number of untracked files</li>
</ul>
<p>Backtracking to <code>stringsFromStatus</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">stringsFromStatus</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Maybe</span> <span style="color:#66d9ef">Hash</span>
                  <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">String</span> <span style="color:#75715e">-- status</span>
                  <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Maybe</span> [<span style="color:#66d9ef">String</span>]
<span style="color:#a6e22e">stringsFromStatus</span> h status <span style="color:#f92672">=</span> <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- List</span>
    processed <span style="color:#f92672">&lt;-</span> processGitStatus (lines status)
    return (showGitInfo h processed)
</code></pre></div><p>If <code>processGitStatus</code> returns a <code>Just GitInfo</code>, the <code>GitInfo</code> is bound to the name <code>processed</code>, then <code>showGitInfo h processed</code> is executed and the list it returns is wrapped inside a <code>Just</code> and returned by <code>stringsFromStatus</code>. If <code>processGitStatus</code> returns a <code>Nothing</code>, then <code>stringsFromStatus</code> returns a <code>Nothing</code>.</p>
<h2 id="backtracking-to-the-main-function">Backtracking to the <code>main</code> function</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">main</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">IO</span> ()
<span style="color:#a6e22e">main</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- IO</span>
  status <span style="color:#f92672">&lt;-</span> getContents
  mhash <span style="color:#f92672">&lt;-</span> unsafeInterleaveIO gitrevparse <span style="color:#75715e">-- defer the execution until we know we need the hash</span>
  <span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> <span style="color:#66d9ef">do</span> <span style="color:#75715e">-- Maybe</span>
    strings <span style="color:#f92672">&lt;-</span> stringsFromStatus mhash status
    return (unwords strings)
  putStr (fromMaybe <span style="color:#e6db74">&#34;&#34;</span> result)
</code></pre></div><p>If <code>stringsFromStatus</code> returns a <code>Just [String]</code>, the <code>[String]</code> is bound to <code>strings</code>. The <code>unwords</code> function then joins the <code>String</code>s in the list together into one big <code>String</code>, with each <code>String</code> in the list separated by a space character. This <code>Maybe String</code> is then bound to the <code>result</code> let binding. If <code>result</code> is a <code>Just String</code>, then <code>putStr (fromMaybe &quot;&quot; result)</code> will print the <code>String</code> to standard output; otherwise it will print the empty string to standard output.</p>
<p>And&hellip; we are done with our main function.</p>
<p>The rest of the post covers how the output of this Haskell program is used to generate a prompt containing information about the git repo.</p>
<h2 id="generating-the-prompt">Generating the prompt</h2>
<p>Very early on, we briefly covered the <code>update_current_git_vars</code> function <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/zshrc.sh#L43">defined in line 43 of zshrc.sh</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-zsh" data-lang="zsh"><span style="color:#66d9ef">function</span> update_current_git_vars<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    unset __CURRENT_GIT_STATUS

    <span style="color:#66d9ef">if</span> <span style="color:#f92672">[[</span> <span style="color:#e6db74">&#34;</span>$GIT_PROMPT_EXECUTABLE<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;python&#34;</span> <span style="color:#f92672">]]</span>; <span style="color:#66d9ef">then</span>
        local gitstatus<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$__GIT_PROMPT_DIR<span style="color:#e6db74">/gitstatus.py&#34;</span>
        _GIT_STATUS<span style="color:#f92672">=</span><span style="color:#e6db74">`</span>python <span style="color:#e6db74">${</span>gitstatus<span style="color:#e6db74">}</span> 2&gt;/dev/null<span style="color:#e6db74">`</span>
    <span style="color:#66d9ef">fi</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">[[</span> <span style="color:#e6db74">&#34;</span>$GIT_PROMPT_EXECUTABLE<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;haskell&#34;</span> <span style="color:#f92672">]]</span>; <span style="color:#66d9ef">then</span>
        _GIT_STATUS<span style="color:#f92672">=</span><span style="color:#e6db74">`</span>git status --porcelain --branch &amp;&gt; /dev/null | $__GIT_PROMPT_DIR/src/.bin/gitstatus<span style="color:#e6db74">`</span>
    <span style="color:#66d9ef">fi</span>
     __CURRENT_GIT_STATUS<span style="color:#f92672">=(</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>(@s: :)_GIT_STATUS<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">)</span>
  GIT_BRANCH<span style="color:#f92672">=</span>$__CURRENT_GIT_STATUS<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span>
  GIT_AHEAD<span style="color:#f92672">=</span>$__CURRENT_GIT_STATUS<span style="color:#f92672">[</span>2<span style="color:#f92672">]</span>
  GIT_BEHIND<span style="color:#f92672">=</span>$__CURRENT_GIT_STATUS<span style="color:#f92672">[</span>3<span style="color:#f92672">]</span>
  GIT_STAGED<span style="color:#f92672">=</span>$__CURRENT_GIT_STATUS<span style="color:#f92672">[</span>4<span style="color:#f92672">]</span>
  GIT_CONFLICTS<span style="color:#f92672">=</span>$__CURRENT_GIT_STATUS<span style="color:#f92672">[</span>5<span style="color:#f92672">]</span>
  GIT_CHANGED<span style="color:#f92672">=</span>$__CURRENT_GIT_STATUS<span style="color:#f92672">[</span>6<span style="color:#f92672">]</span>
  GIT_UNTRACKED<span style="color:#f92672">=</span>$__CURRENT_GIT_STATUS<span style="color:#f92672">[</span>7<span style="color:#f92672">]</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>This is the line that runs the Haskell program to process the output of <code>git status --porcelain --branch</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-zsh" data-lang="zsh">        _GIT_STATUS<span style="color:#f92672">=</span><span style="color:#e6db74">`</span>git status --porcelain --branch &amp;&gt; /dev/null | $__GIT_PROMPT_DIR/src/.bin/gitstatus<span style="color:#e6db74">`</span>
</code></pre></div><p>and the output of the Haskell program is stored in the <code>_GIT_STATUS</code> variable. The line</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-zsh" data-lang="zsh">__CURRENT_GIT_STATUS<span style="color:#f92672">=(</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>(@s: :)_GIT_STATUS<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">)</span>
</code></pre></div><p>splits the <code>_GIT_STATUS</code> variable using space as the delimiter and stores the result as an array in the <code>__CURRENT_GIT_STATUS</code> variable. Right after that</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-zsh" data-lang="zsh">  GIT_BRANCH<span style="color:#f92672">=</span>$__CURRENT_GIT_STATUS<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span>
  GIT_AHEAD<span style="color:#f92672">=</span>$__CURRENT_GIT_STATUS<span style="color:#f92672">[</span>2<span style="color:#f92672">]</span>
  GIT_BEHIND<span style="color:#f92672">=</span>$__CURRENT_GIT_STATUS<span style="color:#f92672">[</span>3<span style="color:#f92672">]</span>
  GIT_STAGED<span style="color:#f92672">=</span>$__CURRENT_GIT_STATUS<span style="color:#f92672">[</span>4<span style="color:#f92672">]</span>
  GIT_CONFLICTS<span style="color:#f92672">=</span>$__CURRENT_GIT_STATUS<span style="color:#f92672">[</span>5<span style="color:#f92672">]</span>
  GIT_CHANGED<span style="color:#f92672">=</span>$__CURRENT_GIT_STATUS<span style="color:#f92672">[</span>6<span style="color:#f92672">]</span>
  GIT_UNTRACKED<span style="color:#f92672">=</span>$__CURRENT_GIT_STATUS<span style="color:#f92672">[</span>7<span style="color:#f92672">]</span>
</code></pre></div><p>we see that the author makes the assumption that there are 7 elements in the <code>__CURRENT_GIT_STATUS</code> array and assigns each element to a variable. These are the same 7 elements in the list created by the <code>showGitInfo</code> Haskell function.</p>
<p>We go back to the <code>git_super_status</code> function, <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/zshrc.sh#L64">defined at line 64 of zshrc.sh</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-zsh" data-lang="zsh">git_super_status<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
  precmd_update_git_vars
  <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> -n <span style="color:#e6db74">&#34;</span>$__CURRENT_GIT_STATUS<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
    STATUS<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$ZSH_THEME_GIT_PROMPT_PREFIX$ZSH_THEME_GIT_PROMPT_BRANCH$GIT_BRANCH<span style="color:#e6db74">%{</span><span style="color:#e6db74">${</span>reset_color<span style="color:#e6db74">}</span><span style="color:#e6db74">%}&#34;</span>
    <span style="color:#75715e"># omitted</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>In the <code>if</code> statement, <code>__CURRENT_GIT_STATUS</code> variable is checked for non emptiness. If so, <code>STATUS</code> is assigned a value which begins with <code>$ZSH_THEME_GIT_PROMPT_PREFIX</code>, <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/zshrc.sh#L96">defined at line 96 of zshrc.sh</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-zsh" data-lang="zsh">ZSH_THEME_GIT_PROMPT_PREFIX<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;(&#34;</span>
</code></pre></div><p>followed by <code>$ZSH_THEME_GIT_PROMPT_BRANCH</code>, <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/zshrc.sh#L99">defined at line 99 of the same file</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-zsh" data-lang="zsh">ZSH_THEME_GIT_PROMPT_BRANCH<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;%{</span>$fg_bold<span style="color:#e6db74">[magenta]%}&#34;</span>
</code></pre></div><p>This changes the foreground color (text color) to magenta.</p>
<p>This is followed by <code>$GIT_BRANCH</code>, which gives us the branch name produced by the Haskell program. Then we have a <code>%{${reset_color}%}</code> which resets the foreground color.</p>
<p>If the current directory is in a git repo and the branch is named <code>my-branch</code>, the <code>STATUS</code> variable will have the following value:</p>
<pre><code>(my-branch
</code></pre><p>Next up, we have the following code inside the overall <code>if</code> branch in <code>git_super_status</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-zsh" data-lang="zsh">    <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> <span style="color:#e6db74">&#34;</span>$GIT_AHEAD<span style="color:#e6db74">&#34;</span> -ne <span style="color:#e6db74">&#34;0&#34;</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
      STATUS<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$STATUS$ZSH_THEME_GIT_PROMPT_AHEAD$GIT_AHEAD<span style="color:#e6db74">%{</span><span style="color:#e6db74">${</span>reset_color<span style="color:#e6db74">}</span><span style="color:#e6db74">%}&#34;</span>
    <span style="color:#66d9ef">fi</span>
</code></pre></div><p>This appends extra stuff to <code>STATUS</code>, <strong>but only if <code>GIT_AHEAD</code> is a non-zero value</strong>. It starting with <code>ZSH_THEME_GIT_PROMPT_AHEAD</code>, <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/zshrc.sh#L104">defined at line 104 of zshrc.sh</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-zsh" data-lang="zsh">ZSH_THEME_GIT_PROMPT_AHEAD<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;%{UpArrow%G%}&#34;</span>
</code></pre></div><p>There is an up arrow character ↑ which I have replaced with the text <code>UpArrow</code> because of some technical issues that prevents it from rendering in a code block.</p>
<p>This is then followed by <code>GIT_AHEAD</code>, which is the number of git commits the current branch is ahead of its remote tracking branch (if any). Then we have another <code>%{${reset_color}%}</code>.</p>
<p>The <code>%{UpArrow%G%}</code> is used to include a &lsquo;glitch&rsquo; to output the ↑ character. According to <a href="http://zsh.sourceforge.net/Doc/Release/Prompt-Expansion.html">zsh documentation</a>:</p>
<blockquote>
<p>%G</p>
<p>Within a %{&hellip;%} sequence, include a ‘glitch’: that is, assume that a single character width will be output. This is useful when outputting characters that otherwise cannot be correctly handled by the shell, such as the alternate character set on some terminals. The characters in question can be included within a %{&hellip;%} sequence together with the appropriate number of %G sequences to indicate the correct width. An integer between the ‘%’ and ‘G’ indicates a character width other than one. Hence %{seq%2G%} outputs seq and assumes it takes up the width of two standard characters.</p>
<p>Multiple uses of %G accumulate in the obvious fashion; the position of the %G is unimportant. Negative integers are not handled.</p>
<p>Note that when prompt truncation is in use it is advisable to divide up output into single characters within each %{&hellip;%} group so that the correct truncation point can be found.</p>
</blockquote>
<p>Building on our hypothetical example, if <code>my-branch</code> is 5 commits ahead of its remote tracking branch, the <code>GIT_AHEAD</code> variable will have value 5 and the <code>STATUS</code> variable will have the value <code>(my-branch↑5</code>. However, if <code>my-branch</code> is not ahead of its remote tracking branch, then <code>GIT_AHEAD</code> will be zero and <code>STATUS</code> will still be <code>(my-branch</code>.</p>
<p>The next line in <code>git_super_status</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-zsh" data-lang="zsh">    STATUS<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$STATUS$ZSH_THEME_GIT_PROMPT_SEPARATOR<span style="color:#e6db74">&#34;</span>
</code></pre></div><p>appends <code>ZSH_THEME_GIT_PROMPT_SEPARATOR</code>, which is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/zshrc.sh#L98">defined at line 98</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-zsh" data-lang="zsh">ZSH_THEME_GIT_PROMPT_SEPARATOR<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;|&#34;</span>
</code></pre></div><p>so it is a pipe character. This separates the (git branch, number of commits ahead and number of commits behind) from the rest of the information.</p>
<p>The rest of the code in <code>git_super_status</code> is of a similar nature and we shall not go through them here. We make an exception for line 91, where <code>echo &quot;$STATUS&quot;</code> prints the prompt that is built. For zsh-git-prompt to display iinformation about a git repo, code which calls the <code>git_super_status</code> function has to be at the user&rsquo;s <code>~/.zshrc</code> (or included by it). <a href="https://github.com/olivierverdier/zsh-git-prompt/tree/v0.5#install">Example code from the README</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">source path/to/zshrc.sh
<span style="color:#75715e"># an example prompt</span>
PROMPT<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;%B%m%~%b$(git_super_status) %# &#39;</span>
</code></pre></div><p>The prompt from the <code>STATUS</code> variable printed by the <code>git_super_status</code> function will be part of the <code>PROMPT</code> variable, which presumably forms the actual prompt that the user sees. Thus when the user is in a directory which is a git repository, information about that repository will be shown.</p>
<p>Note that in <code>git_super_status</code>, if <code>__CURRENT_GIT_STATUS</code> is empty, which can happen from either a failure to parse the branch line or a failure to parse any of the status lines from the output of <code>git status --porcelain --branch</code>, then <code>git_super_status</code> will not print anything and hence in</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-zsh" data-lang="zsh">PROMPT<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;%B%m%~%b$(git_super_status) %# &#39;</span>
</code></pre></div><p>the <code>$(git_super_status)</code> part will interpolate to nothing. A &ldquo;conventional&rdquo; prompt will be shown.</p>
<p>With that, our deep dive into zsh-git-prompt has come to an end.</p>
<h2 id="conclusion--ramblings">Conclusion / Ramblings</h2>
<p>We have not covered all the important code in the zsh-git-prompt repo, only the code that is actually run during normal usage. There are some <a href="https://github.com/olivierverdier/zsh-git-prompt/tree/v0.5/src/test">test code in the src/test directory</a> that the reader might want to take a look at, along with supporting code that is littered throughout the main code but used in tests as well. For instance, line 28 of <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L28">src/src/BranchParse.hs</a>. This code offers some insight on how one can use the venerable <a href="https://hackage.haskell.org/package/QuickCheck">QuickCheck library</a> for testing Haskell code. I could go through that in a follow up post, or maybe not, because it has taken me about a week of my free time to write this post and I need to get back to other stuff I was working on.</p>
<p>This is a pretty intense post (hence I called it a deep dive) and sometimes even I was lost in the details (but I managed to find my way back). The parts where I pasted previously discussed code was more for myself to refresh my memory than for you the reader. If you have made it all the way here and understood most of the content, then you deserve a pat on the back and my mission was successful.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="https://github.com/olivierverdier/zsh-git-prompt">https://github.com/olivierverdier/zsh-git-prompt</a> (zsh-git-prompt GitHub repo)</li>
<li><a href="https://unix.stackexchange.com/a/129184">https://unix.stackexchange.com/a/129184</a> (Unix &amp; Linux Stack Exchange: Redirect output of a command to two different files)</li>
<li><a href="https://unix.stackexchange.com/a/345508">https://unix.stackexchange.com/a/345508</a> (Unix &amp; Linux Stack Exchange: how to redirect output to multiple log files)</li>
<li><a href="http://zsh.sourceforge.net/Doc/Release/Redirection.html">http://zsh.sourceforge.net/Doc/Release/Redirection.html</a> (The Z Shell Manual chapter 7: Redirection)</li>
<li><a href="https://stackoverflow.com/q/13263692">https://stackoverflow.com/q/13263692</a> (Stack Overflow: When is unsafeInterleaveIO unsafe?)</li>
<li><a href="http://hackage.haskell.org/package/base-4.10.1.0/docs/System-IO-Unsafe.html#v:unsafeInterleaveIO">http://hackage.haskell.org/package/base-4.10.1.0/docs/System-IO-Unsafe.html#v:unsafeInterleaveIO</a> (unsafeInterleaveIO documentation)</li>
<li><a href="http://hackage.haskell.org/package/process-1.6.2.0/docs/System-Process.html#v:readProcessWithExitCode">http://hackage.haskell.org/package/process-1.6.2.0/docs/System-Process.html#v:readProcessWithExitCode</a> (readProcessWithExitCode documentation)</li>
<li><a href="http://hackage.haskell.org/package/process-1.6.2.0/docs/System-Process.html#v:readProcess">http://hackage.haskell.org/package/process-1.6.2.0/docs/System-Process.html#v:readProcess</a> (readProcess documentation)</li>
<li><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:unwords">http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:unwords</a> (unwords documentation)</li>
<li><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#v:fromMaybe">http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#v:fromMaybe</a> (fromMaybe documentation)</li>
<li><a href="http://hackage.haskell.org/package/base-4.10.1.0/docs/Prelude.html#v:lines">http://hackage.haskell.org/package/base-4.10.1.0/docs/Prelude.html#v:lines</a> (lines documentation)</li>
<li><a href="https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html#v:parse">https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html#v:parse</a> (parse documentation)</li>
<li><a href="https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html#v:-60--124--62-">https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html#v:-60&ndash;124&ndash;62-</a> ((&lt;|&gt;) documentation)</li>
<li><a href="https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html#v:try">https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html#v:try</a> (try documentation)</li>
<li><a href="https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html#v:manyTill">https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html#v:manyTill</a> (manyTill documentation)</li>
<li><a href="https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec-Char.html#v:anyChar">https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec-Char.html#v:anyChar</a> (anyChar documentation)</li>
<li><a href="https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html#v:eof">https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html#v:eof</a> (eof documentation)</li>
<li><a href="https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec-Char.html#v:noneOf">https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec-Char.html#v:noneOf</a> (noneOf documentation)</li>
<li><a href="https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html#v:between">https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html#v:between</a> (between documentation)</li>
<li><a href="https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html#v:many1">https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html#v:many1</a> (many1 documentation)</li>
<li><a href="https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec-Char.html#v:digit">https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec-Char.html#v:digit</a> (digit documentation)</li>
<li><a href="http://hackage.haskell.org/package/base-4.10.1.0/docs/Prelude.html#v:either">http://hackage.haskell.org/package/base-4.10.1.0/docs/Prelude.html#v:either</a> (either documentation)</li>
<li><a href="http://hackage.haskell.org/package/base-4.10.1.0/docs/Prelude.html#v:const">http://hackage.haskell.org/package/base-4.10.1.0/docs/Prelude.html#v:const</a> (const documentation)</li>
<li><a href="http://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Traversable.html#v:for">http://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Traversable.html#v:for</a> (for documentation)</li>
<li><a href="http://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Traversable.html#v:traverse">http://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Traversable.html#v:traverse</a> (traverse documentation)</li>
<li><a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/src/Data.Traversable.html#line-235">https://hackage.haskell.org/package/base-4.10.1.0/docs/src/Data.Traversable.html#line-235</a> (definition of traverse for lists)</li>
<li><a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/src/GHC.Base.html#line-716">https://hackage.haskell.org/package/base-4.10.1.0/docs/src/GHC.Base.html#line-716</a> (Applicative instance for Maybe)</li>
<li><a href="https://git-scm.com/docs/git-status/2.15.0">https://git-scm.com/docs/git-status/2.15.0</a> (git status manpage, for git 2.15.0)</li>
<li><a href="http://zsh.sourceforge.net/Doc/Release/Prompt-Expansion.html">http://zsh.sourceforge.net/Doc/Release/Prompt-Expansion.html</a> (The Z Shell Manual, Chapter 13: Prompt Expansion)</li>
</ul>

</div>

<div class="disclaimer">
  <p>Disclaimer: Opinions expressed on this blog are solely my own and do not express the views or opinions of my employer(s), past or present.</p>
</div><div id="disqus_thread"></div>
<script type="text/javascript">

(function () {
  
  
  if (window.location.hostname == "localhost")
    return;

  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  var disqus_shortname = 'pangyanhan';
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the</a></noscript>
<a href="http://disqus.com/">comments powered by <span>Disqus</span></a>
</div>

</main><footer>
 © Copyright 2013 Yan Han Pang | <a href="https://github.com/dataCobra/hugo-vitae">Vitae</a> theme for <a href="https://gohugo.io">Hugo</a> 


    

</footer>
</body>
</html>
