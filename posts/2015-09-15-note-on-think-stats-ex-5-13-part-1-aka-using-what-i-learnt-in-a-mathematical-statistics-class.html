<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Note on Think Stats Exercise 5.13 Part 1 aka Using what I learnt in a Mathematical Statistics class</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="author" content="Pang Yan Han">
        <link rel="stylesheet" href="../css/normalize.css">
        <link rel="stylesheet" href="../css/foundation.min.css">
        <link rel="stylesheet" href="../css/responsive-nav.css">
        <link href="http://fonts.googleapis.com/css?family=Roboto" rel="stylesheet" type="text/css">
        <link href="http://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet" type="text/css">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="../css/my-pygments-colorscheme.css">
        <link rel="stylesheet" href="../css/main.css">
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css">

        <script src="../js/vendor/modernizr.js"></script>
        <script src="../js/responsive-nav.min.js"></script>
        <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
            tex2jax: {
              inlineMath: [ ["\\(", "\\)"] ],
              processEscapes: true
            }
          });
        </script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
    </head>

    <body>
      <div class="site">
        <div class="row">
          <div class="small-6 columns">
            <h1 class="title"><a href="../">yan han's blog</a></h1>
          </div>
          <div class="small-6 columns">
            <div class="header-icons header-icons-translate show-for-medium-up">
              <a href="https://github.com/yanhan" target="_blank">
                <i class="fa fa-github-alt fa-4x"></i>
              </a>
              <a href="http://sg.linkedin.com/pub/yan-han-pang/92/158/91b" target="_blank">
                <i class="fa fa-linkedin fa-4x"></i>
              </a>
              <a href="https://twitter.com/yanhan_pang" target="_blank">
                <i class="fa fa-twitter fa-4x"></i>
              </a>
            </div>
            <div class="header-icons show-for-small-only">
              <a href="https://github.com/yanhan" target="_blank">
                <i class="fa fa-github-alt fa-2x"></i>
              </a>
              <a href="http://sg.linkedin.com/pub/yan-han-pang/92/158/91b" target="_blank">
                <i class="fa fa-linkedin fa-2x"></i>
              </a>
              <a href="https://twitter.com/yanhan_pang" target="_blank">
                <i class="fa fa-twitter fa-2x"></i>
              </a>
            </div>
          </div>
        </div>

        <div class="row">
          <div class="small-12 columns">
            <nav class="header nav-collapse">
              <ul>
                <li><a class="extra" href="../">home</a></li>
                <li><a class="extra" href="../about.html">about</a></li>
                <li><a class="extra" href="../haskell">Haskell</a></li>
                <li><a class="extra" href="../bookshelf.html">bookshelf</a></li>
                <li><a class="extra" href="../interesting-talks.html">interesting talks</a></li>
                <li><a class="extra" href="../archive.html">archive</a></li>
              </ul>
            </nav>
          </div>
        </div>

        <div class="row">
          <div class="small-12 columns">
            <h2>Note on Think Stats Exercise 5.13 Part 1 aka Using what I learnt in a Mathematical Statistics class</h2>
<p class="meta">
  15 Sep 2015,
  
    by <span class="italic">Pang Yan Han</span>
  
</p>
<div class="post-tags">
  <i class="fa fa-tags"></i>Tags: <a href="../tags/mathematical%20statistics.html">mathematical statistics</a>, <a href="../tags/statistics.html">statistics</a>, <a href="../tags/simulation.html">simulation</a>, <a href="../tags/probability.html">probability</a>
</div>
<div class="post">
  <p><strong>NOTE:</strong> This post has been delayed by 2 weeks due to me falling sick on the week beginning 23 August. A lot of momentum originally going into the post has been abruptly taken away but heck, I gotta pick up where I left off.</p>
<p>This week I’ve been using my spare time to crack my mind on <a href="http://greenteapress.com/thinkstats/">Think Stats</a> Exercise 5.13 part 1. After skipping Exercise 5.12 because I found it too open-ended and poorly defined for someone who has no experience in mathematical / statistical modelling, I resolved to work on Exercise 5.13 even if the outcome doesn’t seem “good”; well at least I resolved to work on Part 1 of it and I did. And I’m very glad I did. Because I got to use some knowledge I picked up in a Mathematical Statistics class I took in my final semester in university (ST2132 Mathematical Statistics).</p>
<p><strong>NOTE:</strong> There is a very high likelihood that I’ve misused some terms due to my rudimentary knowledge in Probability and Statistics. Some of my approaches may also be completely wrong. But I don’t have someone around to guide me and point out my mistakes (as do many many other people), so a lot of what I do is based on my own judgement and intuition.</p>
<h2 id="source-code">Source Code</h2>
<p>Before we continue, relevant source code is available here as a gist: <a href="https://gist.github.com/yanhan/d8fcafdbaa421f0262bf" class="uri">https://gist.github.com/yanhan/d8fcafdbaa421f0262bf</a>. Most of it is from Think Stats and is licensed under the GNU GPL v3. My code specific to this post is in <code>ch05.py</code>.</p>
<h2 id="the-problem">The problem</h2>
<p>Here is the problem statement:</p>
<blockquote>
<p>Suppose that a particular cancer has an incidence of 1 case per thousand people per year. If you follow a particular cohort of 100 people for 10 years, you would expect to see about 1 case. If you saw two cases, that would not be very surprising, but more than two would be rare.</p>
<p>Write a program that simulates a large number of cohorts over a 10 year period and estimates the distribution of total cases.</p>
</blockquote>
<h2 id="the-problem-solving-process-questions-and-assumptions">The “problem solving” process: Questions and Assumptions</h2>
<p>Notice that the words problem solving are in quotes, because I don’t think my approach is the only way to look at the problem.</p>
<p>The first thing I asked myself was: Ok. So we gotta do a simulation. But how does one translate <strong>1 case per thousand people per year</strong> to a cohort of 100 people for 10 years? I mean, do we just assume that \( P(\text{person gets cancer}) = \frac{1}{1000} \)? Or should this probability be \( \frac{1}{10000} \) since there’s only 100 people for each cohort?</p>
<p>Even more questions:</p>
<ul>
<li>Are we assuming independence between the event that person \(A\) contracts cancer and the event that person \(B\) contracting cancer, where person \(A\) and \(B\) are distinct individuals?</li>
<li>How do we perform the simulation? Do we do assume one of the above probabilities and do it for each person? Do we run the simulation 1 year at a time until we hit 10 years?</li>
</ul>
<p>So even before we get our hands dirty writing code for the simulation, there are so many things to think about and so many assumptions we have to make.</p>
<p>So I thought for a while and here are my answers to the above questions:</p>
<ul>
<li>We indeed assume that \( P(\text{person gets cancer}) = \frac{1}{1000} \), since that’s the assumption given in the question. The confusion about whether \( P(\text{person gets cancer}) \) should vary based on the cohort size we’re looking at and become \( \frac{1}{10000} \) for a cohort of size 100 is a newbie’s mistake. Initially, I couldn’t explain why but while writing this sentence, somehow my mind came up with an explanation that I believe is correct: <strong>This confusion is the result of a confusion between the concept of underlying probability vs. the concept of Expectation</strong>. Indeed \( P(\text{person gets cancer}) = \frac{1}{1000} \) and once we fix this probability, it will not change regardless of the number of people (very tempted to use the term <strong>population</strong> here but I’m not sure if it’s the right term) we’re looking at; what will vary when the cohort size changes is the expected number of people who will contract cancer. Case in point: If we look at \(1000\) people and assume that the probability of each one of them getting cancer is \( \frac{1}{1000} \) and any one person getting cancer does not affect whether anyone else gets cancer, then we can model this as a binomial random variable \( X \sim Binom(n = 1000, p = \frac{1}{1000}) \) and the expected number of people getting cancer is given by \( \mathbb{E} [X] = np = 1000 * \frac{1}{1000} = 1 \). However, if we make the same assumptions as before but change the cohort size to \(100\), then the expected number of people getting cancer becomes \( \mathbb{E}[X] = 100 * \frac{1}{1000} = 0.1 \)  . Man am I glad I wrote this post, just this section alone clarifies a lot of things for me.</li>
<li>For simplicity, we assume that the event that some person \(A\) contracts cancer is independent of the event that a distinct person \(B\) contracts cancer, regardless of the cohort they are from. In fact, I have no idea how to perform this simulation if we don’t make this assumption.</li>
<li>We perform the simulation on a per year basis; and for each year, we do it for each cohort; and for each cohort, we do it for each individual. Since we assumed that \( P(\text{person gets cancer}) = \frac{1}{1000} \) and each cohort is modelled as a \( Binom(n = 100, p = \frac{1}{1000}) \) random variable which is just a sum of \( 100 \) i.i.d. \( Ber(\frac{1}{1000}) \) random variables, we can use a CDF inversion algorithm to simulate each \( Ber(\frac{1}{1000}) \) random variable, by generating a \( Unif(0, 1) \) random variable and checking if its probability lies below \( \frac{1}{1000} \). If the value of the \( Unif(0, 1)\) is less than or equal to \( \frac{1}{1000} \), then that person contracts cancer in that year. Because we are tracking the total number of people in a cohort who contracted cancer in a 10 year period, as long as the person contracts cancer in some year, he/she is considered to have contracted cancer in the 10 year period. So to save a little bit of computing time for the simulation, we can effectively ignore that particular person for the rest of the years.</li>
</ul>
<p>Here’s the code we use to perform the simulation:</p>
<div class="highlight"><pre><span></span><span class="c1"># We'll do the simulation 1 year by 1 year</span>
<span class="c1"># Each year, about 1 / 1000 people will contract the particular cancer.</span>
<span class="c1"># So we assume that for each year, P(person gets cancer) = 1 / 1000</span>
<span class="n">prob_get_cancer</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mi">1000</span>

<span class="c1"># Performs a simulation and returns the simulated data</span>
<span class="k">def</span> <span class="nf">_perform_simulation</span><span class="p">(</span><span class="n">nr_cohorts</span><span class="p">):</span>
    <span class="n">cohort_size</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="n">nr_years</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">simulated_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># we perform simulation one cohort at a time</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nr_cohorts</span><span class="p">):</span>
        <span class="n">cancer_cases_in_cohort</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># and for each cohort, we perform the simulation 1 year at a</span>
        <span class="c1"># time for `nr_years` years</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nr_years</span><span class="p">):</span>
            <span class="n">nr_contracted_cancer_in_this_round</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># Once a patient contracts cancer, he/she is counted as a</span>
            <span class="c1"># case. Therefore we don't need to perform simulation for</span>
            <span class="c1"># that person anymore. The `nr_in_cohort_without_cancer`</span>
            <span class="c1"># stores the number of people in the cohort who have not yet</span>
            <span class="c1"># contracted cancer (we sound evil here but I don't know how</span>
            <span class="c1"># else to put it)</span>
            <span class="n">nr_in_cohort_without_cancer</span> <span class="o">=</span> <span class="n">cohort_size</span> <span class="o">-</span> <span class="n">cancer_cases_in_cohort</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nr_in_cohort_without_cancer</span><span class="p">):</span>
                <span class="c1"># this simulates a Ber(p) random variable, where p is</span>
                <span class="c1"># the probability of the person contracting cancer</span>
                <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">prob_get_cancer</span><span class="p">:</span>
                    <span class="n">nr_contracted_cancer_in_this_round</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">cancer_cases_in_cohort</span> <span class="o">+=</span> <span class="n">nr_contracted_cancer_in_this_round</span>
        <span class="c1"># we're done simulating the cohort and have the total number of</span>
        <span class="c1"># cancer cases in the cohort over 10 years. append it to our</span>
        <span class="c1"># data set.</span>
        <span class="n">simulated_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cancer_cases_in_cohort</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">simulated_data</span>
</pre></div>

<p>With that, we perform our simulation by:</p>
<div class="highlight"><pre><span></span><span class="n">nr_cohorts</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">simulated_data</span> <span class="o">=</span> <span class="n">_perform_simulation</span><span class="p">(</span><span class="n">nr_cohorts</span><span class="p">)</span>
</pre></div>

<p>There’s a reason why we place all our simulation code in a function. We’ll see why later.</p>
<h2 id="the-problem-solving-process-model-fitting">The “problem solving” process: Model fitting</h2>
<p>Imho, Chapters 3 and 4 of the book have been the most insightful chapters so far, in particular Chapter 4, which introduces the idea of model fitting. Plotting the CDF of a single variable data set (not sure if I’m using the right term here) can offer a lot of insights, especially when you know how to quickly spot some common patterns, or better, fit a lot of commonly used models onto the data. That was exactly what I did.</p>
<p>Let’s take a look at the CDF from our simulation data:</p>
<div class="figure">
<img src="../images/2015-09-15/cdf.png" />

</div>
<p>Hmmm ok, so slightly less than 40% of the cohorts have no cancer cases and slightly less than 40% of the cohorts have 1 cancer case. So overall, about slightly less than 80% of the cohorts have 1 or less cancer cases. About 10% to 15% of the cohorts have 2 cancer cases, and less than 10% cohorts see &gt;= 3 cases. So this kind of fits the description given in the book:</p>
<blockquote>
<p>If you follow a particular cohort of 100 people for 10 years, you would expect to see about 1 case. If you saw two cases, that would not be very surprising, but more than two would be rare.</p>
</blockquote>
<p>And serves as a verification that we are doing our simulation correctly.</p>
<p>Now, let’s transform the CDF in various ways as outlined in Chapter 4 and see if we observe certain trends that reveal to us that the a certain distribution will a good fit for the data.</p>
<h3 id="trend-observation-i-the-exponential-distribution">Trend observation I: the Exponential distribution</h3>
<p>The CDF of a random variable from an exponential distribution with parameter λ is given by:</p>
<p><br /><span class="math display"><em>F</em><sub><em>X</em></sub>(<em>x</em>)=1 − <em>e</em><sup>−<em>λ</em><em>x</em></sup> </span><br /></p>
<p>From Chapter 4.1 of the book, we know that we can perform some transformations and see if we observe a linear trend, first by considering the CCDF (Complementary Cumulative Distribution Function) instead of the CDF:</p>
<p><br /><span class="math display">1 − <em>F</em><sub><em>X</em></sub>(<em>x</em>)=<em>e</em><sup>−<em>λ</em><em>x</em></sup> </span><br /></p>
<p>So \( 1 - F_{X}(x) \) is the CCDF. We replace it with \( y \):</p>
<p><br /><span class="math display"><em>y</em> = <em>e</em><sup>−<em>λ</em><em>x</em></sup> </span><br /></p>
<p>Then take \( log \) on both sides:</p>
<p><br /><span class="math display">$$
\begin{align*}
log(y) &amp;= log(e^{-λx}) \\
log(y) &amp;= -λx
\end{align*}
$$</span><br /></p>
<p>Hence, if we plot \( y = e^{-λx} \) where \( y \) is the CCDF on a \( log\ y \) scale and the exponential distribution happens to be a good model for the data, then we should be observing a linear trend, where \( -λ \) is the gradient of the line. Is that the case? Let’s look at our plot:</p>
<div class="figure">
<img src="../images/2015-09-15/ccdf-logy-scale.png" />

</div>
<p>Looks like a reasonably linear trend to me. Because I don’t know how to do it using matplotlib, allow me to use Gimp to hand draw a smooth curve:</p>
<div class="figure">
<img src="../images/2015-09-15/ccdf-logy-scale-with-hand-drawn-curve.png" />

</div>
<p>Ok, it wouldn’t be too outrageous to call this linear, or at least very close to it. So the exponential distribution may very well be a good fit. Let’s perform some other transformations on the CDF and see if we can spot other trends.</p>
<h3 id="trend-observation-ii-the-pareto-distribution">Trend observation II: the Pareto distribution</h3>
<p>Think Stats gives the CDF of the Pareto distribution as follows:</p>
<p><br /><span class="math display">$$CDF(x) = 1 - (\frac{x}{x_m})^{-\alpha}
$$</span><br /></p>
<p>while the <a href="https://en.wikipedia.org/wiki/Pareto_distribution">Wikipedia entry for the Pareto Distribution</a> says it is:</p>
<p><br /><span class="math display">$$CDF(x) = 1 - (\frac{x_m}{x})^{\alpha}
$$</span><br /></p>
<p>There is essentially no difference between the two. For consistency, we shall stick with the form given by Think Stats.</p>
<p>Again, we consider the CCDF of the Pareto Distribution. That is:</p>
<p><br /><span class="math display">$$1 - CDF(x) = (\frac{x}{x_m})^{-\alpha}
$$</span><br /></p>
<p>And we replace \( 1 - CDF(x) \) with \( y \) to get:</p>
<p><br /><span class="math display">$$y = (\frac{x}{x_m})^{-\alpha}
$$</span><br /></p>
<p>Taking \( log \) on both sides:</p>
<p><br /><span class="math display">$$log(y) = -\alpha log(\frac{x}{x_m}) \\
log(y) = -\alpha(log(x) - log(x_m)) \\
log(y) = -\alpha log(x) + \alpha log(x_m)
$$</span><br /></p>
<p>So if we plot the CCDF on a \( log \ log \) scale and the Pareto is a good model for the data, we should see a linear trend with gradient \( -\alpha \) and y-intercept \( \alpha log(x_m) \). Let’s do a \( log \ log \) plot of the CCDF and see if that’s the case:</p>
<div class="figure">
<img src="../images/2015-09-15/ccdf-log-log-scale.png" />

</div>
<p>And with a hand drawn curve:</p>
<div class="figure">
<img src="../images/2015-09-15/ccdf-log-log-scale-with-hand-drawn-curve.png" />

</div>
<p>It’s pretty obvious that this is hardly linear. So the Pareto distribution does not seem to be a good model for the data.</p>
<h3 id="trend-observation-iii-the-log-normal-distribution">Trend observation III: the Log-normal distribution</h3>
<p>If we look at the CDF of our simulated data:</p>
<div class="figure">
<img src="../images/2015-09-15/cdf.png" />

</div>
<p>We can see that it looks quite different from that of a normal CDF, which looks something like this:</p>
<div class="figure">
<img src="../images/2015-09-15/normal-cdf.png" />

</div>
<p>So the normal distribution is not a good fit for our data. But how about the Log-normal distribution? We say that if a random variable \( X \) is log-normally distributed, then \( Y = ln(X) \) has a normal distribution. So if the Log-normal distribution is a good fit for our data, we should see a plot that looks similar to the normal CDF when we plot the CDF on a \( log \ x \) scale. Let’s do the plot:</p>
<div class="figure">
<img src="../images/2015-09-15/cdf-logx-scale.png" />

</div>
<p>And… it looks nothing like the CDF of a normal distribution. So the Log-normal distribution is not a good model for our data.</p>
<h3 id="trend-observation-iv-the-weibull-distribution">Trend observation IV: the Weibull distribution</h3>
<p>The other distribution that we’ve learnt about in Chapter 4, specifically from Exercise 4.6, is the Weibull distribution. Its CDF is given by:</p>
<p><br /><span class="math display">$$CDF(x) = 1 - e^{-(\frac{x}{λ})^{k}}
$$</span><br /></p>
<p>Again, we consider the CCDF:</p>
<p><br /><span class="math display">$$1 - CDF(x) = e^{-(\frac{x}{λ})^{k}}
$$</span><br /></p>
<p>and perform the following manipulations:</p>
<p><br /><span class="math display">$$1 - CDF(x) = e^{-(\frac{x}{λ})^{k}} \\
log(1 - CDF(x)) = -(\frac{x}{λ})^{k} \\
-log(1 - CDF(x)) = (\frac{x}{λ})^{k} \\
log(-log(1 - CDF(x))) = k \cdot log(\frac{x}{λ}) \\
log(-log(1 - CDF(x))) = k \cdot log(x) - k \cdot log(λ) \\
log(log((1 - CDF(x))^{-1})) = k \cdot log(x) - k \cdot log(λ)
$$</span><br /></p>
<p>Admittedly, this is quite a handful. Basically, if we do a \( log \ log \) plot with \( y = log((1 - CDF(x))^{-1}) = log(\frac{1}{1 - CDF(x)}) = log(\frac{1}{CCDF(x)}) \), then we should observe a linear trend with gradient \( k \) and y-intercept \( -k \cdot log(λ) \). Let’s look at the plot:</p>
<div class="figure">
<img src="../images/2015-09-15/one-over-log-ccdf-log-log-scale.png" />

</div>
<p>And with a hand drawn curve:</p>
<div class="figure">
<img src="../images/2015-09-15/one-over-log-ccdf-log-log-scale-with-hand-drawn-curve.png" />

</div>
<p>And we indeed observe a linear trend.</p>
<h3 id="conclusions-of-trend-observations">Conclusions of Trend Observations</h3>
<p>So to recap, we performed various transformations on the CDF to see if any of the Exponential, Pareto, Log-normal or Weibull distributions will be a good model for our data. Based on what we see, it seems that the Exponential and Weibull distributions could be good models for our data. Let’s take a look at the plots again:</p>
<p>Plot of the transform to observe if the Exponential distribution is a good model:</p>
<div class="figure">
<img src="../images/2015-09-15/ccdf-logy-scale-with-hand-drawn-curve.png" />

</div>
<p>Plot of the transform to observe if the Weibull distribution is a good model:</p>
<div class="figure">
<img src="../images/2015-09-15/one-over-log-ccdf-log-log-scale-with-hand-drawn-curve.png" />

</div>
<h2 id="now-what">Now what?</h2>
<p>Now that we’ve narrowed down the choices of models to the Exponential and Weibull distributions, what do we do next? It would be to verify if any of them are actually good models. And how do we do that? It seems that we have to find out the concrete Exponential and Weibull distributions that would make for good models. While Think Stats has shown us how to come up with various plots of the CDF of the data and observe if the data can be modelled using some commonly occurring distributions, it doesn’t show us how to do this follow up step, which is to come up with the concrete distributions and see how well they correspond to the CDF.</p>
<p>To make myself clear, let’s say we want to find out the Exponential distribution that would best correspond to our data. We know that the Exponential distribution is parameterized by \( \lambda \). So our job is to find out this appropriate value of \( \lambda \), plot the CDF of the \( Exp(\lambda) \) distribution and compare that against the CDF of our data to see how well they match up. This seems to be a complicated step. Perhaps we should just stop here and call it a day and just move on, after all we did our best and it doesn’t seem that we can do more.</p>
<p>Or is it?</p>
<h2 id="mathematical-statistics-to-the-rescue">Mathematical Statistics to the rescue</h2>
<p>I happen to have taken a Mathematical Statistics class in my final semester of university. ST2132 Mathematical Statistics, to be exact. I didn’t do very well for the class, having gotten a B. The paper was pretty tough and the concepts were pretty abstract for someone whose previous exposure to Statistics was about 3 years ago in a rather poorly taught class. Also, I didn’t see the point to a lot of things I’ve learnt in the class; it all seemed like a bunch of mechanical calculations.</p>
<p>Until I ran into this exercise in the Think Stats book.</p>
<p>For some reason, I recalled that when given a data set that one suspects belongs to some distribution with some unknown parameter(s), one could perform parameter estimation. Ok, I must admit that when I did this exercise, I certainly didn’t think of the term ‘parameter estimation’; it only came up as I was writing this blog post. But I certainly did recall the <strong>Method of Moments</strong> and <strong>Maximum Likelihood Estimate</strong> techniques. And I was set.</p>
<h2 id="model-fitting">Model Fitting</h2>
<h3 id="model-i-exponential-distribution">Model I: Exponential distribution</h3>
<p>So for the Method of Moments method, we take as many moments as necessary, starting from the first moment, and express the moments in terms of the parameters. Then we invert the role of the moments and the parameters and express the parameters in terms of the moments. Finally, we substitute the estimated parameters in place of the actual parameters, and the sample moments in place of the moments. Hopefully we’ll only run into stuff like \( \bar{X} \) which we can easily compute from the data set and have an easier time computing the estimated parameters. The number of such equations we’ll need is equivalent to the number of unknown parameters we need to estimate; sometimes we’ll need to take more moments than unknowns because some moments are equal to \( 0 \), which is useless to us.</p>
<p>Ok, that is quite a mouthful. To be more concrete, suppose we are trying to estimate parameters for a distribution parameterized by \( \alpha \) and \( \beta \). Then there are 3 steps we need to do:</p>
<ol style="list-style-type: decimal">
<li>Take as many moments as necessary and express them in terms of unknown parameters. Suppose we took 2 moments and obtained the following:</li>
</ol>
<p><br /><span class="math display">$$\mathbb{E}[X] = \alpha \\
\mathbb{E}[X^2] = \frac{1}{\beta}
$$</span><br /></p>
<ol start="2" style="list-style-type: decimal">
<li>Express the parameters in terms of the moments.</li>
</ol>
<p><br /><span class="math display">$$\alpha = \mathbb{E}[X] \\
\beta = \frac{1}{\mathbb{E}[X^2]}
$$</span><br /></p>
<ol start="3" style="list-style-type: decimal">
<li>Substitute the estimated parameters in place of the actual parameters, and substitute the sample moments in place of the actual moments. We’ll denote the estimated parameters by placing a caret (or a hat) symbol above how we write the actual parameters, so the estimated parameter for \( \alpha \) will be \( \hat{\alpha} \). For sample moments, the \(k\)th sample moment is defined as \( \frac{1}{n} \displaystyle \sum_{i=1}^{n} X_i^{k} \). So performing the substitution on the above 2 equations:</li>
</ol>
<p><br /><span class="math display">$$\hat{\alpha} = \frac{1}{n} \displaystyle \sum_{i=1}^{n} X_i \\
\hat{\beta} = \frac{1}{\frac{1}{n} \displaystyle \sum_{i=1}^{n} X_i^2}
$$</span><br /></p>
<p>Let’s see it in action for the Exponential distribution.</p>
<p>The Exponential distribution is parameterized by \( \lambda \), so we only need one equation. Let’s begin by taking the first moment:</p>
<p><br /><span class="math display">$$\begin{align*}
  \mathbb{E}[X] =&amp; \int_{0}^{\infty} x \cdot f(x) dx \\
                =&amp; \int_{0}^{\infty} x \cdot \lambda e^{- \lambda x} dx
\end{align*}
$$</span><br /></p>
<p>At this point, my limited knowledge of Calculus (which I’m making an effort to pick up) means that it’ll be quite difficult for me to compute this integral. However, there is a trick I’ve learnt from the Mathematical Statistics class, which is that a PDF integrated over its support equals to \( 1 \), and that for certain types of integrals, we can perform some algebraic manipulations to massage the symbols into a PDF that we recognize, barring some constant factors. As long as we can do that and we’re trying to integrate over the same support, then we can simply replace the entire integral with 1.</p>
<p>In this case, the \( x \cdot e^{- \lambda x} \) part of the integral looks like the PDF of a Gamma distribution parameterized by \( \alpha \) (shape) and \( \beta \) (rate), which is \( \frac{\beta ^ \alpha}{\Gamma (\alpha)} x^{\alpha - 1} e^{- \beta x} \), where \( \alpha = 2 \) and \( \beta = \lambda \), barring constant factors. So we pick up from where we left off:</p>
<p><br /><span class="math display">$$\begin{align*}
  \mathbb{E}[X] =&amp; \int_{0}^{\infty} x \cdot \lambda e^{- \lambda x} dx \\
                =&amp; \ \lambda \cdot \int_{0}^{\infty} x^{2-1} \cdot e^{- \lambda x} dx \\
                =&amp; \ \lambda \cdot \int_{0}^{\infty} \frac{\lambda^{2}}{\Gamma(2)} x^{2 - 1} \cdot e^{- \lambda x} \cdot \frac{\Gamma(2)}{\lambda^2} dx \\
                =&amp; \ \lambda \cdot \frac{\Gamma(2)}{\lambda^2} \int_{0}^{\infty} \frac{\lambda^{2}}{\Gamma(2)} x^{2 - 1} \cdot e^{- \lambda x} dx \\
                =&amp; \ \lambda \cdot \frac{\Gamma(2)}{\lambda^2} \cdot 1 \\
                =&amp; \ \frac{\Gamma(2)}{\lambda} \\
                =&amp; \ \frac{(2 - 1)!}{\lambda} \\
                =&amp; \ \frac{1}{\lambda}
\end{align*}
$$</span><br /></p>
<p>So our first step of taking moments and expressing them in terms of parameters is done. For our next step, we express the parameters in terms of the moments:</p>
<p><br /><span class="math display">$$\mathbb{E}[X] = \ \frac{1}{\lambda} \\
\lambda = \frac{1}{\mathbb{E}[X]}
$$</span><br /></p>
<p>Finally, we substitute the sample moments in place of the actual moments, and substitute the estimated parameter in place of the actual parameter. In other words, we substitute the first sample moment \( \frac{1}{n} \displaystyle \sum_{i = 1}^{n} X_i \) in place of \( \mathbb{E}[X] \), and substitute the estimated parameter \( \hat{\lambda} \) in place of the actual parameter \( \lambda \).</p>
<p><br /><span class="math display">$$\hat{\lambda} = \frac{1}{\frac{1}{n} \displaystyle \sum_{i=1}^{n}X_i}
$$</span><br /></p>
<p>The first sample moment, \( \displaystyle \frac{1}{n} \sum_{i=1}^{n} X_i \), also written as \( \bar{X} \), can be easily computed from the data set; it is simply the average of the \( X \)’s.</p>
<p>How about the Maximum Likelihood Estimate?</p>
<p>Suppose that the random variables \( X_1, X_2, … , X_n \) have a joint density function \( f(x_1, x_2, … , x_n | \theta) \) for parameter \( \theta \). Then, given observed values \( X_i = x_i \), for \( i = 1, 2, …, n \), the likelihood function of \( \theta \) as a function of \( x_1, x_2, …, x_n \) is given by:</p>
<p><br /><span class="math display">$$lik(\theta) = f(x_1, x_2, ... , x_n | \theta) \\
$$</span><br /></p>
<p>To simplify things, we assume that the \( X_i \)’s are i.i.d. (independently and identically distributed). Then the joint density function can be expressed as a product of the marginal densities. Hence the likelihood function can be written as:</p>
<p><br /><span class="math display">$$\begin{align*}
  lik(\theta) =&amp; f(x_1, x_2, ... , x_n | \theta) \\
              =&amp; \prod_{i=1}^{n} f(X_i | \theta)
\end{align*}
$$</span><br /></p>
<p>So the maximum likelihood estimate of the parameter \( \theta \) is the value that maximizes the likelihood above. That is, it makes the observed data most likely (hence its name).</p>
<p>Often times, it is much easier to maximize the log likelihood instead of the likelihood. Maximizing the likelihood is equivalent to maximizing the log likelihood since log is a monotonic function. Given an i.i.d. sample, the log likelihood is:</p>
<p><br /><span class="math display">$$
\begin{align*}
  l(\theta) =&amp; \ log(lik(\theta)) \\
            =&amp; \ log(\prod_{i=1}^{n} f(X_i | \theta)) \\
            =&amp; \ log(f(X_1 | \theta) \cdot f(X_2 | \theta) \cdot \ \ldots \ \cdot f(X_n | \theta)) \\
            =&amp; \ log(f(X_1 | \theta)) + log(f(X_2 | \theta)) \ + \ \ldots \ + \ log(f(X_n | \theta)) \\
            =&amp; \ \sum_{i=1}^{n} log(f(X_i | \theta))
\end{align*}
$$</span><br /></p>
<p>To use this for our scenario, suppose \( X_1, X_2, … , X_n \) are i.i.d \( Exp(\lambda) \). Then the log likelihood is given by:</p>
<p><br /><span class="math display">$$
\begin{align*}
  l(\lambda ) =&amp; \sum_{i=1}^{n} log(f(X_i | \lambda)) \\
              =&amp; \sum_{i=1}^{n} log(\lambda e^{- \lambda X_i}) \\
              =&amp; \sum_{i=1}^{n} [log(\lambda) + log(e^{- \lambda X_i})] \\
              =&amp; \sum_{i=1}^{n} [log(\lambda) -\lambda X_i ] \\
              =&amp; \sum_{i=1}^{n} [log(\lambda)] - \sum_{i=1}^{n} [\lambda X_i] \\
              =&amp; \ n \cdot log(\lambda) - \lambda \sum_{i=1}^{n} X_i
\end{align*}
$$</span><br /></p>
<p>To maximize the log likelihood, we set its first derivative to zero:</p>
<p><br /><span class="math display">$$
\begin{align*}
  l'(\lambda) =&amp; \frac{d}{d \lambda} l(\lambda) \\
              =&amp; \frac{d}{d \lambda} ( n \cdot log(\lambda) - \lambda \sum_{i=1}^{n} X_i ) \\
              =&amp; \frac{n}{\lambda} - \sum_{i=1}^{n} X_i \\
\\
0 =&amp; \ \frac{n}{\lambda} - \sum_{i=1}^{n} X_i \\
\frac{n}{\lambda} =&amp; \sum_{i=1}^{n} X_i \\
\lambda =&amp; \ \frac{n}{\sum_{i=1}^{n} X_i} \\
        =&amp; \ \frac{1}{\frac{1}{n} \sum_{i=1}^{n} X_i} \\
        =&amp; \ \frac{1}{\bar{X}}
\end{align*}
$$</span><br /></p>
<p>Hence, the maximum likelihood estimate of \( \lambda \), which we denote as \( \tilde{\lambda} \), is also \( \frac{1}{\bar{X}} \), which is exactly the same as the method of moments estimate \( \hat{\lambda} \).</p>
<p>To visually see how well the \( Exp(\hat{\lambda}) \) model is a fit for our data, I came up with 2 plots. First, the plot of the CCDF and the \( Exp(\hat{\lambda}) \) with a similar transform done. Before showing you the plots, here’s the code we use to compute \( \hat{\lambda} \) and draw the Exponential CDF:</p>
<div class="highlight"><pre><span></span><span class="c1"># First, we compute lambda = 1 / Xbar</span>
<span class="n">xBar</span> <span class="o">=</span> <span class="n">Mean</span><span class="p">(</span><span class="n">simulated_data</span><span class="p">)</span>
<span class="n">exp_lambda</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">xBar</span>
<span class="c1"># Here, we plot the Exp(lambda) CDF, over increments of 0.01 to make</span>
<span class="c1"># it more smooth when we plot it. Otherwise, we'll be getting a plot</span>
<span class="c1"># which looks similar to the empirical CDF, which is only defined at</span>
<span class="c1"># discrete points.</span>
<span class="n">max_val</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">simulated_data</span><span class="p">)</span>
<span class="n">exp_lambda_pdf</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">exp_lambda</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">exp_lambda</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>
<span class="n">val_to_density</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">i</span><span class="p">,</span> <span class="n">incr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.01</span>
<span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">max_val</span><span class="p">:</span>
    <span class="n">val_to_density</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">exp_lambda_pdf</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="n">incr</span>
<span class="n">exp_model_cdf</span> <span class="o">=</span> <span class="n">Cdf</span><span class="o">.</span><span class="n">MakeCdfFromDict</span><span class="p">(</span><span class="n">val_to_density</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;model&quot;</span>
<span class="p">)</span>
</pre></div>

<p>Plot for the empirical CCDF and CCDF of our exponential model:</p>
<div class="figure">
<img src="../images/2015-09-15/ccdf-with-ccdf-of-exp-model-logy-scale.png" />

</div>
<p>followed by the CDF with the exponential model:</p>
<div class="figure">
<img src="../images/2015-09-15/cdf-with-exp-model.png" />

</div>
<p>While it is not perfect, other than the fact that the the probability of 0 cancer cases is way off for the model, the rest of the differences are arguably still acceptable. But it seems that we can do better. Suppose that \( X \) is a random variable for the simulated data and \( \mathbb{P}(X &lt;= 0) = p \), so \( p \) is the y-coordinate where \( x = 0 \) for the blue curve and is very close to 0.4 . Suppose \( Y \sim Exp(\hat{\lambda}) \), so the CDF plot of \( Y \) is the green curve. What we want is the value \( y \) such that \( \mathbb{P}(Y &lt;= y) = p \). In other words, the value on the x-axis where the green curve intersects with the blue curve at y-coordinate \( p \). It seems that if we shift the CDF plot of \( Y \sim Exp(\hat{\lambda}) \) by \( y \) units to the left on the x-axis, then the CDF of our model will be a much better fit for the simulated data.</p>
<p>We can obtain \( p \) quite easily, since that is just the fraction of cohorts with zero cancer cases in our simulated data. Once we obtain \( p \), since we know the exact value of \( \hat{\lambda} \), we can perform CDF inversion to get \( y \).</p>
<p>Here is the resulting plot after we shift the Exponential model:</p>
<div class="figure">
<img src="../images/2015-09-15/cdf-with-shifted-exp-model.png" />

</div>
<p>Seems like our modification to the \( Exp(\hat{\lambda}) \) model is a good fit for the data. Let’s move on to our next model, the Weibull distribution.</p>
<h3 id="model-ii-weibull-distribution">Model II: Weibull distribution</h3>
<p>According to the <a href="https://en.wikipedia.org/wiki/Weibull_distribution">Wikipedia entry for the Weibull distribution</a>, the PDF of the Weibull distribution is given by \( \frac{k}{\lambda} (\frac{x}{\lambda})^{k-1} e^{-(x / \lambda)^{k}} \). I have to admit that I cheated a bit and looked at the moments for the Weibull distribution and it seems that we’ll need the gamma function, which is defined as \( \Gamma(n) = (n - 1)! \) if \( n \) is a positive integer, or \( \Gamma(t) = \int_{0}^{\infty} x^{t-1} e^{-x} dx \) for complex numbers with a positive real part.</p>
<p>Suppose \( X \sim Weibull(k, \lambda) \). Let us first use the Method of Moments method and take the first moment:</p>
<p><br /><span class="math display">$$
\begin{align*}
  \mathbb{E}[X] =&amp; \int_{0}^{\infty} x \cdot f(x) dx \\
                =&amp; \int_{0}^{\infty} x \cdot \frac{k}{x} (\frac{x}{\lambda})^{k-1} e^{-(x / \lambda)^{k}} dx \\
                =&amp; \int_{0}^{\infty} k (\frac{x}{\lambda})^{k} e^{-(x / \lambda)^{k}} dx
\end{align*}
$$</span><br /></p>
<p>Now I’m stuck. I decided to perform an integration by substitution. Let \( y = \frac{x}{\lambda} \). Then \( dy = \frac{1}{\lambda} dx \), so \( dx = \lambda dy \). Performing this substitution:</p>
<p><br /><span class="math display">$$
\begin{align*}
  \mathbb{E}[X] =&amp; \int_{0}^{\infty} k (\frac{x}{\lambda})^{k} e^{-(x / \lambda)^{k}} dx \\
                =&amp; \int_{0}^{\infty} k y^k e^{-y^k} \lambda dy \\
                =&amp; \ \lambda k \int_{0}^{\infty} y^k e^{-y^k} dy \\
                =&amp; \ \lambda k \int_{0}^{\infty} (y^k)^{2-1} e^{-(y^k)} dy \\
                =&amp; \ \lambda k \Gamma(2) \\
                =&amp; \ \lambda k \cdot (2-1)! \\
                =&amp; \ \lambda k
\end{align*}
$$</span><br /></p>
<p>However, according to Wikipedia, the first moment of a Weibull random variable is \( \lambda \Gamma(1 + \frac{1}{k}) \), which is very different from \( \lambda k \); I mean, in general, it doesn’t seem like \( \Gamma(1 + \frac{1}{k}) = k \) is going to hold. So somewhere along the way, we made a mistake.</p>
<p>After some thinking, I realized that the mistake is here:</p>
<p><br /><span class="math display">$$\lambda k \int_{0}^{\infty} (y^k)^{2-1} e^{-(y^k)} dy = \ \lambda k \Gamma(2) \\
$$</span><br /></p>
<p>Recall that the Gamma function is defined as \( \Gamma(t) = \int_{0}^{\infty} x^{t-1} e^{-x} dx \). However, notice that in \( \int_{0}^{\infty} ( y^k )^{2-1} e^{-( y^k )} dy \), we are treating \( y^k \) as \( x \), but notice that we are integrating with respect to \( dy \) and not \( dy^k \). If we were integrating with respect to \( dy^k \), then indeed the integral would have evaluated to \( \lambda k \Gamma(2) \).</p>
<p>So it seems like the correct substitution to perform is to let \( y = ( \frac{x}{\lambda} )^k \). Then \( dy = \frac{k}{\lambda} ( \frac{x}{\lambda} )^{k-1} dx \) and \( dx = ( \frac{x}{\lambda} )^{1-k} \cdot \frac{\lambda}{k} dy = y^{\frac{1-k}{k}} \cdot \frac{\lambda}{k} \). Performing the substitutions:</p>
<p><br /><span class="math display">$$
\begin{align*}
  \mathbb{E}[X] =&amp; \int_{0}^{\infty} k (\frac{x}{\lambda})^{k} e^{-(x / \lambda)^{k}} dx \\
                =&amp; \int_{0}^{\infty} k \cdot y \cdot e^{-y} \cdot y^{\frac{1-k}{k}} \cdot \frac{\lambda}{k} dy \\
                =&amp; \int_{0}^{\infty} \lambda \cdot y^{1 + \frac{1-k}{k}} \cdot e^{-y} dy \\
                =&amp; \lambda \int_{0}^{\infty} y^{\frac{k+1-k}{k}} \cdot e^{-y} dy \\
                =&amp; \lambda \int_{0}^{\infty} y^{\frac{1}{k}} e^{-y} dy \\
                =&amp; \lambda \int_{0}^{\infty} y^{(1 + \frac{1}{k}) - 1} e^{-y} dy \\
                =&amp; \lambda \Gamma(1 + \frac{1}{k})
\end{align*}
$$</span><br /></p>
<p>Let us carry on by taking the second moment:</p>
<p><br /><span class="math display">$$
\begin{align*}
  \mathbb{E}[X^2] =&amp; \int_{0}^{\infty} x^2 f(x) dx \\
                  =&amp; \int_{0}^{\infty} x^2 \cdot \frac{k}{\lambda} ( \frac{x}{\lambda} )^{k-1} e^{-(x / \lambda)^k} dx \\
                  =&amp; \int_{0}^{\infty} x \cdot k ( \frac{x}{\lambda} )^k e^{-(x / \lambda)^k} dx
\end{align*}
$$</span><br /></p>
<p>Again, we let \( y = ( \frac{x}{\lambda} )^k \), so \( x = \lambda \cdot y^{\frac{1}{k}} \), \( dy = \frac{k}{\lambda} \cdot ( \frac{x}{\lambda} )^{k-1} dx \), \( dx = \frac{\lambda}{k} \cdot ( \frac{x}{\lambda} )^{1-k} dy = \frac{\lambda}{k} \cdot y^{\frac{1-k}{k}} dy \). Performing the necessary substitutions:</p>
<p><br /><span class="math display">$$
\begin{align*}
  \mathbb{E}[X^2] =&amp; \int_{0}^{\infty} x \cdot k ( \frac{x}{\lambda} )^k e^{-(x / \lambda)^k} dx \\
                  =&amp; \int_{0}^{\infty} \lambda \cdot y^{\frac{1}{k}} \cdot k \cdot y \cdot e^{-y} \cdot \frac{\lambda}{k} \cdot y^{\frac{1-k}{k}} dy \\
                  =&amp; \int_{0}^{\infty} \lambda^2 y^{\frac{1 + 1 - k}{k} + 1} e^{-y} dy \\
                  =&amp; \ \lambda^2 \int_{0}^{\infty} y^{\frac{2 - k + k}{k}} e^{-y} dy \\
                  =&amp; \ \lambda^2 \int_{0}^{\infty} y^{\frac{2}{k}} e^{-y} dy \\
                  =&amp; \ \lambda^2 \int_{0}^{\infty} y^{(1 + \frac{2}{k}) - 1} e^{-y} dy \\
                  =&amp; \ \lambda^2 \Gamma(1 + \frac{2}{k})
\end{align*}
$$</span><br /></p>
<p>So we have:</p>
<p><br /><span class="math display">$$\mathbb{E}[X] = \lambda \Gamma(1 + \frac{1}{k}) \\
\mathbb{E}[X^2] = \lambda^2 \Gamma(1 + \frac{2}{k})
$$</span><br /></p>
<p>Which is not very useful to us, since the parameter \( k \) is stuck inside the gamma function. In fact, the Wikipedia entry for the Weibull distribution states that in general, the \(n\)th moment of a Weibull random variable is given by \( \lambda^n \Gamma(1 + \frac{n}{k}) \). So it doesn’t seem like we’ll be going anywhere by taking additional moments. Time to try the method of Maximum Likelihood Estimate.</p>
<p>Assume that \( X_1, X_2, … X_n \) are i.i.d. \( Weibull(k, \lambda) \), then the joint likelihood is given by \( \displaystyle \prod_{i=1}^{n} f(X_i) = \prod_{i=1}^{n} \frac{k}{\lambda} ( \frac{X_i}{\lambda} )^{k-1} e^{-(X_i / \lambda)^k} \). Maximizing the likelihood is equivalent to maximizing the log likelihood, which is given by:</p>
<p><br /><span class="math display">$$
\begin{align*}
  l = log(\prod_{i=1}^{n} f(x_i) ) =&amp; \sum_{i=1}^{n} log(f(X_i)) \\
                                   =&amp; \sum_{i=1}^{n} log(\frac{k}{\lambda} ( \frac{X_i}{\lambda} )^{k-1} e^{-(X_i / \lambda)^k} ) \\
                                   =&amp; \sum_{i=1}^{n}[ log(\frac{k}{\lambda}) + (k - 1) \cdot log(\frac{X_i}{\lambda}) - ( \frac{X_i}{\lambda} )^k ] \\
                                   =&amp; \sum_{i=1}^{n} [ log(k) - log(\lambda) + (k - 1) \cdot log(X_i) - (k-1) \cdot log(\lambda) - ( \frac{X_i}{\lambda} )^k ] \\
                                   =&amp; \sum_{i=1}^{n} [ log(k) - k \cdot log(\lambda) + (k-1) \cdot log(X_i) - ( \frac{X_i}{\lambda} )^k ] \\
                                   =&amp; \ n \cdot log(k) - nk \cdot log(\lambda) + \sum_{i=1}^{n}[ (k-1) \cdot log(X_i) - ( \frac{X_i}{\lambda} )^k ]
\end{align*}
$$</span><br /></p>
<p>Taking derivatives with respect to \( k \):</p>
<p><br /><span class="math display">$$\frac{\partial l}{\partial k} = \frac{n}{k} - n \cdot log(\lambda) + \sum_{i=1}^{n} [ log(X_i) - ( \frac{X_i}{\lambda} )^k log(\frac{X_i}{\lambda}) ] \\
$$</span><br /></p>
<p>Taking derivatives with respect to \( \lambda \):</p>
<p><br /><span class="math display">$$
\begin{align*}
  \frac{\partial l}{\partial \lambda} =&amp; - \frac{nk}{\lambda} + \sum_{i=1}^{n} [ -(-k) \frac{X_i^k}{\lambda^{k+1}} ] \\
                                      =&amp; - \frac{nk}{\lambda} + k \cdot \sum_{i=1}^{n} \frac{X_i^k}{\lambda^{k+1}} \\
                                      =&amp; - \frac{nk}{\lambda} + \frac{k}{\lambda^{k+1}} \cdot \sum_{i=1}^{n}X_i^k
\end{align*}
$$</span><br /></p>
<p>Setting \( \frac{\partial l}{\partial \lambda} = 0 \):</p>
<p><br /><span class="math display">$$
- \frac{nk}{\lambda} + \frac{k}{\lambda^{k+1}} \cdot \sum_{i=1}^{n} X_i^k = 0 \\
\frac{nk}{\lambda} = \frac{k}{\lambda^{k+1}} \cdot \sum_{i=1}^{n} X_i^k \\
\frac{\lambda^{k+1}}{\lambda} = \frac{k}{nk} \cdot \sum_{i=1}^{n} X_i^k \\
\lambda^k = \frac{1}{n} \sum_{i=1}^{n} X_i^k
$$</span><br /></p>
<p>Setting \( \frac{\partial l}{\partial k} = 0 \):</p>
<p><br /><span class="math display">$$ \frac{n}{k} - n \cdot log(\lambda) + \sum_{i=1}^{n} [ log(X_i) - ( \frac{X_i}{\lambda} )^k \cdot log(\frac{X_i}{\lambda}) ] = 0 \\
\frac{n}{k} - n \cdot log(\lambda) + \sum_{i=1}^{n} [ log(X_i) - ( \frac{X_i}{\lambda} )^k \cdot log(X_i) + ( \frac{X_i}{\lambda} )^k \cdot log(\lambda) ] = 0 \\
\frac{n}{k} - n \cdot log(\lambda) + \sum_{i=1}^{n} [ log(X_i) ] - \frac{1}{\lambda^k} \cdot \sum_{i=1}^{n} [ X_i^k \cdot log(X_i) ] + \frac{log(\lambda)}{\lambda^k} \sum_{i=1}^{n} [X_i^k] = 0 \\
\frac{n}{k} - \frac{1}{\lambda^k} \sum_{i=1}^{n} [ X_i^k \cdot log(X_i) ] + \frac{log(\lambda)}{\lambda^k} \sum_{i=1}^{n} [ X_i^k ] = n \cdot log(\lambda) - \sum_{i=1}^{n} [ log(X_i) ] \\
$$</span><br /></p>
<p>Substituting \( \lambda^k = \frac{1}{n} \sum_{i=1}^{n} X_i^k \):</p>
<p><br /><span class="math display">$$ \frac{n}{k} - \frac{1}{\lambda^k} \sum_{i=1}^{n} [ X_i^k \cdot log(X_i) ] + \frac{log(\lambda)}{\lambda^k} \sum_{i=1}^{n} [ X_i^k ] = n \cdot log(\lambda) - \sum_{i=1}^{n} [ log(X_i) ] \\
\frac{n}{k} - \frac{1}{\frac{1}{n} \sum_{i=1}^{n} [ X_i^k ] } \sum_{i=1}^{n} [ X_i^k \cdot log(X_i) ] + \frac{log(\lambda)}{\frac{1}{n} \sum_{i=1}^{n} [ X_i^k ]} \sum_{i=1}^{n} [ X_i^k ] = n \cdot log(\lambda) - \sum_{i=1}^{n} [ log(X_i) ] \\
\frac{n}{k} - \frac{\sum_{i=1}^{n} [ X_i^k \cdot log(X_i) ]}{\frac{1}{n} \sum_{i=1}^{n} [ X_i^k ]} + \frac{log(\lambda)}{\frac{1}{n}} = n \cdot log(\lambda) - \sum_{i=1}^{n} [ log(X_i) ] \\
\frac{n}{k} - \frac{n \cdot \sum_{i=1}^{n} [ X_i^k \cdot log(X_i) ]}{\sum_{i=1}^{n} [ X_i^k ]} + n \cdot log(\lambda) = n \cdot log(\lambda) - \sum_{i=1}^{n} [ log(X_i) ] \\
\frac{n}{k} - \frac{n \cdot \sum_{i=1}^{n} [ X_i^k \cdot log(X_i) ]}{\sum_{i=1}^{n} [ X_i^k ]} = - \sum_{i=1}^{n} [ log(X_i) ] \\
\frac{n}{k} = \frac{n \cdot \sum_{i=1}^{n} [ X_i^k \cdot log(X_i) ]}{\sum_{i=1}^{n} [ X_i^k ]} - \sum_{i=1}^{n} [ log(X_i) ] \\
k^{-1} = \frac{\sum_{i=1}^{n} [ X_i^k \cdot log(X_i) ]}{\sum_{i=1}^{n} [ X_i^k ]} - \frac{1}{n} \sum_{i=1}^{n} [ log(X_i) ] \\
k = ( \frac{\sum_{i=1}^{n} [ X_i^k \cdot log(X_i) ]}{\sum_{i=1}^{n} [ X_i^k ]} - \frac{1}{n} \sum_{i=1}^{n} [ log(X_i) ] )^{-1} \\
$$</span><br /></p>
<p>So now we have these 2 equations: \( \lambda^k = \frac{1}{n} \sum_{i=1}^{n} X_i^k \) and \( k = ( \frac{ \sum_{i=1}^{n} [ X_i^k \cdot log(X_i)] }{ \sum_{i=1}^{n} [ X_i^k ] } - \frac{1}{n} \sum_{i=1}^{n} [ log(X_i) ] )^{-1} \), and we see that the one for \( \lambda^k \) depends on the value of \( k \), whereas the one for \( k \) does not depend on \( \lambda \), but is expressed in terms of itself and… I don’t know how to solve it. Typically, this is where things are glossed over during a Mathematical Statistics class, where students are told that “oh, you can solve the equation for \( k \) using a statistical software package”, but aren’t actually shown how to do it.</p>
<p>I did remember such situations happening in ST2132 (the Mathematical Statistics class I’ve taken), where we were trying to maximize the log likelihood for i.i.d. \( X_1, … X_n \) and the underlying distribution is one which is quite well studied. And we ran into this situation and the the lecturer and the notes mentioned that these are non-linear equations which will be quite difficult to evaluate by hand and can be solved numerically using a statistical software package.</p>
<p>I was trying to do this in Python, after all that is the language that Think Stats uses. So I googled a bit and read some questions and answers on Stack Overflow that seemed to be doing what I wanted. But I wasn’t sure, after all I was pretty new to all these and know absolutely nothing about it. I remembered I have a friend doing a PhD in Operations Research at MIT who might be familiar with these things. So I asked him for a bit of help which he kindly rendered.</p>
<p>Perhaps it was luck and persistence that got me through. I guess it was the query “python solve numerical equation” that yielded what I needed. Namely, <a href="http://stackoverflow.com/a/25208202">this answer on Stack Overflow by CT Zhu</a> and <a href="http://stackoverflow.com/a/22743440">this answer on Stack Overflow by nibot</a>. It seemed to me that one of <a href="http://docs.scipy.org/doc/scipy-0.13.0/reference/generated/scipy.optimize.root.html">scipy.optimize.root</a> or <a href="http://docs.scipy.org/doc/scipy-0.13.0/reference/generated/scipy.optimize.fsolve.html#scipy.optimize.fsolve">scipy.optimize.fsolve</a> was what I needed. Since the answer by CT Zhu and nibot both made use of <code>scipy.optimize.fsolve</code> and there was code there, I decided to go ahead with <code>scipy.optimize.fsolve</code>.</p>
<p><a href="http://docs.scipy.org/doc/scipy-0.13.0/reference/generated/scipy.optimize.fsolve.html#scipy.optimize.fsolve%60">Documentation for scipy.optimize.fsolve</a> states that it:</p>
<blockquote>
<p>Returns the roots of the (non-linear) equations defined by <code>func(x) = 0</code> given a starting estimate.</p>
</blockquote>
<p>Notice that we have \( k = ( \frac{ \sum_{i=1}^{n} [ X_i^k \cdot log(X_i)] }{ \sum_{i=1}^{n} [ X_i^k ] } - \frac{1}{n} \sum_{i=1}^{n} [ log(X_i) ] )^{-1} \). So in order to make use of <code>scipy.optimize.fsolve</code>, we have to convert it to a function equal to \( 0 \). That is simply \( ( \frac{ \sum_{i=1}^{n} [ X_i^k \cdot log(X_i)] }{ \sum_{i=1}^{n} [ X_i^k ] } - \frac{1}{n} \sum_{i=1}^{n} [ log(X_i) ] )^{-1} - k = 0 \) .</p>
<p>And how about the initial estimate? <a href="http://stackoverflow.com/a/22743440">nibot’s answer</a> states the following helpful tip:</p>
<blockquote>
<p>A good way to find such an initial guess is to just plot the expression and look for the zero crossing.</p>
</blockquote>
<p>So I did just that:</p>
<div class="figure">
<img src="../images/2015-09-15/weibull-k-parameter-plot.png" />

</div>
<p>Values of \( x \) are supplied to the equation \( f(k) = ( \frac{ \sum_{i=1}^{n} [ X_i^k \cdot log(X_i)] }{ \sum_{i=1}^{n} [ X_i^k ] } - \frac{1}{n} \sum_{i=1}^{n} [ log(X_i) ] )^{-1} - k \) (so \( k \) takes on each value of \( x \) ’s we are plotting). We see that the curve intersects with the line \( y = 0 \) at approximately \( x = 2 \). So \( 2.0 \) is an ok initial guess to supply to <code>scipy.optimize.fsolve</code>.</p>
<p>Notice that in \( f(k) = ( \frac{ \sum_{i=1}^{n} [ X_i^k \cdot log(X_i)] }{ \sum_{i=1}^{n} [ X_i^k ] } - \frac{1}{n} \sum_{i=1}^{n} [ log(X_i) ] )^{-1} - k \), there is \( log(X_i) \). For our simulated data, a large number of cohorts have 0 cancer cases, so \( X_i = 0 \) for those \( i \). However, \( log \) is undefined at \( 0 \). Hence, we have to exclude those data points during parameter estimation.</p>
<p>Here’s the code for parameter estimation of \( k \) using the method of Maximum Likelihood Estimate:</p>
<div class="highlight"><pre><span></span><span class="n">X_without_zero</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">simulated_data</span><span class="p">))</span>
<span class="n">X_without_zero_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_without_zero</span><span class="p">)</span>
<span class="n">log_X_without_zero</span> <span class="o">=</span> <span class="p">[</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">X_without_zero</span><span class="p">]</span>
<span class="n">one_over_n_sum_of_log_X_without_zero</span> <span class="o">=</span> \
    <span class="nb">sum</span><span class="p">(</span><span class="n">log_X_without_zero</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">X_without_zero_len</span><span class="p">)</span>
<span class="c1"># equation we're trying to find roots</span>
<span class="k">def</span> <span class="nf">_eqn_for_k</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
    <span class="n">numer</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X_without_zero_len</span><span class="p">):</span>
        <span class="n">numer</span> <span class="o">+=</span> <span class="p">(</span><span class="n">X_without_zero</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">**</span> <span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">log_X_without_zero</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X_without_zero_len</span><span class="p">):</span>
        <span class="n">denom</span> <span class="o">+=</span> <span class="p">(</span><span class="n">X_without_zero</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">**</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">numer</span> <span class="o">/</span> <span class="n">denom</span> <span class="o">-</span> <span class="n">one_over_n_sum_of_log_X_without_zero</span><span class="p">)</span> <span class="o">-</span> <span class="n">k</span>

<span class="c1"># This is a rough estimate from looking at the k parameter plot</span>
<span class="n">initial_guess</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="n">weibull_model_shape</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">fsolve</span><span class="p">(</span><span class="n">_eqn_for_k</span><span class="p">,</span>
    <span class="p">[</span><span class="n">initial_guess</span><span class="p">]</span>
<span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>

<p>And once we obtain the MLE for \( k \), we can easily compute the MLE for \( \lambda \). Since \( \lambda^k = \frac{1}{n} \sum_{i=1}^{n} X_i^k \), then \( \lambda = ( \frac{1}{n} \sum_{i=1}^{n} X_i^k )^{ \frac{1}{k} } \). The question is, since we excluded the zero data points when computing the MLE for \( k \), should we also exclude those points when computing the MLE for \( \lambda \)? Frankly speaking, I do not know. So I computed one value of \( \lambda \) that uses the zero data points and another one that excludes them:</p>
<div class="highlight"><pre><span></span><span class="n">weibull_model_scale_on_full_data</span> <span class="o">=</span> <span class="p">(</span>
    <span class="nb">sum</span><span class="p">((</span><span class="n">x</span> <span class="o">**</span> <span class="n">weibull_model_shape</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">simulated_data</span><span class="p">))</span> <span class="o">/</span> \
        <span class="nb">float</span><span class="p">(</span><span class="n">nr_cohorts</span><span class="p">)</span>
<span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">weibull_model_shape</span><span class="p">)</span>
<span class="n">weibull_model_scale_on_non_zero_data</span> <span class="o">=</span> <span class="p">(</span>
    <span class="nb">sum</span><span class="p">((</span><span class="n">x</span> <span class="o">**</span> <span class="n">weibull_model_shape</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">X_without_zero</span><span class="p">))</span> <span class="o">/</span> \
        <span class="nb">float</span><span class="p">(</span><span class="n">X_without_zero_len</span><span class="p">)</span>
<span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">weibull_model_shape</span><span class="p">)</span>
</pre></div>

<p>From this point, we’re going to use \( \hat{\lambda} \) to denote the value of \( \lambda \) that is computed using the full data set, and we’re going to use \( \widetilde{\lambda} \) to denote the value of \( \lambda \) that is computed using the non-zero values in the data set.</p>
<p>We’re going to do some plots. We’ll be needing the PDF of the Weibull, defined as \( f(x) = \frac{k}{\lambda} ( \frac{x}{\lambda} )^{k-1} e^{-(x / \lambda)^k} \) for \( x \geqslant 0 \). In code:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_weibull_pdf</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">shape</span> <span class="o">/</span> <span class="n">scale</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">scale</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">shape</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span>
        <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">((</span><span class="n">x</span> <span class="o">/</span> <span class="n">scale</span><span class="p">)</span> <span class="o">**</span> <span class="n">shape</span><span class="p">))</span>
</pre></div>

<p>This next part makes use of a <code>for</code> loop to do some plots for the 2 values of \( \lambda \):</p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">scale</span><span class="p">,</span> <span class="n">root_suffix</span> <span class="ow">in</span> <span class="p">[</span>
    <span class="p">(</span><span class="n">weibull_model_scale_on_full_data</span><span class="p">,</span> <span class="s2">&quot;scale-on-full-data&quot;</span><span class="p">,),</span>
    <span class="p">(</span><span class="n">weibull_model_scale_on_non_zero_data</span><span class="p">,</span> <span class="s2">&quot;scale-on-non-zero-data&quot;</span><span class="p">,),</span>
<span class="p">]:</span>
</pre></div>

<p>First, I did a CDF plot of the simulated data along with the Weibull model:</p>
<div class="highlight"><pre><span></span><span class="n">weibull_val_to_density</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">i</span><span class="p">,</span> <span class="n">incr</span><span class="p">,</span> <span class="n">max_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">simulated_data</span><span class="p">)</span>
<span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">max_val</span><span class="p">:</span>
    <span class="n">weibull_val_to_density</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_weibull_pdf</span><span class="p">(</span>
        <span class="n">weibull_model_shape</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">i</span>
    <span class="p">)</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="n">incr</span>
<span class="n">weibull_model_cdf</span> <span class="o">=</span> <span class="n">Cdf</span><span class="o">.</span><span class="n">MakeCdfFromDict</span><span class="p">(</span><span class="n">weibull_val_to_density</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;model&quot;</span>
<span class="p">)</span>
<span class="n">myplot</span><span class="o">.</span><span class="n">Cdfs</span><span class="p">([</span><span class="n">empirical_cdf</span><span class="p">,</span> <span class="n">weibull_model_cdf</span><span class="p">])</span>
<span class="n">myplot</span><span class="o">.</span><span class="n">Save</span><span class="p">(</span>
    <span class="n">root</span><span class="o">=</span><span class="s2">&quot;ex5-13-p1-cdf-with-weibull-model-{}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">root_suffix</span>
    <span class="p">),</span>
    <span class="n">formats</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;pdf&quot;</span><span class="p">,</span> <span class="s2">&quot;png&quot;</span><span class="p">,],</span>
    <span class="n">xlabel</span><span class="o">=</span><span class="s2">&quot;cancer cases&quot;</span><span class="p">,</span>
    <span class="n">ylabel</span><span class="o">=</span><span class="s2">&quot;CDF(x)&quot;</span><span class="p">,</span>
    <span class="n">title</span><span class="o">=</span><span class="s2">&quot;CDF &amp; Weibull model&quot;</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>

<p>Plot of empirical CDF and \( Weibull(\hat{\lambda}, k) \) CDF:</p>
<div class="figure">
<img src="../images/2015-09-15/cdf-with-weibull-model-scale-on-full-data.png" />

</div>
<p>Plot of empirical CDF and \( Weibull(\widetilde{\lambda}, k) \) CDF:</p>
<div class="figure">
<img src="../images/2015-09-15/cdf-with-weibull-model-scale-on-non-zero-data.png" />

</div>
<p>If we let \( W \) denote either one of our Weibull random variable, notice that \( \mathbb{P}(W &lt;= 0) \approx 0 \). However, it is about \( 0.4 \) for the empirical CDF. It also seems that if we shift the Weibull CDF plot to the left by 1 unit in the x-axis, then either model will be much better for our data, that is, if we ignore the region from \( [-1, 0) \). Let’s do it:</p>
<div class="highlight"><pre><span></span><span class="n">weibull_val_minus_one_to_density</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
        <span class="n">weibull_val_to_density</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">)</span>
<span class="p">)</span>
<span class="n">weibull_model_minus_one_cdf</span> <span class="o">=</span> <span class="n">Cdf</span><span class="o">.</span><span class="n">MakeCdfFromDict</span><span class="p">(</span>
    <span class="n">weibull_val_minus_one_to_density</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;model&quot;</span>
<span class="p">)</span>
</pre></div>

<p>Plot of empirical CDF and \( Weibull(\hat{\lambda}, k) \) CDF shifted by -1 unit along the x-axis:</p>
<div class="figure">
<img src="../images/2015-09-15/cdf-with-weibull-model-left-shifted-by-one-scale-on-full-data.png" />

</div>
<p>Plot of empirical CDF and \( Weibull(\widetilde{\lambda}, k) \) CDF shifted by -1 unit along the x-axis:</p>
<div class="figure">
<img src="../images/2015-09-15/cdf-with-weibull-model-left-shifted-by-one-scale-on-non-zero-data.png" />

</div>
<p>Hmm, despite some discrepancies, that indeed is the case. Let us take it a step further and accumulate all the densities from \( [-1, 0) \) and put them under \( 0 \) and leave the rest of the densities as they are:</p>
<div class="highlight"><pre><span></span><span class="n">sum_of_negative_and_zero_density</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
    <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">weibull_val_minus_one_to_density</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
<span class="n">weibull_val_to_density</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">weibull_val_minus_one_to_density</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">)</span>
<span class="p">)</span>
<span class="n">weibull_val_to_density</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum_of_negative_and_zero_density</span>
<span class="n">weibull_model_negative_grouped_with_zero_cdf</span> <span class="o">=</span> <span class="n">Cdf</span><span class="o">.</span><span class="n">MakeCdfFromDict</span><span class="p">(</span>
    <span class="n">weibull_val_to_density</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;model&quot;</span>
<span class="p">)</span>
</pre></div>

<p>Resulting plot for \( Weibull(\hat{\lambda}, k) \):</p>
<div class="figure">
<img src="../images/2015-09-15/cdf-with-weibull-model-negative-densities-accum-with-zero-scale-on-full-data.png" />

</div>
<p>Resulting plot for \( Weibull(\widetilde{\lambda}, k) \):</p>
<div class="figure">
<img src="../images/2015-09-15/cdf-with-weibull-model-negative-densities-accum-with-zero-scale-on-non-zero-data.png" />

</div>
<p>So \( \hat{\lambda} \) offers a good start for \( x = 0 \), but using \( \widetilde{\lambda} \) is a lot better for \( x = 1 \) onwards.</p>
<h2 id="validating-our-models">Validating our models</h2>
<p>We’ve done model fitting using the Exponential and Weibull distributions. The question is, how well do they generalize? Let’s perform another simulation to find out (and this is where our <code>_perform_simulation</code> function really shines):</p>
<div class="highlight"><pre><span></span><span class="n">test_data</span> <span class="o">=</span> <span class="n">_perform_simulation</span><span class="p">(</span><span class="n">nr_cohorts</span><span class="p">)</span>
<span class="n">test_data_cdf</span> <span class="o">=</span> <span class="n">Cdf</span><span class="o">.</span><span class="n">MakeCdfFromList</span><span class="p">(</span><span class="n">test_data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;test data&quot;</span><span class="p">)</span>
</pre></div>

<p>Exponential model:</p>
<div class="figure">
<img src="../images/2015-09-15/test-data-cdf-with-shifted-exp-model.png" />

</div>
<p>\(Weibull(\hat{\lambda}, k) \) model:</p>
<div class="figure">
<img src="../images/2015-09-15/test-data-cdf-with-weibull-model-negative-densities-accum-with-zero-scale-on-full-data.png" />

</div>
<p>\(Weibull(\widetilde{\lambda}, k) \) model:</p>
<div class="figure">
<img src="../images/2015-09-15/test-data-cdf-with-weibull-model-negative-densities-accum-with-zero-scale-on-non-zero-data.png" />

</div>
<p>I think there are much more mathematically rigorous ways to assess the strength of our models, but I don’t know them well and at this point, I feel that I’ve spent too much time and effort writing this blog post (it took me <em>much</em> longer to write this post than work on the actual problem).</p>
<h2 id="conclusion">Conclusion</h2>
<p>There are probably a lot of things that can be done better. These are the ones that I know of:</p>
<ul>
<li>Using proper stopping rules to determine the number of cohorts we should use for the simulation, instead of using an arbitrary number like \( 1000000 \) as I did</li>
<li>Using more rigorous ways to determine how well our models fare on other simulated data sets</li>
<li>I did something crazy by shifting the model based on the Exponential distribution to the left by accumulating densities, and the same trick was used for the model based on the Weibull distribution. I have to confess that for this step, mathematically I have no idea whether what I’m doing is valid and how we can characterize the resulting distribution.</li>
<li>During parameter estimation of \( k \) for the Weibull model, I discarded all the \( X_i = 0 \) values. Later on, I didn’t know whether to use the entire simulated data set or the same truncated data set that we used for paramter estimation of \( k \) to estimate \( \lambda \).</li>
</ul>
<p>I learnt a lot from thinking a bit more about this exercise and wondering:</p>
<ul>
<li>Can we do more than just doing the various variants of the CDF plots and observing trends?</li>
<li>What is the next step that we can do?</li>
<li>Should we try to plot the distributions we’re using as models and see visually how well they fit the data?</li>
<li>What will enable us to plot such distributions?</li>
</ul>
<p>Then I realized that I have some familiarity with the Exponential and Normal distributions, and while the Pareto and Weibull distributions are new to me, <a href="../posts/2015-08-04-note-on-think-stats-multiplying-a-pareto-random-variable-with-x_m-eq-1-by-a-positive-number-what-do-we-get.html">I did a small blog post on the Pareto Distribution</a> and also an exercise on the Weibull distribution so they are not entirely unfamiliar to me. I went on to realize that these distributions are are defined by parameters. For instance, the Exponential distribution is parameterized by \( \lambda \), while the Normal distribution is parameterized by its mean \( \mu \) and variance \( \sigma^2 \).</p>
<p>Probably because of the preparation I did for the final exam of the ST2132 Mathematical Statistics class I took earlier this year, I recalled that there are ways in which we can figure out the parameters given a data set that we know (or in this case, believe) comes from a certain distribution - namely the Method of Moments and Maximum Likelihood Estimate method. This gave me the possibility to explore the exercise on a deeper level instead of just stopping at the step where we look at the various variants of the CDF plots to see if they display some trend. Taking action on this newfound knowledge was the next very crucial step.</p>
<p>While some people may think that it’s a waste of time to derive the algebraic form of the Method of Moments and MLE parameter estimates of the various distributions by hand, especially when the results are available on the Internet, I think that this is a very good revision of the Statistics that I’ve picked up earlier this year. In particular, it was a very interesting exercise to figure out the parameter estimates for the Weibull distribution - not just because I figured out a really bad Calculus mistake I made along the way, but also because it forced me to figure out which libraries to use to solve for an equation \( f(x) = 0 \) numerically - just so I could come up with a model based on the Weibull distribution.</p>
<p>After doing all that work, I figured that it would be great it I could blog about it - it was a terrific decision. Some of the benefits I’ve gained out of writing this blog post:</p>
<ul>
<li>Writing this blog post clarified a lot of things for me, because whenever I’m trying to explain something that I don’t fully understand, I’m forced to spend time to think through what exactly I’m trying to explain, after all I can’t just write some incoherent junk. This leads to a much greater understanding and solidification of the knowledge I’ve picked up compared to if I was to just do the exercise and call it a day. Some examples of what I’ve spent time figuring out are:
<ul>
<li>Expectation vs. Probability (yes, I know I’m a noob to even confuse them)</li>
<li>Why we can use Bernoulli random variables to simulate whether each individual in a cohort contracts cancer</li>
<li>Greater confidence that we’re doing the simulation correctly</li>
</ul></li>
<li>That the Method of Moments and the method of Maximum Likelihood Estimate are used for <strong>parameter estimation</strong>. I was using them in the Python code without realizing I was doing parameter estimation - it only occurred to me when I was writing this post. It is my belief that knowing the name of something makes a difference.</li>
<li>Somewhere in the middle of writing this post, I decided to make the source code available as well. As such, I was forced to clean up a lot of the code I wrote, which was in a rather messy state. It’s still somewhat messy after the cleanup but a lot better than before the cleanup.</li>
<li>A combination of 1. making mistakes in the code 2. refactoring the code 3. making changes to the code so it does new things meant that I had to regenerate the various plots. Many many times. Initially, the code generated the plots in EPS and PDF format. Each time I had to regenerate the plots, I would open up the PDF file, take a screenshot, crop it, then copy and paste it to the images folder for the blog. It was very tedious. Add on to the fact that there were some plots on which I manually drew a curve in red ink using Gimp. After several times, I got sick of doing everything manually. There was nothing I could do about the part where I had to draw a curve manually for some of the plots (thankfully there were not a lot of those and I could delay this process to after everything else was done), but the process by which I had to obtain the final images of the plots for this post was annoying me greatly. So I wondered: can I generate images of the plots instead of just EPS and PDF? Like, PNG images. Turns out that matplotlib can generate plots in PNG format. Next thing on my mind was: ok, is there a way I can programmatically resize the plots so I don’t have to manually crop them anymore? There’s a way to do that as well, using ImageMagick. And I can write a shell script to resize all the images using ImageMagick, dumping the output of each resize to a destination image in the blog’s images folder. All by running 2 commands, one for the python code to generate the plots, the other to do the image resizing. Automation at its finest.</li>
<li>For <code>scipy.optimize.fsolve</code>, we need to specify an initial guess. Initially, I supplied \( 1.0 \) probably because \( 0 \) didn’t work. I didn’t actually know the use of the initial guess and essentially filled in a number just because I had to fill in something, until I read <a href="http://stackoverflow.com/a/22743440">nibot’s answer</a> and thought that it would be a good idea to plot a curve of the \( k \) parameter and see where it crosses the \( y = 0 \) line. Visual inspection of the plot determined that \( 2.0 \) will be a closer estimate to the parameter than \( 1.0 \). So I changed my code to use that. Through this process, I obtained a much better understanding of the purpose of the initial guess in <code>scipy.optimize.fsolve</code>. I don’t know if this is true (but I’m thinking that it is), I also read <a href="http://stackoverflow.com/a/22743496">behzad.nouri’s answer</a> which says that no numerical algorithm can figure out all the solutions. I assume I have to add this: “especially if the initial guess is way off”.</li>
</ul>
<p>There might be more stuff I’ve left out but these are probably the most important ones.</p>
<p>This is also the second rather long blog post I’ve written since my first real blog post (if you don’t count the “Hello World!” blog post), <a href="../posts/2013-08-27-ngtut.html">A very long AngularJS tutorial</a>. And it’s slightly more than 2 years since then. This blog post is a lot more obscure than the AngularJS tutorial and is a purely academic exercise that is probably of interest only to myself, but the sense of accomplishment that I feel for completing this post is much greater than that for the AngularJS tutorial, especially because I feel that the topic of this post, Mathematical Statistics, is harder than AngularJS. And unlike the last time, I’m no longer a student and I did this during my spare time outside working hours - that means a lot to me because it is a demonstration that I had the discipline to pull through. I hope to author more posts of this nature (a longer and more involved nature) in the future on some topic in Mathematics, Statistics or Machine Learning - preferrably all of them at the same time =P I hope I’m not biting off more than I can chew (again).</p>
<p>To greater knowledge!</p>
<h2 id="credits">Credits</h2>
<p>Ng Yee Sian, for providing assistance.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="http://stackoverflow.com/a/25208202">python - Function returns a vector, how to minimize in via Numpy (answer by CT Zhu)</a></li>
<li><a href="http://stackoverflow.com/a/22743440">Solve an equation using a python numerical solver in numpy (answer by nibot)</a></li>
<li><a href="http://stackoverflow.com/a/22743496">Solve an equation using a python numerical solver in numpy (answer by behzad.nouri)</a></li>
<li><a href="http://docs.scipy.org/doc/scipy-0.13.0/reference/generated/scipy.optimize.root.html">scipy.optimize.root - SciPy v0.13.0 Reference Guide</a></li>
<li><a href="http://docs.scipy.org/doc/scipy-0.13.0/reference/generated/scipy.optimize.fsolve.html#scipy.optimize.fsolve">scipy.optimize.fsolve - SciPy v0.13.0 Reference Guide</a></li>
</ul>
</div>
<div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'pangyanhan'; // required: replace example with your forum shortname
        var disqus_identifier = "posts/2015-09-15-note-on-think-stats-ex-5-13-part-1-aka-using-what-i-learnt-in-a-mathematical-statistics-class.md";
        var disqus_url = "http://blog.pangyanhan.com/posts/2015-09-15-note-on-think-stats-ex-5-13-part-1-aka-using-what-i-learnt-in-a-mathematical-statistics-class.html";

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

          </div>
        </div>

        <div class="row footer">
          <div class="medium-12 columns">
            <div class="footer-item">
              <span>Github</span>
              <a href="https://github.com/yanhan/">github.com/yanhan</a>
            </div>
            <div class="hakyll-line">
              Site proudly generated by
              <a href="http://jaspervdj.be/hakyll" target="_blank">Hakyll</a>
            </div>
          </div>
        </div>
      </div>

      <script src="../js/vendor/jquery.js"></script>
      <script src="../js/foundation.min.js"></script>
      <script>
        $(document).foundation();
        var navigation = responsiveNav(".nav-collapse", {
          animate: true,
          transition: 284,
          label: "",
          insert: "after",
          openPos: "relative",
          navActiveClass: "js-nav-active"
        });
      </script>
      <script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create', 'UA-49506023-1', 'pangyanhan.com');ga('send', 'pageview');</script>
    </body>
</html>
