<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Haskell deep dive: zsh-git-prompt - Yan Han's blog</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="author" content="Pang Yan Han">
        <link rel="stylesheet" href="../css/normalize.css">
        <link rel="stylesheet" href="../css/foundation.min.css">
        <link rel="stylesheet" href="../css/responsive-nav.css">
        <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet" type="text/css">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="../css/my-pygments-colorscheme.css">
        <link rel="stylesheet" href="../css/main.css">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css">

        <script src="../js/vendor/modernizr.js"></script>
        <script src="../js/responsive-nav.min.js"></script>
        <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
            tex2jax: {
              inlineMath: [ ["\\(", "\\)"] ],
              processEscapes: true
            }
          });
        </script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
    </head>

    <body>
      <div class="site">
        <div class="row">
          <div class="small-6 columns">
            <h1 class="title"><a href="../">yan han's blog</a></h1>
          </div>
          <div class="small-6 columns">
            <div class="header-icons header-icons-translate show-for-medium-up">
              <a href="../atom.xml" target="_blank">
                <i class="fa fa-rss-square fa-4x"></i>
              </a>
              <a href="https://github.com/yanhan" target="_blank">
                <i class="fa fa-github-alt fa-4x"></i>
              </a>
              <a href="http://sg.linkedin.com/pub/yan-han-pang/92/158/91b" target="_blank">
                <i class="fa fa-linkedin fa-4x"></i>
              </a>
              <a href="https://twitter.com/yanhan_pang" target="_blank">
                <i class="fa fa-twitter fa-4x"></i>
              </a>
            </div>
            <div class="header-icons show-for-small-only">
              <a href="../atom.xml" target="_blank">
                <i class="fa fa-rss-square fa-2x"></i>
              </a>
              <a href="https://github.com/yanhan" target="_blank">
                <i class="fa fa-github-alt fa-2x"></i>
              </a>
              <a href="http://sg.linkedin.com/pub/yan-han-pang/92/158/91b" target="_blank">
                <i class="fa fa-linkedin fa-2x"></i>
              </a>
              <a href="https://twitter.com/yanhan_pang" target="_blank">
                <i class="fa fa-twitter fa-2x"></i>
              </a>
            </div>
          </div>
        </div>

        <div class="row">
          <div class="small-12 columns">
            <nav class="header nav-collapse">
              <ul>
                <li><a class="extra" href="../">home</a></li>
                <li><a class="extra" href="../about.html">about</a></li>
                <li><a class="extra" href="../haskell">Haskell</a></li>
                <li><a class="extra" href="../bookshelf.html">bookshelf</a></li>
                <li><a class="extra" href="../interesting-talks.html">interesting talks</a></li>
                <li><a class="extra" href="../archive.html">archive</a></li>
              </ul>
            </nav>
          </div>
        </div>

        <div class="row">
          <div class="small-12 columns">
            <h2>Haskell deep dive: zsh-git-prompt</h2>
<p class="meta">
  09 Dec 2017,
  
    by <span class="italic">Pang Yan Han</span>
  
</p>
<div class="post-tags">
  <i class="fa fa-tags"></i>Tags: <a href="../tags/haskell.html">haskell</a>, <a href="../tags/zsh.html">zsh</a>, <a href="../tags/zsh-git-prompt.html">zsh-git-prompt</a>, <a href="../tags/deep%20dive.html">deep dive</a>
</div>
<div class="post">
  <p>In <a href="http://www.catb.org/esr/faqs/hacker-howto.html">How To Become A Hacker</a>, Eric S. Raymond gives the following golden advice:</p>
<blockquote>
<p>Learning to program is like learning to write good natural language. The best way to do it is to read some stuff written by masters of the form, write some things yourself, read a lot more, write a little more, read a lot more, write some more … and repeat until your writing begins to develop the kind of strength and economy you see in your models.</p>
</blockquote>
<p>This year, when I decided to give another shot at learning Haskell again, I realized that I needed not just tutorials to study, but also actual code. The reason is, as much as tutorials help to illustrate concepts, it is in actual code that one learns how to compose things together and see some tricks that are not covered in tutorials. About 6 years ago, I was an active user of Arch Linux and wanted to contribute to their package manager, Pacman. Pacman was written in C, which was a language I was using rather heavily at that time. I thought I knew C, but it was a rather eye opening experience to study the Pacman source code and see some real world C code from a program that I used on a day to day basis. Heck, I even contributed slightly to pacman-key probably as a result of that.</p>
<p>Ok, enough with the stuff that doesn’t concern anyone else.</p>
<p>After some serious searching, I found <a href="https://github.com/olivierverdier/zsh-git-prompt">zsh-git-prompt</a>. It is the probably the first serious Haskell program I’ve studied and understood. What makes this codebase so good for a beginner are:</p>
<ul>
<li>It is pretty short. 464 lines to be precise for <code>.hs</code> files in the <code>src</code> dir based on the output of a find command</li>
<li>It is a real world program. At least for zsh users. What zsh-git-prompt does is, whenever you cd into a directory that is a git repository (and all subdirs in it), it will show you some information about the git repo. For instance, whether the git repo is clean, the number of staged changes, how many commits has it diverged from its tracking branch, etc</li>
<li>Once you install it, you see it all the time you are working with code. If you happen to be learning Haskell and happen to hit a wall and feel like giving up (happens to most people I believe), look at that shiny zsh-git-prompt showing you your git repo’s status and you know that Haskell is capable of doing so much and the difference maker is the person that is between the chair and the keyboard. Extra motivation to work harder to eventually be able to write something useful in Haskell!</li>
</ul>
<h2 id="prerequisite-knowledge">Prerequisite knowledge</h2>
<p>As I was writing this post, I realized that there are a number of things that the reader must know to truly understand the code (even with my guidance) and that for me to explain those concepts in detail will make an already long post even longer.</p>
<p>This knowledge is often summarized by the phrase “the first N chapters of LYAH”, where <code>N</code> is usually 7 and LYAH is the <a href="http://learnyouahaskell.com/">Learn You a Haskell book</a>. I would say that the prereqs for understanding this post is pretty much the first 12 chapters of LYAH. Specifically, the following:</p>
<ul>
<li>Some knowledge of Monads</li>
<li>Definition of the Maybe monad and the List monad. Specifically, each of their definition of <code>&gt;&gt;=</code> and what it does in <code>do</code> notation</li>
</ul>
<p>Non Haskell related knowledge:</p>
<ul>
<li>Some knowledge of git and shell scripting</li>
</ul>
<h2 id="target-audience">Target Audience</h2>
<p>Haskell beginners who have some / all of the prereq knowledge above. You should also be willing to google to find out more information about concepts I didn’t explain too well / skipped over.</p>
<p>If you have read LYAH or similar but you are finding it very hard to use your newfound knowledge to write a real world application, I believe that you will find this post helpful.</p>
<h2 id="software-required">Software required</h2>
<p>It is also highly recommended that you install zsh and zsh-git-prompt; you will doubly appreciate this post and what the zsh-git-prompt does. If you are a zsh user but just lack zsh-git-prompt, check out our <a href="../posts/how-to-install-zsh-git-prompt.html">blog post on how to install zsh-git-prompt</a>.</p>
<p>Alternatively, if you do not wish to go through the hassle of installing zsh and zsh-git-prompt on your system, you can head over to <a href="https://github.com/yanhan/zsh-git-prompt-docker" class="uri">https://github.com/yanhan/zsh-git-prompt-docker</a> to pull / build our Docker image; simply follow the instructions in the README of that repo.</p>
<h2 id="version-we-are-covering">Version we are covering</h2>
<p>We will be going through tag <code>v0.5</code> of zsh-git-prompt. At the time of writing, it happens to be the HEAD of master branch. You can also go to <a href="https://github.com/olivierverdier/zsh-git-prompt/tree/v0.5" class="uri">https://github.com/olivierverdier/zsh-git-prompt/tree/v0.5</a> and browse the files there.</p>
<p>Throughout this post, we will be referencing zsh-git-prompt source code on its GitHub repo that fall under the <code>v0.5</code> tag.</p>
<h2 id="finding-main">Finding main</h2>
<p>Looking at <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/stack.yaml#L7">stack.yaml</a>, we see:</p>
<div class="highlight"><pre><span></span>packages:
- 'src'
</pre></div>

<p>which tells us that we should look at the <code>src</code> directory. Listing that directory shows us there is a <code>.cabal</code> file in <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/git-prompt.cabal">git-prompt.cabal</a>. In the <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/git-prompt.cabal#L23"><code>executable</code> section</a>, we see the following:</p>
<div class="highlight"><pre><span></span>executable gitstatus
  hs-source-dirs:      app
  main-is:             Main.hs
  ghc-options:         -threaded -rtsopts -with-rtsopts=-N
  build-depends:       base, git-prompt, parsec &gt;=3.1, process&gt;=1.1.0.2, QuickCheck
  default-language:    Haskell2010
  ghc-options: -Wall -O2 -fno-warn-tabs -fno-warn-unused-do-bind
  cc-options: -O3
</pre></div>

<p>So the main function sits at <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/app/Main.hs">app/Main.hs</a> (within the top level <code>src</code> dir). As an aside, there are very few dependencies on third party libraries.</p>
<p>I have to admit that this is a rather roundabout way to find the main function. In practice, it is much easier to do a <code>git grep -n main</code>. But this process teaches us some stuff about Stack and Cabal.</p>
<h2 id="the-main-function">The main function</h2>
<div class="highlight"><pre><span></span><span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> <span class="c1">-- IO</span>
  <span class="n">status</span> <span class="ow">&lt;-</span> <span class="n">getContents</span>
  <span class="n">mhash</span> <span class="ow">&lt;-</span> <span class="n">unsafeInterleaveIO</span> <span class="n">gitrevparse</span> <span class="c1">-- defer the execution until we know we need the hash</span>
  <span class="kr">let</span> <span class="n">result</span> <span class="ow">=</span> <span class="kr">do</span> <span class="c1">-- Maybe</span>
    <span class="n">strings</span> <span class="ow">&lt;-</span> <span class="n">stringsFromStatus</span> <span class="n">mhash</span> <span class="n">status</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">unwords</span> <span class="n">strings</span><span class="p">)</span>
  <span class="n">putStr</span> <span class="p">(</span><span class="n">fromMaybe</span> <span class="s">&quot;&quot;</span> <span class="n">result</span><span class="p">)</span>
</pre></div>

<p>Ok. This is short but not very straightforward at first glance. There are some functions that we may not be familiar with, so we turn to <a href="https://www.haskell.org/Hoogle/">Hoogle</a>.</p>
<div class="highlight"><pre><span></span><span class="nf">getContents</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="kt">String</span>
<span class="c1">-- The getContents operation returns all user input as a single string, which</span>
<span class="c1">-- is read lazily as it is needed (same as hGetContents stdin).</span>

<span class="nf">unsafeInterleaveIO</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span>
<span class="c1">-- unsafeInterleaveIO allows an IO computation to be deferred lazily. When</span>
<span class="c1">-- passed a value of type IO a, the IO will only be performed when the value of</span>
<span class="c1">-- the a is demanded. This is used to implement lazy file reading, see</span>
<span class="c1">-- hGetContents.</span>

<span class="nf">unwords</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="c1">-- unwords is an inverse operation to words. It joins words with separating</span>
<span class="c1">-- spaces.</span>
</pre></div>

<p>Ok. The first question is, what is with the <code>status &lt;- getContents</code>? It is not like we are supplying any input via stdin to zsh-git-prompt; we simply see the zsh-git-prompt displayed on our terminal when we are in a git repo without having us to do anything. So this input must be coming from somewhere else.</p>
<p>Indeed, if we look at the <a href="https://github.com/olivierverdier/zsh-git-prompt/tree/v0.5#install">Install section of the README</a>, we see the following:</p>
<blockquote>
<p>Source the file zshrc.sh from your ~/.zshrc config file, and configure your prompt. So, somewhere in ~/.zshrc, you should have:</p>
</blockquote>
<div class="highlight"><pre><span></span><span class="nb">source</span> path/to/zshrc.sh
<span class="c1"># an example prompt</span>
<span class="nv">PROMPT</span><span class="o">=</span><span class="s1">'%B%m%~%b$(git_super_status) %# '</span>
</pre></div>

<p>The magic lies with the <code>git_super_status</code> zsh function and the <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/zshrc.sh">zshrc.sh</a> script. We open that file and find the <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/zshrc.sh#L64">git_super_status</a> function. This is where the prompt gets constructed. Most notably, it starts with:</p>
<div class="highlight"><pre><span></span>git_super_status() {
    precmd_update_git_vars
</pre></div>

<p>Here’s the definition of the <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/zshrc.sh#L32">precmd_update_git_vars</a> function:</p>
<div class="highlight"><pre><span></span><span class="k">function</span> precmd_update_git_vars<span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">[</span> -n <span class="s2">&quot;</span><span class="nv">$__EXECUTED_GIT_COMMAND</span><span class="s2">&quot;</span> <span class="o">]</span> <span class="o">||</span> <span class="o">[</span> ! -n <span class="s2">&quot;</span><span class="nv">$ZSH_THEME_GIT_PROMPT_CACHE</span><span class="s2">&quot;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
        update_current_git_vars
        <span class="nb">unset</span> __EXECUTED_GIT_COMMAND
    <span class="k">fi</span>
<span class="o">}</span>
</pre></div>

<p>which points to the <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/zshrc.sh#L43">update_current_git_vars</a> function as the likely workhorse:</p>
<div class="highlight"><pre><span></span><span class="k">function</span> update_current_git_vars<span class="o">()</span> <span class="o">{</span>
    <span class="nb">unset</span> __CURRENT_GIT_STATUS

    <span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;</span><span class="nv">$GIT_PROMPT_EXECUTABLE</span><span class="s2">&quot;</span> <span class="o">==</span> <span class="s2">&quot;python&quot;</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
        <span class="nb">local</span> <span class="nv">gitstatus</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$__GIT_PROMPT_DIR</span><span class="s2">/gitstatus.py&quot;</span>
        <span class="nv">_GIT_STATUS</span><span class="o">=</span><span class="sb">`</span>python <span class="si">${</span><span class="nv">gitstatus</span><span class="si">}</span> <span class="m">2</span>&gt;/dev/null<span class="sb">`</span>
    <span class="k">fi</span>
    <span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;</span><span class="nv">$GIT_PROMPT_EXECUTABLE</span><span class="s2">&quot;</span> <span class="o">==</span> <span class="s2">&quot;haskell&quot;</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
        <span class="nv">_GIT_STATUS</span><span class="o">=</span><span class="sb">`</span>git status --porcelain --branch <span class="p">&amp;</span>&gt; /dev/null <span class="p">|</span> <span class="nv">$__GIT_PROMPT_DIR</span>/src/.bin/gitstatus<span class="sb">`</span>
    <span class="k">fi</span>
     <span class="nv">__CURRENT_GIT_STATUS</span><span class="o">=(</span><span class="s2">&quot;</span><span class="si">${</span><span class="p">(@s: :)_GIT_STATUS</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">)</span>
  <span class="nv">GIT_BRANCH</span><span class="o">=</span><span class="nv">$__CURRENT_GIT_STATUS</span><span class="o">[</span><span class="m">1</span><span class="o">]</span>
  <span class="nv">GIT_AHEAD</span><span class="o">=</span><span class="nv">$__CURRENT_GIT_STATUS</span><span class="o">[</span><span class="m">2</span><span class="o">]</span>
  <span class="nv">GIT_BEHIND</span><span class="o">=</span><span class="nv">$__CURRENT_GIT_STATUS</span><span class="o">[</span><span class="m">3</span><span class="o">]</span>
  <span class="nv">GIT_STAGED</span><span class="o">=</span><span class="nv">$__CURRENT_GIT_STATUS</span><span class="o">[</span><span class="m">4</span><span class="o">]</span>
  <span class="nv">GIT_CONFLICTS</span><span class="o">=</span><span class="nv">$__CURRENT_GIT_STATUS</span><span class="o">[</span><span class="m">5</span><span class="o">]</span>
  <span class="nv">GIT_CHANGED</span><span class="o">=</span><span class="nv">$__CURRENT_GIT_STATUS</span><span class="o">[</span><span class="m">6</span><span class="o">]</span>
  <span class="nv">GIT_UNTRACKED</span><span class="o">=</span><span class="nv">$__CURRENT_GIT_STATUS</span><span class="o">[</span><span class="m">7</span><span class="o">]</span>
<span class="o">}</span>
</pre></div>

<p>What should catch our attention is the following 3 lines:</p>
<div class="highlight"><pre><span></span>    <span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;</span><span class="nv">$GIT_PROMPT_EXECUTABLE</span><span class="s2">&quot;</span> <span class="o">==</span> <span class="s2">&quot;haskell&quot;</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
        <span class="nv">_GIT_STATUS</span><span class="o">=</span><span class="sb">`</span>git status --porcelain --branch <span class="p">&amp;</span>&gt; /dev/null <span class="p">|</span> <span class="nv">$__GIT_PROMPT_DIR</span>/src/.bin/gitstatus<span class="sb">`</span>
    <span class="k">fi</span>
</pre></div>

<p>Suppose <code>GIT_PROMPT_EXECUTABLE</code> has the value <code>haskell</code>. Then <code>git status --porcelain --branch &amp;&gt;/dev/null | $__GIT_PROMPT_DIR/src/.bin/gitstatus</code> is executed. Despite some experience in Bash, the <code>&amp;&gt;</code> tripped me up because I didn’t use it. So I did some googling and I found out that in Bash, the <code>&amp;&gt;</code> redirects both standard output and standard error to the same location, which in this case, is <code>/dev/null</code>.</p>
<p>That doesn’t make sense. If both standard output and standard error are redirected to <code>/dev/null</code>, wouldn’t the <code>$__GIT_PROMPT_DIR/src/.bin/gitstatus</code> program not get any input? Or, does that program not require any standard input and it will just work? To verify, I ran the following commands in a git repo:</p>
<div class="highlight"><pre><span></span>git status --porcelain --branch &amp;&gt;/dev/null | $__GIT_PROMPT_DIR/src/.bin/gitstatus
</pre></div>

<p>versus</p>
<div class="highlight"><pre><span></span>$__GIT_PROMPT_DIR/src/.bin/git status &lt;/dev/null
</pre></div>

<p>The first showed me:</p>
<div class="highlight"><pre><span></span>master 95 0 0 0 1 1
</pre></div>

<p>and the second did not output anything. So clearly, it was receiving standard input from the <code>git status --porcelain --branch</code> command!</p>
<p>At this point, I was wondering, what the hell was going on? If all output from the <code>git status --porcelain --branch</code> command was redirected to <code>/dev/null</code>, shouldn’t it effectively be doing the same thing as supplying no standard input to the next program?</p>
<p>I tried a few other things but this one kind of blew my mind:</p>
<div class="highlight"><pre><span></span>git status --porcelain --branch &amp;&gt;/dev/null &gt;a &gt;o
</pre></div>

<p>Both <code>a</code> and <code>o</code> contained the output of the command! Seems like there is multiple output redirection going on. Something I didn’t know was possible.</p>
<p>A google search for “stdout redirect to multiple linux” turned out the usual answers (most commonly using <code>tee</code>), but also <a href="https://unix.stackexchange.com/a/129184">this answer on Unix &amp; Linux Stack Exchange</a>:</p>
<blockquote>
<p>With zsh:</p>
</blockquote>
<div class="highlight"><pre><span></span>ls &gt; file1 &gt; file2
</pre></div>

<blockquote>
<p>(internally, zsh creates a pipe and spawns a process that reads from that pipe and writes to the two files as tee does. ls stdout is the other end of the pipe).</p>
</blockquote>
<p>and also the <a href="https://unix.stackexchange.com/a/345508">following answer</a>:</p>
<blockquote>
<p>As <span class="citation">@jofel</span> mentioned in a comment under the answer, this can be done natively in zsh:</p>
</blockquote>
<div class="highlight"><pre><span></span>echo foobar &gt;file1 &gt;file2 &gt;file3
</pre></div>

<blockquote>
<p>or, with brace expansion:</p>
</blockquote>
<div class="highlight"><pre><span></span>echo foobar &gt;file{1..3}
</pre></div>

<blockquote>
<p>Internally this works very similarly to the tee answers provided above. The shell connects the command’s stdout to a process that pipes to multiple files; therefore, there isn’t any compelling technical advantage to doing it this way (but it does look real good). See the zsh manual for more.</p>
</blockquote>
<p>And it links to the <a href="http://zsh.sourceforge.net/Doc/Release/Redirection.html">Redirection chapter of the zsh manual</a>. Turns out zsh has a feature known as Multios that allows multiple output redirection. That section opens with:</p>
<blockquote>
<p>If the user tries to open a file descriptor for writing more than once, the shell opens the file descriptor as a pipe to a process that copies its input to all the specified outputs, similar to tee, provided the MULTIOS option is set, as it is by default. Thus:</p>
</blockquote>
<div class="highlight"><pre><span></span>date &gt;foo &gt;bar
</pre></div>

<blockquote>
<p>writes the date to two files, named ‘foo’ and ‘bar’. Note that a pipe is an implicit redirection; thus</p>
</blockquote>
<div class="highlight"><pre><span></span>date &gt;foo | cat
</pre></div>

<blockquote>
<p>writes the date to the file ‘foo’, and also pipes it to cat.</p>
</blockquote>
<p>So we totally misunderstood the context. Our premise of reasoning about the behavior of the command in Bash is totally wrong because we are not using Bash but zsh!</p>
<p>Therefore</p>
<div class="highlight"><pre><span></span>git status --porcelain --branch &amp;&gt;/dev/null | $__GIT_PROMPT_DIR/src/.bin/gitstatus
</pre></div>

<p>does indeed redirect the standard output of <code>git status --porcelain --branch</code> to the <code>$__GIT_PROMPT_DIR/src/.bin/gitstatus</code> program.</p>
<p>Looking at the <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/stack.yaml#L30">lines 30 to 34 of stack.yaml</a>:</p>
<div class="highlight"><pre><span></span># Extra directories used by stack for building
# extra-include-dirs: [/path/to/dir]
# extra-lib-dirs: [/path/to/dir]

local-bin-path: './src/.bin'
</pre></div>

<p>and <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/git-prompt.cabal#L23">line 23 of src/git-prompt.cabal</a>:</p>
<div class="highlight"><pre><span></span>executable gitstatus
</pre></div>

<p>We see that <code>stack install</code> will indeed build a program named <code>gitstatus</code> and place it in the <code>src/.bin</code> directory of the repo. So indeed our guess that something else is piping its output as standard input to the main function of the zsh-git-prompt Haskell program is correct. So we explained a grand total of… one truly meaningful line of Haskell code:</p>
<div class="highlight"><pre><span></span><span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> <span class="c1">-- IO</span>
  <span class="n">status</span> <span class="ow">&lt;-</span> <span class="n">getContents</span>
</pre></div>

<p>Nevertheless, we have learnt a lot more about how zsh-git-prompt works overall. Let’s return to our main function:</p>
<div class="highlight"><pre><span></span><span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> <span class="c1">-- IO</span>
  <span class="n">status</span> <span class="ow">&lt;-</span> <span class="n">getContents</span>
  <span class="n">mhash</span> <span class="ow">&lt;-</span> <span class="n">unsafeInterleaveIO</span> <span class="n">gitrevparse</span> <span class="c1">-- defer the execution until we know we need the hash</span>
  <span class="kr">let</span> <span class="n">result</span> <span class="ow">=</span> <span class="kr">do</span> <span class="c1">-- Maybe</span>
    <span class="n">strings</span> <span class="ow">&lt;-</span> <span class="n">stringsFromStatus</span> <span class="n">mhash</span> <span class="n">status</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">unwords</span> <span class="n">strings</span><span class="p">)</span>
  <span class="n">putStr</span> <span class="p">(</span><span class="n">fromMaybe</span> <span class="s">&quot;&quot;</span> <span class="n">result</span><span class="p">)</span>
</pre></div>

<p>The next line of code is:</p>
<div class="highlight"><pre><span></span>  <span class="n">mhash</span> <span class="ow">&lt;-</span> <span class="n">unsafeInterleaveIO</span> <span class="n">gitrevparse</span> <span class="c1">-- defer the execution until we know we need the hash</span>
</pre></div>

<p>and from our Hoogle search above:</p>
<div class="highlight"><pre><span></span><span class="nf">unsafeInterleaveIO</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span>
<span class="c1">-- unsafeInterleaveIO allows an IO computation to be deferred lazily. When</span>
<span class="c1">-- passed a value of type IO a, the IO will only be performed when the value of</span>
<span class="c1">-- the a is demanded. This is used to implement lazy file reading, see</span>
<span class="c1">-- hGetContents.</span>
</pre></div>

<p>So <code>unsafeInterleaveIO gitrevparse</code> will only call the <code>gitrevparse</code> function when necessary. As for why it is unsafe, please read <a href="https://stackoverflow.com/questions/13263692/when-is-unsafeinterleaveio-unsafe">this Stack Overflow question and its answers</a>. Truth to be told, I do not know enough to explain it and any explanation will make this already long post even longer.</p>
<p>The <code>gitrevparse</code> function is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/app/Main.hs#L20">defined in the src/app/Main.hs file</a> and is as follows:</p>
<div class="highlight"><pre><span></span><span class="nf">gitrevparse</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="kt">Hash</span><span class="p">)</span>
<span class="nf">gitrevparse</span> <span class="ow">=</span> <span class="kr">do</span> <span class="c1">-- IO</span>
    <span class="n">mresult</span> <span class="ow">&lt;-</span> <span class="n">safeRun</span> <span class="s">&quot;git&quot;</span> <span class="p">[</span><span class="s">&quot;rev-parse&quot;</span><span class="p">,</span> <span class="s">&quot;--short&quot;</span><span class="p">,</span> <span class="s">&quot;HEAD&quot;</span><span class="p">]</span>
    <span class="kr">let</span> <span class="n">rev</span> <span class="ow">=</span> <span class="kr">do</span> <span class="c1">-- Maybe</span>
      <span class="n">result</span> <span class="ow">&lt;-</span> <span class="n">mresult</span>
      <span class="n">return</span> <span class="p">(</span><span class="kt">MkHash</span> <span class="p">(</span><span class="n">init</span> <span class="n">result</span><span class="p">))</span>
    <span class="n">return</span> <span class="n">rev</span>
</pre></div>

<p>Here is the <code>safeRun</code> function, <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/app/Main.hs#L14">also in the src/app/Main.hs file</a>:</p>
<div class="highlight"><pre><span></span><span class="nf">safeRun</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="kt">String</span><span class="p">)</span>
<span class="nf">safeRun</span> <span class="n">command</span> <span class="n">arguments</span> <span class="ow">=</span>
  <span class="kr">do</span> <span class="c1">-- IO</span>
    <span class="n">output</span> <span class="ow">&lt;-</span> <span class="n">readProcessWithExitCode</span> <span class="n">command</span> <span class="n">arguments</span> <span class="s">&quot;&quot;</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">successOrNothing</span> <span class="n">output</span><span class="p">)</span>
</pre></div>

<p>Some relevant documentation for the <code>System.Process.readProcessWithExitCode</code> function:</p>
<div class="highlight"><pre><span></span><span class="nf">readProcessWithExitCode</span>
  <span class="ow">::</span> <span class="kt">FilePath</span>                         <span class="c1">-- Filename of the executable</span>
  <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>                         <span class="c1">-- any arguments</span>
  <span class="ow">-&gt;</span> <span class="kt">String</span>                           <span class="c1">-- standard input</span>
  <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="p">(</span><span class="kt">ExitCode</span><span class="p">,</span> <span class="kt">String</span><span class="p">,</span> <span class="kt">String</span><span class="p">)</span>    <span class="c1">-- exitcode, stdout, stderr</span>

<span class="c1">-- readProcessWithExitCode is like readProcess but with two differences:</span>
<span class="c1">-- * it returns the ExitCode of the process, and does not throw any exception if</span>
<span class="c1">--   the code is not ExitSuccess</span>
<span class="c1">-- * it reads and returns the output from process' standard error handle, rather</span>
<span class="c1">--   than the process inheriting the standard error handle.</span>
</pre></div>

<p>Some relevant documentation for the <code>System.Process.readProcess</code> function:</p>
<div class="highlight"><pre><span></span><span class="nf">readProcess</span>
  <span class="ow">::</span> <span class="kt">FilePath</span>     <span class="c1">-- Filename of the executable (see RawCommand for details)</span>
  <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>     <span class="c1">-- any arguments</span>
  <span class="ow">-&gt;</span> <span class="kt">String</span>       <span class="c1">-- standard input</span>
  <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">String</span>    <span class="c1">-- stdout</span>

<span class="c1">-- readProcess forks an external process, reads its standard output strictly,</span>
<span class="c1">-- blocking until the process terminates, and returns the output string. The</span>
<span class="c1">-- external process inherits the standard error.</span>
<span class="c1">--</span>
<span class="c1">-- If an asynchronous exception is thrown to the thread executing readProcess,</span>
<span class="c1">-- the forked process will be terminated and readProcess will wait (block) until</span>
<span class="c1">-- the process has been terminated.</span>
<span class="c1">--</span>
<span class="c1">-- Output is returned strictly, so this is not suitable for interactive</span>
<span class="c1">-- applications.</span>
</pre></div>

<p>Hence, the following code:</p>
<div class="highlight"><pre><span></span><span class="nf">gitrevparse</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="kt">Hash</span><span class="p">)</span>
<span class="nf">gitrevparse</span> <span class="ow">=</span> <span class="kr">do</span> <span class="c1">-- IO</span>
    <span class="n">mresult</span> <span class="ow">&lt;-</span> <span class="n">safeRun</span> <span class="s">&quot;git&quot;</span> <span class="p">[</span><span class="s">&quot;rev-parse&quot;</span><span class="p">,</span> <span class="s">&quot;--short&quot;</span><span class="p">,</span> <span class="s">&quot;HEAD&quot;</span><span class="p">]</span>
    <span class="c1">-- some code omitted</span>

<span class="nf">safeRun</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="kt">String</span><span class="p">)</span>
<span class="nf">safeRun</span> <span class="n">command</span> <span class="n">arguments</span> <span class="ow">=</span>
  <span class="kr">do</span> <span class="c1">-- IO</span>
    <span class="n">output</span> <span class="ow">&lt;-</span> <span class="n">readProcessWithExitCode</span> <span class="n">command</span> <span class="n">arguments</span> <span class="s">&quot;&quot;</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">successOrNothing</span> <span class="n">output</span><span class="p">)</span>
</pre></div>

<p>is equivalent to running <code>git rev-parse --short HEAD</code> on the command line while supplying the empty string as stdin, waits for it to finish, then send the <code>(ExitCode, stdout, stderr)</code> 3-tuple to the <code>successOrNothing</code> function, which is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/app/Main.hs#L10">also defined in the src/app/Main.hs file</a>:</p>
<div class="highlight"><pre><span></span><span class="nf">successOrNothing</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">ExitCode</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
<span class="nf">successOrNothing</span> <span class="p">(</span><span class="n">exitCode</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kr">if</span> <span class="n">exitCode</span> <span class="o">==</span> <span class="kt">ExitSuccess</span> <span class="kr">then</span> <span class="kt">Just</span> <span class="n">output</span> <span class="kr">else</span> <span class="kt">Nothing</span>
</pre></div>

<p><code>successOrNothing</code> is pretty straightforward; if our <code>git rev-parse --short HEAD</code> command exited successfully, then it will return the standard output string wrapped in a <code>Just</code>. Otherwise, it returns a <code>Nothing</code>.</p>
<p>Going back to the <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/app/Main.hs#L20">gitrevparse function</a>:</p>
<div class="highlight"><pre><span></span><span class="nf">gitrevparse</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="kt">Hash</span><span class="p">)</span>
<span class="nf">gitrevparse</span> <span class="ow">=</span> <span class="kr">do</span> <span class="c1">-- IO</span>
    <span class="n">mresult</span> <span class="ow">&lt;-</span> <span class="n">safeRun</span> <span class="s">&quot;git&quot;</span> <span class="p">[</span><span class="s">&quot;rev-parse&quot;</span><span class="p">,</span> <span class="s">&quot;--short&quot;</span><span class="p">,</span> <span class="s">&quot;HEAD&quot;</span><span class="p">]</span>
    <span class="kr">let</span> <span class="n">rev</span> <span class="ow">=</span> <span class="kr">do</span> <span class="c1">-- Maybe</span>
      <span class="n">result</span> <span class="ow">&lt;-</span> <span class="n">mresult</span>
      <span class="n">return</span> <span class="p">(</span><span class="kt">MkHash</span> <span class="p">(</span><span class="n">init</span> <span class="n">result</span><span class="p">))</span>
    <span class="n">return</span> <span class="n">rev</span>
</pre></div>

<p>we see the use of the Maybe monad. If <code>git rev-parse --short HEAD</code> ran successfully, then <code>mresult</code> will be a <code>Just String</code>. The <code>result &lt;- mresult</code> will then extract the standard output string, and <code>init result</code> will return everything except the last character, which in this case is a newline. If you run <code>git rev-parse --short HEAD</code> in a git repo, its standard output will be a short git commit SHA1 similar to <code>055f126c</code> and ending with a newline. This git commit SHA1 is then passed to the <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/Utils.hs#L9">MkHash data constructor</a>:</p>
<div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">Hash</span> <span class="ow">=</span> <span class="kt">MkHash</span> <span class="p">{</span><span class="n">getHash</span> <span class="ow">::</span> <span class="kt">String</span><span class="p">}</span>
</pre></div>

<p>which turns out to be a newtype wrapper. The <code>return</code> then wraps the whole thing in a <code>Just</code> again.</p>
<p>To summarize what the <code>gitrevparse</code> function does:</p>
<ul>
<li>It runs <code>git rev-parse --short HEAD</code> and if successful, returns a <code>Just (MkHash s)</code> where <code>s</code> is a <code>String</code> wrapped in a <code>Hash</code> newtype that represents the git commit SHA1 that the HEAD is on</li>
<li>If <code>git rev-parse --short HEAD</code> fails, then a <code>Nothing</code> is returned.</li>
</ul>
<p>Let us revisit the main function again:</p>
<div class="highlight"><pre><span></span><span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> <span class="c1">-- IO</span>
  <span class="n">status</span> <span class="ow">&lt;-</span> <span class="n">getContents</span>
  <span class="n">mhash</span> <span class="ow">&lt;-</span> <span class="n">unsafeInterleaveIO</span> <span class="n">gitrevparse</span> <span class="c1">-- defer the execution until we know we need the hash</span>
  <span class="kr">let</span> <span class="n">result</span> <span class="ow">=</span> <span class="kr">do</span> <span class="c1">-- Maybe</span>
    <span class="n">strings</span> <span class="ow">&lt;-</span> <span class="n">stringsFromStatus</span> <span class="n">mhash</span> <span class="n">status</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">unwords</span> <span class="n">strings</span><span class="p">)</span>
  <span class="n">putStr</span> <span class="p">(</span><span class="n">fromMaybe</span> <span class="s">&quot;&quot;</span> <span class="n">result</span><span class="p">)</span>
</pre></div>

<p>Tying all that we know so far, we may or may not need the output of <code>git rev-parse --short HEAD</code>, hence the use of <code>unsafeInterleaveIO</code> to defer the computation. This deferred <code>IO (Maybe Hash)</code> action, along with <code>status</code> (which contains the output of <code>git status --porcelain --branch &amp;&gt;/dev/null</code>) are passed to the <code>stringsFromStatus</code> function, which seems to be doing the bulk of the work. We know this because a Hoogle search shows the following docs for <code>unwords</code> and <code>fromMaybe</code>:</p>
<div class="highlight"><pre><span></span><span class="nf">unwords</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="c1">-- unwords is an inverse operation to words. It joins words with separating</span>
<span class="c1">-- spaces.</span>

<span class="nf">fromMaybe</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="c1">-- The fromMaybe function takes a default value and a Maybe value. If the Maybe</span>
<span class="c1">-- is a Nothing, it returns the default value; otherwise it returns the value</span>
<span class="c1">-- contained in the Maybe.</span>
</pre></div>

<p>So we pretty much covered the main function. Let’s get to the <code>stringsFromStatus</code> function next.</p>
<h2 id="the-stringsfromstatus-function">The <code>stringsFromStatus</code> function</h2>
<p>We can find the <code>stringsFromStatus</code> function in <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/Utils.hs#L64">src/src/Utils.hs</a>:</p>
<div class="highlight"><pre><span></span><span class="nf">stringsFromStatus</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Hash</span>
                  <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="c1">-- status</span>
                  <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
<span class="nf">stringsFromStatus</span> <span class="n">h</span> <span class="n">status</span> <span class="ow">=</span> <span class="kr">do</span> <span class="c1">-- List</span>
    <span class="n">processed</span> <span class="ow">&lt;-</span> <span class="n">processGitStatus</span> <span class="p">(</span><span class="n">lines</span> <span class="n">status</span><span class="p">)</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">showGitInfo</span> <span class="n">h</span> <span class="n">processed</span><span class="p">)</span>
</pre></div>

<p>The comment on line 67 is a mistake; this function lives inside the <code>Maybe</code> monad, not the <code>List</code> monad. Anyways. Here is some relevant documentation for <code>lines</code>:</p>
<div class="highlight"><pre><span></span><span class="nf">lines</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
<span class="c1">-- lines breaks a string up into a list of strings at newline characters. The</span>
<span class="c1">-- resulting strings do not contain newlines.</span>
<span class="c1">-- Note that after splitting the string at newline characters, the last part of</span>
<span class="c1">-- the string is considered a line even if it doesn't end with a newline.</span>
</pre></div>

<p>So <code>lines status</code> will break the output of <code>git status --porcelain --branch</code>, which can consist of multiple lines, into a list of <code>String</code>, with each element in the list being one line in the original string. This list of strings is then passed to <code>processGitStatus</code>, <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/Utils.hs#L21">defined as follows</a>:</p>
<div class="highlight"><pre><span></span><span class="nf">processGitStatus</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">GitInfo</span>
<span class="nf">processGitStatus</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">Nothing</span>
<span class="nf">processGitStatus</span> <span class="p">(</span><span class="n">branchLine</span><span class="kt">:</span><span class="n">statusLines</span><span class="p">)</span> <span class="ow">=</span>
    <span class="kr">do</span> <span class="c1">-- Maybe</span>
      <span class="n">mbranch</span> <span class="ow">&lt;-</span> <span class="n">processBranch</span> <span class="n">branchLine</span>
      <span class="n">status</span> <span class="ow">&lt;-</span> <span class="n">processStatus</span> <span class="n">statusLines</span>
      <span class="n">return</span> <span class="p">(</span><span class="kt">MkGitInfo</span> <span class="n">mbranch</span> <span class="n">status</span><span class="p">)</span>
</pre></div>

<p>As its name suggests, <code>processGitStatus</code> handles output from <code>git status</code>. Specifically, <code>git status --porcelain --branch &amp;&gt;/dev/null</code>.</p>
<p>We will deal with the easy case first, where <code>processGitStatus</code> pattern matches its first argument against the empty list. In this case, a <code>Nothing</code> is returned. This case happens when <code>git status --porcelain --branch &amp;&gt;/dev/null</code> does not print anything to standard output, which occurs when we are not in a git repo. (Verify it!)</p>
<p>The other pattern match will lead us deeper into the code. It is a pattern match against a non-empty list. For this pattern match, we see that the author once again uses the <code>do</code> notation and we are inside the <code>Maybe</code> monad. First, the head of the list is bound to <code>branchLine</code> and passed to the <code>processBranch</code> function, which also lives inside the <code>Maybe</code> monad.</p>
<p>To understand the motivation behind this code, we have to know what the <code>git status --porcelain --branch</code> command is outputting. Here is the <a href="https://git-scm.com/docs/git-status/2.15.0#git-status---porcelainltversiongt">documentation for the <code>--porcelain</code> flag from the git status 2.15.0 manpage</a>:</p>
<blockquote>
<p>–porcelain[=&lt;version&gt;]</p>
<p>  Give the output in an easy-to-parse format for scripts. This is similar to the short output, but will remain stable across Git versions and regardless of user configuration. See below for details.</p>
<p>  The version parameter is used to specify the format version. This is optional and defaults to the original version v1 format.</p>
</blockquote>
<p>and <a href="https://git-scm.com/docs/git-status/2.15.0#git-status--b">documentation for the <code>--branch</code> flag</a>:</p>
<blockquote>
<p>-b</p>
<p>--branch</p>
<p>  Show the branch and tracking info even in short-format.</p>
</blockquote>
<p>and the final part of the <a href="https://git-scm.com/docs/git-status/2.15.0#_short_format">docs explaining the short-format output</a>:</p>
<blockquote>
<p>If -b is used the short-format status is preceded by a line</p>
<p>  ## branchname tracking info</p>
</blockquote>
<p>Armed with this information, we know that <code>git status --porcelain --branch</code>:</p>
<ul>
<li>is a form of git status whose output is easy to parse for scripts and is similar to the short-format output</li>
<li>uses the porcelain v1 format</li>
<li>will show the branch and tracking info as the first line. This line looks similar to <code>&quot;  ## branchname tracking info&quot;</code> and is precisely what the <code>processGitStatus</code> function passes to the <code>processBranch</code> function</li>
</ul>
<p>The <code>processBranch</code> function is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/Utils.hs#L18">defined in the same file</a>:</p>
<div class="highlight"><pre><span></span><span class="nf">processBranch</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">MBranchInfo</span>
<span class="nf">processBranch</span> <span class="ow">=</span> <span class="n">rightOrNothing</span> <span class="o">.</span> <span class="n">branchInfo</span>
</pre></div>

<p>From <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/Utils.hs#L4">line 4 of the same file</a>:</p>
<div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">BranchParse</span> <span class="p">(</span><span class="kt">Branch</span><span class="p">(</span><span class="kt">MkBranch</span><span class="p">),</span> <span class="kt">MBranchInfo</span><span class="p">,</span> <span class="kt">BranchInfo</span><span class="p">(</span><span class="kt">MkBranchInfo</span><span class="p">),</span> <span class="nf">branchInfo</span><span class="p">,</span> <span class="nf">getDistance</span><span class="p">,</span> <span class="nf">pairFromDistance</span><span class="p">,</span> <span class="kt">Remote</span><span class="p">)</span>
</pre></div>

<p>we see that both the <code>MBranchInfo</code> type and the <code>branchInfo</code> function are defined in <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs">src/src/BranchParse.hs</a>. That is where we shall go to next.</p>
<h2 id="the-branchinfo-function">The <code>branchInfo</code> function</h2>
<p>The <code>branchInfo</code> function is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L150">defined at line 150 of src/src/BranchParse.hs</a>:</p>
<div class="highlight"><pre><span></span><span class="nf">branchInfo</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">ParseError</span> <span class="kt">MBranchInfo</span>
<span class="nf">branchInfo</span> <span class="ow">=</span> <span class="n">parse</span> <span class="n">branchParser'</span> <span class="s">&quot;&quot;</span>
</pre></div>

<p>The <code>parse</code> function is from the <a href="https://hackage.haskell.org/package/parsec">Parsec library</a>. I am not the best guy to explain what Parsec does even though I know how to use it, but a simple explanation is, Parsec allows one to write parsers that look and work very much the same way as <a href="https://en.wikipedia.org/wiki/Context-free_grammar">Context Free Grammars</a>. Since Context Free Languages are a superset of Regular Languages, by extension, one can use Parsec to write Regular Expressions as well (even though they will look like CFGs) - do note that regexes in many languages are not truly regular and I am not certain how much of these non-regular features Parsec provides.</p>
<p>The docs for <code>parse</code> are slightly… difficult. But we will be needing its type signature, so here goes:</p>
<div class="highlight"><pre><span></span><span class="nf">parse</span> <span class="ow">::</span> <span class="kt">Stream</span> <span class="n">s</span> <span class="kt">Identity</span> <span class="n">t</span> <span class="ow">=&gt;</span> <span class="kt">Parsec</span> <span class="n">s</span> <span class="nb">()</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">SourceName</span> <span class="ow">-&gt;</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">ParseError</span> <span class="n">a</span>
</pre></div>

<p>The simpler way to explain it is, it takes in a <code>Parsec</code> “object” which is the parser, followed by a <code>String</code> (actually a type synonym named <code>SourceName</code> that is equivalent to <code>String</code>; usually I just use the empty string), followed by a <code>String</code> / <code>Text</code> / similar (in this case a <code>String</code>) containing the content we want to parse using the parser given in the first argument. Note that currying is used here because only 2 arguments were given to <code>parse</code> when it needs 3; that is reflected in the type signature of <code>branchInfo</code>, because it returns a function that takes in a <code>String</code> argument.</p>
<p>On success, <code>parse</code> returns a <code>Right a</code>. Based on the type signature of <code>branchInfo</code>, this <code>a</code> is an <code>MBranchInfo</code> - that is defined in the same file. On failure, <code>parse</code> returns a <code>Left ParseError</code>; a <code>ParseError</code> is a data type defined in the Parsec library that represents, well, a parse error.</p>
<p>Before we get into <code>branchParser'</code>, recall how we got here. We were in the <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/Utils.hs#L23">second half of processGitStatus</a>:</p>
<div class="highlight"><pre><span></span><span class="nf">processGitStatus</span> <span class="p">(</span><span class="n">branchLine</span><span class="kt">:</span><span class="n">statusLines</span><span class="p">)</span> <span class="ow">=</span>
    <span class="kr">do</span> <span class="c1">-- Maybe</span>
      <span class="n">mbranch</span> <span class="ow">&lt;-</span> <span class="n">processBranch</span> <span class="n">branchLine</span>
</pre></div>

<p>where we were handed the first line in the output of <code>git status --porcelain --branch</code>, which is bound to <code>branchLine</code>.</p>
<div class="highlight"><pre><span></span><span class="nf">processBranch</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">MBranchInfo</span>
<span class="nf">processBranch</span> <span class="ow">=</span> <span class="n">rightOrNothing</span> <span class="o">.</span> <span class="n">branchInfo</span>
</pre></div>

<p>And <code>processBranch</code> calls <code>branchInfo</code> and hands <code>branchLine</code> to it. Which <code>branchInfo</code> will now attempt to parse using the <code>branchParser'</code> parser.</p>
<h2 id="parsing-the-branch-line">Parsing the branch line</h2>
<p><code>branchParser'</code> is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L122">defined in src/src/Branchparse.hs</a>:</p>
<div class="highlight"><pre><span></span><span class="nf">branchParser'</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">MBranchInfo</span>
<span class="nf">branchParser'</span> <span class="ow">=</span>
  <span class="kr">do</span> <span class="c1">-- Parsec</span>
    <span class="n">string</span> <span class="s">&quot;## &quot;</span>
    <span class="n">branchParser</span>
</pre></div>

<p><code>Parser</code> is a type synonym for <code>Parsec String ()</code> and is defined in <code>Text.Parsec.String</code> of the Parsec library. <code>MBranchInfo</code> is a type synonym for <code>Maybe BranchInfo</code> and is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L63">defined on line 63 of src/src/BranchParse.hs</a>. <code>BranchInfo</code> is a type constructor <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L61">defined on line 61 of src/src/BranchParse.hs</a>. Hence, <code>Parser MBranchInfo</code> expands to <code>Parsec String () (Maybe BranchInfo)</code>. What this means is, if there are no parsing errors, we get a <code>Maybe BranchInfo</code>. (Not exactly but we’ll get to that later).</p>
<p>The <code>string</code> function is from the Parsec library. It literally looks for the string supplied to it in the content it is supposed to parse. In this case, it looks for the <code>##</code> string (there is a trailing space but it doesn’t show up in the HTML here) in the first line of <code>git status --porcelain --branch</code>. If that line starts with the given string, we move on to the next parser ,<code>branchParser</code>. Otherwise, a <code>ParseError</code> results and parsing stops.</p>
<p>Note that the <code>branchParser'</code> code uses <code>do</code> notation (once again) but this time we are in the <code>Parser</code> or equivalently <code>Parsec String ()</code> monad.</p>
<p>Here is the <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L114">definition of branchParser</a>:</p>
<div class="highlight"><pre><span></span><span class="nf">branchParser</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">MBranchInfo</span>
<span class="nf">branchParser</span> <span class="ow">=</span>
      <span class="n">try</span> <span class="n">noBranch</span>
    <span class="o">&lt;|&gt;</span> <span class="n">try</span> <span class="n">newRepo</span>
    <span class="o">&lt;|&gt;</span> <span class="n">try</span> <span class="n">branchRemoteTracking</span>
    <span class="o">&lt;|&gt;</span> <span class="n">try</span> <span class="n">branchRemote</span>
    <span class="o">&lt;|&gt;</span> <span class="n">branchOnly</span>
</pre></div>

<p>This consumes the remaining of the line after the <code>##</code> (with a trailing space). <code>try</code> and <code>&lt;|&gt;</code> are both defined in the Parsec library and they are often used together. The documentation for <code>&lt;|&gt;</code> is especially good:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="o">&lt;|&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">ParsecT</span> <span class="n">s</span> <span class="n">u</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ParsecT</span> <span class="n">s</span> <span class="n">u</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ParsecT</span> <span class="n">s</span> <span class="n">u</span> <span class="n">m</span> <span class="n">a</span>
<span class="c1">-- This combinator implements choice. The parser p &lt;|&gt; q first applies p. If it</span>
<span class="c1">-- succeeds, the value of p is returned. If p fails without consuming any input,</span>
<span class="c1">-- parser q is tried. This combinator is defined equal to the mplus member of</span>
<span class="c1">-- the MonadPlus class and the (&lt;|&gt;) member of Alternative.</span>
</pre></div>

<p>The initial part of the documentation for the <code>try</code> function is pretty good too:</p>
<div class="highlight"><pre><span></span><span class="nf">try</span> <span class="ow">::</span> <span class="kt">ParsecT</span> <span class="n">s</span> <span class="n">u</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ParsecT</span> <span class="n">s</span> <span class="n">u</span> <span class="n">m</span> <span class="n">a</span>
<span class="c1">-- The parser try p behaves like parser p, except that it pretends that it</span>
<span class="c1">-- hasn't consumed any input when an error occurs.</span>
<span class="c1">--</span>
<span class="c1">-- This combinator is used whenever arbitrary look ahead is needed. Since it</span>
<span class="c1">-- pretends that it hasn't consumed any input when p fails, the (&lt;|&gt;) combinator</span>
<span class="c1">-- will try its second alternative even when the first parser failed while</span>
<span class="c1">-- consuming input.</span>
</pre></div>

<p>Essentially, <code>branchParser</code> will first attempt to parse the input string using the <code>try noBranch</code> parser, then if that fails, the <code>try</code> will ensure that no input is consumed by <code>noBranch</code> - and because no input is consumed, the <code>&lt;|&gt;</code> will then move on to the next parser, which is <code>try newRepo</code>. And if that fails, no input will be consumed, and it moves on to <code>try branchRemoteTracking</code>, and so on, in the specified order. If there is any successful parse, the parsing halts. People with knowledge of CFGs will appreciate how this code looks.</p>
<p>To understand each of these parsers, we need to play around with some git repositories and observe the output of the <code>git status --porcelain --branch</code> command. In this process, we will also be learning more about Parsec.</p>
<h3 id="the-nobranch-parser">The <code>noBranch</code> parser</h3>
<p>First off the list, the <code>noBranch</code> parser (<a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L71">defined here</a>):</p>
<div class="highlight"><pre><span></span><span class="nf">noBranch</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">MBranchInfo</span>
<span class="nf">noBranch</span> <span class="ow">=</span>
  <span class="kr">do</span> <span class="c1">-- Parsec</span>
    <span class="n">manyTill</span> <span class="n">anyChar</span> <span class="p">(</span><span class="n">try</span> <span class="p">(</span><span class="n">string</span> <span class="s">&quot; (no branch)&quot;</span><span class="p">))</span>
    <span class="n">eof</span>
    <span class="n">return</span> <span class="kt">Nothing</span>
</pre></div>

<p>The <code>manyTill</code>, <code>anyChar</code> and <code>eof</code> parsers are new to us. They are defined in the Parsec library and pretty much do what they say.</p>
<div class="highlight"><pre><span></span><span class="nf">manyTill</span> <span class="ow">::</span> <span class="kt">Stream</span> <span class="n">s</span> <span class="n">m</span> <span class="n">t</span> <span class="ow">=&gt;</span> <span class="kt">ParsecT</span> <span class="n">s</span> <span class="n">u</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ParsecT</span> <span class="n">s</span> <span class="n">u</span> <span class="n">m</span> <span class="n">end</span> <span class="ow">-&gt;</span> <span class="kt">ParsecT</span> <span class="n">s</span> <span class="n">u</span> <span class="n">m</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="c1">-- manyTill p end applies parser p zero or more times until parser end succeeds.</span>
<span class="c1">-- Returns the list of values returned by p.</span>

<span class="nf">anyChar</span> <span class="ow">::</span> <span class="kt">Stream</span> <span class="n">s</span> <span class="n">m</span> <span class="kt">Char</span> <span class="ow">=&gt;</span> <span class="kt">ParsecT</span> <span class="n">s</span> <span class="n">u</span> <span class="n">m</span> <span class="kt">Char</span>
<span class="c1">-- This parser succeeds for any character. Returns the parsed character.</span>

<span class="nf">eof</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Stream</span> <span class="n">s</span> <span class="n">m</span> <span class="n">t</span><span class="p">,</span> <span class="kt">Show</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">ParsecT</span> <span class="n">s</span> <span class="n">u</span> <span class="n">m</span> <span class="nb">()</span>
<span class="c1">-- This parser only succeeds at the end of the input. This is not a primitive</span>
<span class="c1">-- but it is defined using notFollowedBy.</span>
</pre></div>

<p>So <code>manyTill anyChar (try (string &quot; (no branch)&quot;))</code> will apply the <code>anyChar</code> parser zero or more times until the <code>try (string &quot; (no branch)&quot;)</code> parser succeeds. On success, it returns a list of all the <code>Char</code> consumed by <code>anyChar</code>. We know that the <code>string &quot; (no branch)&quot;</code> parser expects and consumes the string <code>&quot; (no branch)&quot;</code>; wrapping it in a <code>try</code> allows us to avoid a parse error while it is used in conjunction with <code>manyTill anyChar</code>, as more and more characters are consumed by repeated applications of <code>anyChar</code> until we finally encounter the string <code>&quot; (no branch)&quot;</code>. Then the <code>manyTill anyChar (try (string &quot; (no branch)&quot;))</code> parser succeeds.</p>
<p>The <code>eof</code> parser then expects us to have reached the end of the input. Or in this case, the end of the first line of the output of <code>git status --porcelain --branch</code>. If everything goes well, a <code>Parser Nothing</code> is returned.</p>
<p>To put this in simpler terms, <code>noBranch</code> is expecting a single line that looks like <code>abcdefgh ijklm nopqrs (no branch)</code>. Notice how the list of characters accumulated by <code>manyTill anyChar</code> are discarded.</p>
<p>We can probably guess that <code>noBranch</code> is meant for parsing a branch line for a git repo that isn’t on a branch. This happens in the detached HEAD state. To see what the line looks like, simply go to any of your git repos with at least 2 commits, make sure you have committed / stashed all your changes, then run the following commands:</p>
<div class="highlight"><pre><span></span>git checkout -b HEAD~
git status --porcelain --branch
</pre></div>

<p>The first line should look similar to the following:</p>
<div class="highlight"><pre><span></span>## HEAD (no branch)
</pre></div>

<p>and this will be happily parsed by <code>branchParser'</code> first with <code>string &quot;## &quot;</code> followed by <code>branchParser</code> using the <code>try noBranch</code> parser, returning a <code>Parser Nothing</code>. So now we know that if <code>branchParser'</code> returns a <code>Parser Nothing</code>, then the git repo is in the detached HEAD state. Nice.</p>
<h3 id="the-newrepo-parser">The <code>newRepo</code> parser</h3>
<p>The <code>try newRepo</code> parser will be used by <code>branchParser</code> if parsing using <code>try noBranch</code> fails.</p>
<div class="highlight"><pre><span></span><span class="nf">branchParser</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">MBranchInfo</span>
<span class="nf">branchParser</span> <span class="ow">=</span>
      <span class="n">try</span> <span class="n">noBranch</span>
    <span class="o">&lt;|&gt;</span> <span class="n">try</span> <span class="n">newRepo</span>
    <span class="o">&lt;|&gt;</span> <span class="n">try</span> <span class="n">branchRemoteTracking</span>
    <span class="o">&lt;|&gt;</span> <span class="n">try</span> <span class="n">branchRemote</span>
    <span class="o">&lt;|&gt;</span> <span class="n">branchOnly</span>
</pre></div>

<p><a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L65">Its definition</a> is as follows:</p>
<div class="highlight"><pre><span></span><span class="nf">newRepo</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">MBranchInfo</span>
<span class="nf">newRepo</span> <span class="ow">=</span>
  <span class="kr">do</span> <span class="c1">-- Parsec</span>
    <span class="n">string</span> <span class="s">&quot;Initial commit on &quot;</span>
    <span class="n">branchOnly</span>
</pre></div>

<p>Based on the <code>string &quot;Initial commit on &quot;</code> parser alone, we can safely assume that this is for a new git repo. By now, we are quite familiar with what <code>string</code> does, so let’s look at the <code>branchOnly</code> parser, <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L106">defined here</a>:</p>
<div class="highlight"><pre><span></span><span class="nf">branchOnly</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">MBranchInfo</span>
<span class="nf">branchOnly</span> <span class="ow">=</span>
  <span class="kr">do</span> <span class="c1">-- Parsec</span>
    <span class="n">branch</span> <span class="ow">&lt;-</span> <span class="n">many</span> <span class="p">(</span><span class="n">noneOf</span> <span class="s">&quot; &quot;</span><span class="p">)</span>
    <span class="n">eof</span>
    <span class="kr">let</span> <span class="n">bi</span> <span class="ow">=</span> <span class="kt">MkBranchInfo</span> <span class="p">(</span><span class="kt">MkBranch</span> <span class="n">branch</span><span class="p">)</span> <span class="kt">Nothing</span>
    <span class="n">return</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">bi</span><span class="p">)</span>
</pre></div>

<p>Documentation for the <code>noneOf</code> parser combinator:</p>
<div class="highlight"><pre><span></span><span class="nf">noneOf</span> <span class="ow">::</span> <span class="kt">Stream</span> <span class="n">s</span> <span class="n">m</span> <span class="kt">Char</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">ParsecT</span> <span class="n">s</span> <span class="n">u</span> <span class="n">m</span> <span class="kt">Char</span>
<span class="c1">-- As the dual of oneOf, noneOf cs succeeds if the current is character not in</span>
<span class="c1">-- the supplied list of characters cs. Returns the parsed character.</span>

<span class="c1">-- Example code:</span>
    <span class="n">consonant</span> <span class="ow">=</span> <span class="n">noneOf</span> <span class="s">&quot;aeiou&quot;</span>
</pre></div>

<p>When used with <code>many</code>, this will consume as many characters as possible, as long as they are not the space character, and return the list of characters consumed. Notice that this time, the author binds the list of characters consumed by <code>many (noneOf &quot; &quot;)</code> to <code>branch</code>. Immediately following that, an <code>eof</code> is expected. Therefore, <code>branchOnly</code> expects the input to consist of only non space characters.</p>
<p>I was expecting <code>newRepo</code> to handle the first line of <code>git status --porcelain --branch</code> for new git repositories but that was not the case. On git 2.15.0 for a new repo initialized using <code>git init</code> but with zero commits, I am getting the following output:</p>
<div class="highlight"><pre><span></span>## No commits yet on master
</pre></div>

<p>That is in the Porcelain v1 output format, which zsh-git-prompt expects. Porcelain v2 is in a different format and is not supported by zsh-git-prompt. I do not see anything on my zsh prompt that indicates this new directory I ran <code>git init</code> in is a git repo. Since this doesn’t work for a git repo that was just created using <code>git init</code> and has zero commits, I added the initial commit and ran <code>git status --porcelain --branch</code> again and… it wasn’t what we are expecting but is instead <code>## master</code>. Changing the commit message to <code>Initial commit</code> and similar does not change anything too.</p>
<p>The only explanation I can come up with is this: perhaps the <code>git status</code> Porcelain format changed since the last version of zsh-git-prompt? After all, at this time of writing, the most recent commit was on 15 Feb 2016 and for v0.5, which is what we are studying right now.</p>
<p>Regardless, let’s go back to <code>branchOnly</code> and go through the final 2 lines:</p>
<div class="highlight"><pre><span></span>    <span class="kr">let</span> <span class="n">bi</span> <span class="ow">=</span> <span class="kt">MkBranchInfo</span> <span class="p">(</span><span class="kt">MkBranch</span> <span class="n">branch</span><span class="p">)</span> <span class="kt">Nothing</span>
    <span class="n">return</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">bi</span><span class="p">)</span>
</pre></div>

<p><code>MkBranch</code> is a newtype wrapper <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L38">defined at line 38 of src/src/BranchParse.hs</a>:</p>
<div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">Branch</span> <span class="ow">=</span> <span class="kt">MkBranch</span> <span class="kt">String</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">)</span>
</pre></div>

<p>while <code>MkBranchInfo</code> is a data constructor <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L61">defined at line 61 of the same file</a>:</p>
<div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">BranchInfo</span> <span class="ow">=</span> <span class="kt">MkBranchInfo</span> <span class="kt">Branch</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="kt">Remote</span><span class="p">)</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</pre></div>

<p>We can see that <code>Branch</code> just wraps a <code>String</code> that is a git branch name. <code>BranchInfo</code> has the one <code>MkBranchInfo</code> data constructor which takes in 2 arguments: a <code>Branch</code> and a <code>Maybe Remote</code>. We shall not cover the <code>Remote</code> type for now. Essentially, this code:</p>
<div class="highlight"><pre><span></span>    <span class="kr">let</span> <span class="n">bi</span> <span class="ow">=</span> <span class="kt">MkBranchInfo</span> <span class="p">(</span><span class="kt">MkBranch</span> <span class="n">branch</span><span class="p">)</span> <span class="kt">Nothing</span>
    <span class="n">return</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">bi</span><span class="p">)</span>
</pre></div>

<p>Creates a representation for a git branch with a <code>Nothing</code> for the <code>Maybe Remote</code> part, then returns a <code>Just BranchInfo</code> if the parsing succeeds.</p>
<p>Putting everything together:</p>
<div class="highlight"><pre><span></span><span class="nf">newRepo</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">MBranchInfo</span>
<span class="nf">newRepo</span> <span class="ow">=</span>
  <span class="kr">do</span> <span class="c1">-- Parsec</span>
    <span class="n">string</span> <span class="s">&quot;Initial commit on &quot;</span>
    <span class="n">branchOnly</span>

<span class="nf">branchOnly</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">MBranchInfo</span>
<span class="nf">branchOnly</span> <span class="ow">=</span>
  <span class="kr">do</span> <span class="c1">-- Parsec</span>
    <span class="n">branch</span> <span class="ow">&lt;-</span> <span class="n">many</span> <span class="p">(</span><span class="n">noneOf</span> <span class="s">&quot; &quot;</span><span class="p">)</span>
    <span class="n">eof</span>
    <span class="kr">let</span> <span class="n">bi</span> <span class="ow">=</span> <span class="kt">MkBranchInfo</span> <span class="p">(</span><span class="kt">MkBranch</span> <span class="n">branch</span><span class="p">)</span> <span class="kt">Nothing</span>
    <span class="n">return</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">bi</span><span class="p">)</span>
</pre></div>

<p>We see that the <code>newRepo</code> parser expects a string similar to:</p>
<div class="highlight"><pre><span></span>Initial commit on some-branch-name
</pre></div>

<p>and on a successful parse, returns a <code>Just BranchInfo</code> which represents a git branch.</p>
<h3 id="the-branchremotetracking-parser">The <code>branchRemoteTracking</code> parser</h3>
<p>If both <code>try noBranch</code> and <code>try newRepo</code> fail, then <code>branchParser</code> tries the <code>try branchRemoteTracking</code> parser.</p>
<div class="highlight"><pre><span></span><span class="nf">branchParser</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">MBranchInfo</span>
<span class="nf">branchParser</span> <span class="ow">=</span>
      <span class="n">try</span> <span class="n">noBranch</span>
    <span class="o">&lt;|&gt;</span> <span class="n">try</span> <span class="n">newRepo</span>
    <span class="o">&lt;|&gt;</span> <span class="n">try</span> <span class="n">branchRemoteTracking</span>
    <span class="o">&lt;|&gt;</span> <span class="n">try</span> <span class="n">branchRemote</span>
    <span class="o">&lt;|&gt;</span> <span class="n">branchOnly</span>
</pre></div>

<p>The <code>branchRemoteTracking</code> parser is the most complicated of the bunch, at line 84 of <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L84">src/src/BranchParse.hs</a>:</p>
<div class="highlight"><pre><span></span><span class="nf">branchRemoteTracking</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">MBranchInfo</span>
<span class="nf">branchRemoteTracking</span> <span class="ow">=</span>
  <span class="kr">do</span> <span class="c1">-- Parsec</span>
    <span class="n">branch</span> <span class="ow">&lt;-</span> <span class="n">trackedBranch</span>
    <span class="n">tracking</span> <span class="ow">&lt;-</span> <span class="n">many</span> <span class="p">(</span><span class="n">noneOf</span> <span class="s">&quot; &quot;</span><span class="p">)</span>
    <span class="n">char</span> <span class="sc">' '</span>
    <span class="n">behead</span> <span class="ow">&lt;-</span> <span class="n">inBrackets</span>
    <span class="kr">let</span> <span class="n">remote</span> <span class="ow">=</span> <span class="kt">MkRemote</span> <span class="p">(</span><span class="kt">MkBranch</span> <span class="n">tracking</span><span class="p">)</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">behead</span><span class="p">)</span>
    <span class="kr">let</span> <span class="n">bi</span> <span class="ow">=</span> <span class="kt">MkBranchInfo</span> <span class="n">branch</span>  <span class="p">(</span><span class="kt">Just</span> <span class="n">remote</span><span class="p">)</span>
    <span class="n">return</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">bi</span><span class="p">)</span>
</pre></div>

<p>Definition of <code>trackedBranch</code>:</p>
<div class="highlight"><pre><span></span><span class="nf">trackedBranch</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">Branch</span>
<span class="nf">trackedBranch</span> <span class="ow">=</span>
    <span class="kr">do</span> <span class="c1">-- Parsec</span>
      <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">manyTill</span> <span class="n">anyChar</span> <span class="p">(</span><span class="n">try</span> <span class="p">(</span><span class="n">string</span> <span class="s">&quot;...&quot;</span><span class="p">))</span>
      <span class="n">return</span> <span class="p">(</span><span class="kt">MkBranch</span> <span class="n">b</span><span class="p">)</span>
</pre></div>

<p>Our experience with Parsec tells us that <code>trackedBranch</code> will consume as many characters as possible until it hits the string <code>...</code>. The list of characters consumed is bound to <code>b</code> and then wrapped in the <code>MkBranch</code> newtype wrapper and returned.</p>
<p>Following that (still in <code>branchRemoteTracking</code>), <code>tracking &lt;- many (noneOf &quot; &quot;)</code> will consume as many characters as possible until it hits the space character. The list of characters consumed is bound to <code>tracking</code>. Subsequently, <code>char ' '</code> expects a single space character and consumes and discards it.</p>
<p><code>inBrackets</code> is defined as follows, <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L128">on line 128</a>:</p>
<div class="highlight"><pre><span></span><span class="nf">inBrackets</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">Distance</span>
<span class="nf">inBrackets</span> <span class="ow">=</span> <span class="n">between</span> <span class="p">(</span><span class="n">char</span> <span class="sc">'['</span><span class="p">)</span> <span class="p">(</span><span class="n">char</span> <span class="sc">']'</span><span class="p">)</span> <span class="p">(</span><span class="n">behind</span> <span class="o">&lt;|&gt;</span> <span class="n">try</span> <span class="n">aheadBehind</span> <span class="o">&lt;|&gt;</span> <span class="n">ahead</span><span class="p">)</span>
</pre></div>

<p>The <code>Distance</code> type constructor is defined at <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L21">line 21</a>, but I will be showing the comments from <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L11">lines 11 to 19</a> as well because they pretty much describe what we will be covering next:</p>
<div class="highlight"><pre><span></span><span class="cm">{-</span>
<span class="cm"> The idea is to parse the first line of the git status command.</span>
<span class="cm"> Such a line may look like:</span>
<span class="cm">  ## master</span>
<span class="cm">or</span>
<span class="cm">  ## master...origin/master</span>
<span class="cm">or</span>
<span class="cm">  ## master...origin/master [ahead 3, behind 4]</span>
<span class="cm"> -}</span>

<span class="kr">data</span> <span class="kt">Distance</span> <span class="ow">=</span> <span class="kt">Ahead</span> <span class="kt">Int</span> <span class="o">|</span> <span class="kt">Behind</span> <span class="kt">Int</span> <span class="o">|</span> <span class="kt">AheadBehind</span> <span class="kt">Int</span> <span class="kt">Int</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">)</span>
</pre></div>

<p>So <code>Distance</code> represents how many commits the current branch is ahead and/or behind its remote tracking branch; its data constructors are all aptly named.</p>
<p>Going back to <code>inBrackets</code>:</p>
<div class="highlight"><pre><span></span><span class="nf">inBrackets</span> <span class="ow">=</span> <span class="n">between</span> <span class="p">(</span><span class="n">char</span> <span class="sc">'['</span><span class="p">)</span> <span class="p">(</span><span class="n">char</span> <span class="sc">']'</span><span class="p">)</span> <span class="p">(</span><span class="n">behind</span> <span class="o">&lt;|&gt;</span> <span class="n">try</span> <span class="n">aheadBehind</span> <span class="o">&lt;|&gt;</span> <span class="n">ahead</span><span class="p">)</span>
</pre></div>

<p><code>between</code> is a function defined in the Parsec library. Documentation as follows:</p>
<div class="highlight"><pre><span></span><span class="nf">between</span> <span class="ow">::</span> <span class="kt">Stream</span> <span class="n">s</span> <span class="n">m</span> <span class="n">t</span> <span class="ow">=&gt;</span> <span class="kt">ParsecT</span> <span class="n">s</span> <span class="n">u</span> <span class="n">m</span> <span class="n">open</span> <span class="ow">-&gt;</span> <span class="kt">ParsecT</span> <span class="n">s</span> <span class="n">u</span> <span class="n">m</span> <span class="n">close</span> <span class="ow">-&gt;</span> <span class="kt">ParsecT</span> <span class="n">s</span> <span class="n">u</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ParsecT</span> <span class="n">s</span> <span class="n">u</span> <span class="n">m</span> <span class="n">a</span>
<span class="c1">-- between open close p parses open, followed by p and close. Returns the value returned by p.</span>
</pre></div>

<p>So essentially, <code>inBrackets</code> expects some string that satisfies one of <code>behind</code>, <code>try aheadBehind</code> or <code>ahead</code> in between a <code>[</code> and <code>]</code>. There is a subtlety with the use of <code>try</code> in <code>try aheadBehind</code> that we will explain later. Now, let’s talk a look at <code>behind</code>, <code>aheadBehind</code> and <code>ahead</code>.</p>
<p><code>behind</code> is defined at <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L140">line 140 of src/src/BranchParse.hs</a>:</p>
<div class="highlight"><pre><span></span><span class="nf">behind</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">Distance</span>
<span class="nf">behind</span> <span class="ow">=</span> <span class="n">makeAheadBehind</span> <span class="s">&quot;behind&quot;</span> <span class="kt">Behind</span>
</pre></div>

<p>Recall that <code>Behind</code> is one of the data constrcutors of <code>Distance</code>. <code>makeAheadBehind</code> is defined at <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L131">line 131 of the same file</a>:</p>
<div class="highlight"><pre><span></span><span class="nf">makeAheadBehind</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Distance</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Parser</span> <span class="kt">Distance</span>
<span class="nf">makeAheadBehind</span> <span class="n">name</span> <span class="n">constructor</span> <span class="ow">=</span>
  <span class="kr">do</span> <span class="c1">-- Parsec</span>
    <span class="n">string</span> <span class="p">(</span><span class="n">name</span> <span class="o">++</span> <span class="s">&quot; &quot;</span><span class="p">)</span>
    <span class="n">dist</span> <span class="ow">&lt;-</span> <span class="n">many1</span> <span class="n">digit</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">constructor</span> <span class="p">(</span><span class="n">read</span> <span class="n">dist</span><span class="p">))</span>
</pre></div>

<p>Documentation for <code>many1</code> and <code>digit</code>, both in the Parsec library:</p>
<div class="highlight"><pre><span></span><span class="nf">many1</span> <span class="ow">::</span> <span class="kt">Stream</span> <span class="n">s</span> <span class="n">m</span> <span class="n">t</span> <span class="ow">=&gt;</span> <span class="kt">ParsecT</span> <span class="n">s</span> <span class="n">u</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ParsecT</span> <span class="n">s</span> <span class="n">u</span> <span class="n">m</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="c1">-- many1 p applies the parser p one or more times. Returns a list of the</span>
<span class="c1">-- returned values of p.</span>

<span class="nf">digit</span> <span class="ow">::</span> <span class="kt">Stream</span> <span class="n">s</span> <span class="n">m</span> <span class="kt">Char</span> <span class="ow">=&gt;</span> <span class="kt">ParsecT</span> <span class="n">s</span> <span class="n">u</span> <span class="n">m</span> <span class="kt">Char</span>
<span class="c1">-- Parses a digit. Returns the parsed character.</span>
</pre></div>

<p>We see that <code>behind = makeAheadBehind &quot;behind&quot; Behind</code>. This will first consume the string <code>&quot;behind &quot;</code> (and discard it), then consume 1 or more digits and bind the list of digits to <code>dist</code>. Since <code>constructor</code> has type <code>Int -&gt; Distance</code>, <code>read dist</code> will convert the list of digits into an <code>Int</code>, then pass it to <code>constructor</code> to create a <code>Distance</code>. In this case, the <code>constructor</code> is the <code>Behind</code> data constructor, which takes in 1 <code>Int</code> and creates a <code>Distance</code>.</p>
<p>The <code>behind</code> parser wants to parse a string similar to <code>behind 5</code> and returns a <code>Behind n</code>. <code>inBrackets</code> can therefore consume a string similar to <code>[behind 5]</code>.</p>
<div class="highlight"><pre><span></span><span class="nf">inBrackets</span> <span class="ow">=</span> <span class="n">between</span> <span class="p">(</span><span class="n">char</span> <span class="sc">'['</span><span class="p">)</span> <span class="p">(</span><span class="n">char</span> <span class="sc">']'</span><span class="p">)</span> <span class="p">(</span><span class="n">behind</span> <span class="o">&lt;|&gt;</span> <span class="n">try</span> <span class="n">aheadBehind</span> <span class="o">&lt;|&gt;</span> <span class="n">ahead</span><span class="p">)</span>
</pre></div>

<p>The other possibility that <code>inBrackets</code> can go down is <code>try aheadBehind</code>. Let’s look at the <code>aheadBehind</code> parser, <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L142">defined at line 142 of src/src/BranchParse.hs</a>:</p>
<div class="highlight"><pre><span></span><span class="nf">aheadBehind</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">Distance</span>
<span class="nf">aheadBehind</span> <span class="ow">=</span>
  <span class="kr">do</span> <span class="c1">-- Parsec</span>
    <span class="kt">Ahead</span> <span class="n">aheadBy</span> <span class="ow">&lt;-</span> <span class="n">ahead</span>
    <span class="n">string</span> <span class="s">&quot;, &quot;</span>
    <span class="kt">Behind</span> <span class="n">behindBy</span> <span class="ow">&lt;-</span> <span class="n">behind</span>
    <span class="n">return</span> <span class="p">(</span><span class="kt">AheadBehind</span> <span class="n">aheadBy</span> <span class="n">behindBy</span><span class="p">)</span>
</pre></div>

<p><code>ahead</code> is defined at <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L138">line 138 of the same file</a>:</p>
<div class="highlight"><pre><span></span><span class="nf">ahead</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">Distance</span>
<span class="nf">ahead</span> <span class="ow">=</span> <span class="n">makeAheadBehind</span> <span class="s">&quot;ahead&quot;</span> <span class="kt">Ahead</span>
</pre></div>

<p><code>aheadBehind</code> will first call <code>ahead</code>, which calls <code>makeAheadBehind</code>, which consumes the string <code>&quot;ahead &quot;</code> (and discard it), then consume 1 or more digits and creates an <code>Ahead Int</code>. The <code>string &quot;, &quot;</code> will consume the string <code>&quot;, &quot;</code>. Next, <code>behind</code> springs into action (we covered that above) and consumes <code>&quot;behind &quot;</code> followed by 1 or more digits. Note that pattern matching is done to get the <code>Int</code> in the <code>Behind</code> so that the <code>Int</code> is bound to <code>behindBy</code>. Finally, an <code>AheadBehind Int Int</code> is created. All in all, <code>inBrackets</code> that goes down the route of <code>aheadBehind</code> consumes a string similar to the following:</p>
<div class="highlight"><pre><span></span>[ahead 13, behind 7]
</pre></div>

<p>Returning to <code>inBrackets</code> once again:</p>
<div class="highlight"><pre><span></span><span class="nf">inBrackets</span> <span class="ow">=</span> <span class="n">between</span> <span class="p">(</span><span class="n">char</span> <span class="sc">'['</span><span class="p">)</span> <span class="p">(</span><span class="n">char</span> <span class="sc">']'</span><span class="p">)</span> <span class="p">(</span><span class="n">behind</span> <span class="o">&lt;|&gt;</span> <span class="n">try</span> <span class="n">aheadBehind</span> <span class="o">&lt;|&gt;</span> <span class="n">ahead</span><span class="p">)</span>
</pre></div>

<p>We see that the final possible branch is <code>ahead</code>. We have already covered this while going through <code>aheadBehind</code>. For completeness, if <code>inBrackets</code> goes down the route of <code>ahead</code>, a string similar to <code>[ahead 10]</code> is desired.</p>
<p>Earlier, we mentioned a subtlety in the use of <code>try</code> in <code>try aheadBehind</code> for the <code>inBrackets</code> parser. One might ask, why only wrap <code>aheadBehind</code> in a <code>try</code>? Why not wrap <code>behind</code> and <code>ahead</code> in <code>try</code> as well?</p>
<p>We do not have to wrap the <code>behind</code> parser in a <code>try</code>, because it uses the <code>string &quot;behind &quot;</code> parser to consume the string <code>&quot;behind &quot;</code>. Notice that the string <code>&quot;behind &quot;</code> and the string <code>&quot;ahead &quot;</code> differ in the first character (<code>b</code> vs. <code>a</code>) - this causes the <code>behind</code> parser to fail immediately <strong>without consuming any input</strong>. Since it does not consume any input, the <code>&lt;|&gt;</code> ensures that it will go on to try the next parser in <code>try aheadBehind</code>.</p>
<p>We see this fine print in the documentation for <code>(&lt;|&gt;)</code>:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="o">&lt;|&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">ParsecT</span> <span class="n">s</span> <span class="n">u</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ParsecT</span> <span class="n">s</span> <span class="n">u</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ParsecT</span> <span class="n">s</span> <span class="n">u</span> <span class="n">m</span> <span class="n">a</span>
<span class="c1">-- This combinator implements choice. The parser p &lt;|&gt; q first applies p. If it</span>
<span class="c1">-- succeeds, the value of p is returned. If p fails without consuming any input,</span>
<span class="c1">-- parser q is tried. This combinator is defined equal to the mplus member of</span>
<span class="c1">-- the MonadPlus class and the (&lt;|&gt;) member of Alternative.</span>
</pre></div>

<p>Specifically, the part that says <code>If p fails without consuming any input, parser q is tried.</code></p>
<p>There is overlap between strings that <code>aheadBehind</code> and <code>ahead</code> parse. <code>aheadBehind</code> expects strings of the form <code>ahead M, behind N</code>, while <code>ahead</code> expects a string similar to <code>ahead M</code>, with <code>M</code> and <code>N</code> being non negative integers. If we were to rearrange things and use <code>behind &lt;|&gt; ahead &lt;|&gt; try aheadBehind</code>, then for the input string <code>ahead 7, behind 9</code>, the <code>behind</code> parser will fail without consuming any input, then <code>&lt;|&gt;</code> will use the <code>ahead</code> parser to consume the string <code>&quot;ahead 7&quot;</code> and stop there. The <code>(behind &lt;|&gt; ahead &lt;|&gt; try aheadBehind)</code> parser succeeds, but <code>between (char '[') (char ']') (behind &lt;|&gt; try aheadBehind &lt;|&gt; ahead)</code> will fail because the next character is not a <code>]</code> but a <code>,</code>. Hence, <code>aheadBehind</code> must be attempted before <code>ahead</code>.</p>
<p>So we have established that <code>aheadBehind</code> must be attempted before <code>ahead</code>. Minimally, we have to use <code>behind &lt;|&gt; aheadBehind &lt;|&gt; ahead</code>. Now for the <code>try</code>. What happens if <code>behind &lt;|&gt; aheadBehind &lt;|&gt; ahead</code> parses the string <code>&quot;ahead 5&quot;</code> (which is valid for a git branch that is only ahead but not behind its remote tracking branch)? The <code>behind</code> parser fails without consuming any input, so <code>&lt;|&gt;</code> tries <code>aheadBehind</code>, which consumes the entire <code>&quot;ahead 5&quot;</code> but then that expects a <code>&quot;, &quot;</code>, so parsing fails. Because input was consumed, the next <code>&lt;|&gt;</code> does not try the <code>ahead</code> parser. Hence we need to wrap <code>aheadBehind</code> in a <code>try</code> so it will not consume any input on parse failure and chaining it with <code>&lt;|&gt; ahead</code> will move on to try the <code>ahead</code> parser.</p>
<p>Now that we know what the <code>inBrackets</code> parser does, we go back to what brought us here in the first place, <code>branchRemoteTracking</code>:</p>
<div class="highlight"><pre><span></span><span class="nf">branchRemoteTracking</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">MBranchInfo</span>
<span class="nf">branchRemoteTracking</span> <span class="ow">=</span>
  <span class="kr">do</span> <span class="c1">-- Parsec</span>
    <span class="n">branch</span> <span class="ow">&lt;-</span> <span class="n">trackedBranch</span>
    <span class="n">tracking</span> <span class="ow">&lt;-</span> <span class="n">many</span> <span class="p">(</span><span class="n">noneOf</span> <span class="s">&quot; &quot;</span><span class="p">)</span>
    <span class="n">char</span> <span class="sc">' '</span>
    <span class="n">behead</span> <span class="ow">&lt;-</span> <span class="n">inBrackets</span>
    <span class="kr">let</span> <span class="n">remote</span> <span class="ow">=</span> <span class="kt">MkRemote</span> <span class="p">(</span><span class="kt">MkBranch</span> <span class="n">tracking</span><span class="p">)</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">behead</span><span class="p">)</span>
    <span class="kr">let</span> <span class="n">bi</span> <span class="ow">=</span> <span class="kt">MkBranchInfo</span> <span class="n">branch</span>  <span class="p">(</span><span class="kt">Just</span> <span class="n">remote</span><span class="p">)</span>
    <span class="n">return</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">bi</span><span class="p">)</span>
</pre></div>

<p>Because <code>inBrackets</code> took a while to explain, if necessary, you might want to read what we previously covered for <code>branchRemoteTracking</code> to refresh your knowledge before carrying on.</p>
<p>To understand the data structures involved, we have to know what we are trying to do here. <code>branchRemoteTracking</code> is trying to parse a string where the current git branch that has a remote tracking branch and falls under one of the 3 cases:</p>
<ol style="list-style-type: decimal">
<li>it is some commits ahead of its remote tracking branch</li>
<li>it is some commits behind its remote tracking branch</li>
<li>it is some commits ahead AND some commits behind its remote tracking branch</li>
</ol>
<p>An example of a string that satisfies case 3 is:</p>
<div class="highlight"><pre><span></span>master...origin/feat [ahead 5, behind 3]
</pre></div>

<p>Armed with this information, we know that</p>
<div class="highlight"><pre><span></span>    <span class="kr">let</span> <span class="n">remote</span> <span class="ow">=</span> <span class="kt">MkRemote</span> <span class="p">(</span><span class="kt">MkBranch</span> <span class="n">tracking</span><span class="p">)</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">behead</span><span class="p">)</span>
</pre></div>

<p>Captures the information about the remote tracking branch in <code>MkBranch tracking</code> and the number of commits the current branch is ahead and/or behind the remote tracking branch in <code>Just behead</code>.</p>
<p>The <code>Remote</code> type constructor and the <code>MkRemote</code> data constructor are <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L56">defined at line 56 of src/src/BranchParse.hs</a>:</p>
<div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Remote</span> <span class="ow">=</span> <span class="kt">MkRemote</span> <span class="kt">Branch</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="kt">Distance</span><span class="p">)</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</pre></div>

<p>There is only 1 data constructor, <code>MkRemote</code>. We see that a remote represents a remote tracking branch (the <code>Branch</code> parameter) and the number of commits the current branch is ahead and/or behind this remote tracking branch (the <code>Maybe Distance</code> parameter). It is possible that the current branch and its remote tracking branch are in sync and <code>Maybe Distance</code> allows us to use <code>Nothing</code> to represent that.</p>
<p>The remaining lines in <code>branchRemoteTracking</code>:</p>
<div class="highlight"><pre><span></span>    <span class="kr">let</span> <span class="n">bi</span> <span class="ow">=</span> <span class="kt">MkBranchInfo</span> <span class="n">branch</span>  <span class="p">(</span><span class="kt">Just</span> <span class="n">remote</span><span class="p">)</span>
    <span class="n">return</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">bi</span><span class="p">)</span>
</pre></div>

<p>creates a <code>BranchInfo</code> object using its single data constructor <code>MkBranchInfo</code>, passing in the current branch (in <code>branch</code>) and information about the remote tracking branch (in <code>Just remote</code>). Then it wraps the <code>BranchInfo</code> inside a <code>Just</code> and uses <code>return</code> on it.</p>
<p>Here’s the definition for the <code>BranchInfo</code> type constructor:</p>
<div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">BranchInfo</span> <span class="ow">=</span> <span class="kt">MkBranchInfo</span> <span class="kt">Branch</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="kt">Remote</span><span class="p">)</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</pre></div>

<p>Earlier when we covered the <code>branchOnly</code> parser, we mentioned we will explain the <code>Maybe Remote</code> part in <code>MkBranchInfo</code>. See how <code>branchOnly</code> also uses <code>MkBranchInfo</code> but passes in a <code>Nothing</code> for the <code>Maybe Remote</code>:</p>
<div class="highlight"><pre><span></span><span class="nf">branchOnly</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">MBranchInfo</span>
<span class="nf">branchOnly</span> <span class="ow">=</span>
    <span class="c1">-- omitted</span>
    <span class="kr">let</span> <span class="n">bi</span> <span class="ow">=</span> <span class="kt">MkBranchInfo</span> <span class="p">(</span><span class="kt">MkBranch</span> <span class="n">branch</span><span class="p">)</span> <span class="kt">Nothing</span>
    <span class="c1">-- omitted</span>
</pre></div>

<p>The <code>Nothing</code> indicates that there is no remote tracking branch for the current branch.</p>
<p>To summarize, the <code>branchRemoteTracking</code> parser wants to consume a string similar to one of the three variants below:</p>
<div class="highlight"><pre><span></span>master...origin/feat [ahead 7]
bourbon...origin/rice-noodles [ahead 10, behind 4]
fix-a-pesky-bug...workplace/nice-feature-work [behind 2]
</pre></div>

<p>In other words, a branch that has a remote tracking branch and is some commits ahead and/or behind that remote tracking branch.</p>
<h3 id="the-branchremote-parser">The <code>branchRemote</code> parser</h3>
<p>In the event that <code>try noBranch</code>, <code>try newRepo</code> and <code>try branchRemoteTracking</code> all fail, <code>branchParser</code> attempts the <code>try branchRemote</code> parser.</p>
<div class="highlight"><pre><span></span><span class="nf">branchParser</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">MBranchInfo</span>
<span class="nf">branchParser</span> <span class="ow">=</span>
      <span class="n">try</span> <span class="n">noBranch</span>
    <span class="o">&lt;|&gt;</span> <span class="n">try</span> <span class="n">newRepo</span>
    <span class="o">&lt;|&gt;</span> <span class="n">try</span> <span class="n">branchRemoteTracking</span>
    <span class="o">&lt;|&gt;</span> <span class="n">try</span> <span class="n">branchRemote</span>
    <span class="o">&lt;|&gt;</span> <span class="n">branchOnly</span>
</pre></div>

<p>The <code>branchRemote</code> parser is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L96">defined at line 96 of src/src/BranchParse.hs</a>:</p>
<div class="highlight"><pre><span></span><span class="nf">branchRemote</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">MBranchInfo</span>
<span class="nf">branchRemote</span> <span class="ow">=</span>
  <span class="kr">do</span> <span class="c1">-- Parsec</span>
    <span class="n">branch</span> <span class="ow">&lt;-</span> <span class="n">trackedBranch</span>
    <span class="n">tracking</span> <span class="ow">&lt;-</span> <span class="n">many</span> <span class="p">(</span><span class="n">noneOf</span> <span class="s">&quot; &quot;</span><span class="p">)</span>
    <span class="n">eof</span>
    <span class="kr">let</span> <span class="n">remote</span> <span class="ow">=</span> <span class="kt">MkRemote</span> <span class="p">(</span><span class="kt">MkBranch</span> <span class="n">tracking</span><span class="p">)</span> <span class="kt">Nothing</span>
    <span class="kr">let</span> <span class="n">bi</span> <span class="ow">=</span> <span class="kt">MkBranchInfo</span> <span class="n">branch</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">remote</span><span class="p">)</span>
    <span class="n">return</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">bi</span><span class="p">)</span>
</pre></div>

<p>Its definition is eerily similar to that of <code>branchRemoteTracking</code>:</p>
<div class="highlight"><pre><span></span><span class="nf">branchRemoteTracking</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">MBranchInfo</span>
<span class="nf">branchRemoteTracking</span> <span class="ow">=</span>
  <span class="kr">do</span> <span class="c1">-- Parsec</span>
    <span class="n">branch</span> <span class="ow">&lt;-</span> <span class="n">trackedBranch</span>
    <span class="n">tracking</span> <span class="ow">&lt;-</span> <span class="n">many</span> <span class="p">(</span><span class="n">noneOf</span> <span class="s">&quot; &quot;</span><span class="p">)</span>
    <span class="n">char</span> <span class="sc">' '</span>
    <span class="n">behead</span> <span class="ow">&lt;-</span> <span class="n">inBrackets</span>
    <span class="kr">let</span> <span class="n">remote</span> <span class="ow">=</span> <span class="kt">MkRemote</span> <span class="p">(</span><span class="kt">MkBranch</span> <span class="n">tracking</span><span class="p">)</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">behead</span><span class="p">)</span>
    <span class="kr">let</span> <span class="n">bi</span> <span class="ow">=</span> <span class="kt">MkBranchInfo</span> <span class="n">branch</span>  <span class="p">(</span><span class="kt">Just</span> <span class="n">remote</span><span class="p">)</span>
    <span class="n">return</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">bi</span><span class="p">)</span>
</pre></div>

<p>Except that in terms of parsers, these 2 are not there:</p>
<div class="highlight"><pre><span></span>    <span class="n">char</span> <span class="sc">' '</span>
    <span class="n">behead</span> <span class="ow">&lt;-</span> <span class="n">inBrackets</span>
</pre></div>

<p>but are instead replaced by the <code>eof</code> parser, which expects there to be no more input.</p>
<p>With what we have covered for <code>branchRemoteTracking</code>, it should not be difficult to see that <code>branchRemote</code> expects a string similar to:</p>
<div class="highlight"><pre><span></span>refactoring...origin/refactoring
</pre></div>

<p>which is a git branch that has a remote tracking branch and is perfectly in sync with it. From</p>
<div class="highlight"><pre><span></span>    <span class="kr">let</span> <span class="n">remote</span> <span class="ow">=</span> <span class="kt">MkRemote</span> <span class="p">(</span><span class="kt">MkBranch</span> <span class="n">tracking</span><span class="p">)</span> <span class="kt">Nothing</span>
    <span class="kr">let</span> <span class="n">bi</span> <span class="ow">=</span> <span class="kt">MkBranchInfo</span> <span class="n">branch</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">remote</span><span class="p">)</span>
</pre></div>

<p>we see that the 2nd argument to <code>MkRemote</code> is a <code>Nothing</code>, which indicates that the git branch and its remote tracking branch are perfectly in sync.</p>
<p>Due to the overlap between the strings that <code>branchRemoteTracking</code> and <code>branchRemote</code> parsers consume, specifically, that <code>branchRemoteTracking</code> will consume what <code>branchRemote</code> consumes and more, therefore, <code>try branchRemoteTracking</code> has to be attempted before <code>try branchRemote</code>.</p>
<h3 id="the-branchonly-parser">The <code>branchOnly</code> parser</h3>
<p>The final parser the <code>branchParser</code> will use, when all else fails, is the <code>branchOnly</code> parser:</p>
<div class="highlight"><pre><span></span><span class="nf">branchParser</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">MBranchInfo</span>
<span class="nf">branchParser</span> <span class="ow">=</span>
      <span class="n">try</span> <span class="n">noBranch</span>
    <span class="o">&lt;|&gt;</span> <span class="n">try</span> <span class="n">newRepo</span>
    <span class="o">&lt;|&gt;</span> <span class="n">try</span> <span class="n">branchRemoteTracking</span>
    <span class="o">&lt;|&gt;</span> <span class="n">try</span> <span class="n">branchRemote</span>
    <span class="o">&lt;|&gt;</span> <span class="n">branchOnly</span>
</pre></div>

<p>Notice that it is not wrapped in a <code>try</code>, because this is the final parser in the chain and we do not need to care about whether input is consumed upon failure and we can just let it fail.</p>
<p><code>branchOnly</code> is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L106">defined at line 106 of src/src/BranchParse.hs</a>:</p>
<div class="highlight"><pre><span></span><span class="nf">branchOnly</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">MBranchInfo</span>
<span class="nf">branchOnly</span> <span class="ow">=</span>
  <span class="kr">do</span> <span class="c1">-- Parsec</span>
    <span class="n">branch</span> <span class="ow">&lt;-</span> <span class="n">many</span> <span class="p">(</span><span class="n">noneOf</span> <span class="s">&quot; &quot;</span><span class="p">)</span>
    <span class="n">eof</span>
    <span class="kr">let</span> <span class="n">bi</span> <span class="ow">=</span> <span class="kt">MkBranchInfo</span> <span class="p">(</span><span class="kt">MkBranch</span> <span class="n">branch</span><span class="p">)</span> <span class="kt">Nothing</span>
    <span class="n">return</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">bi</span><span class="p">)</span>
</pre></div>

<p>We have covered it when we went through the <code>newRepo</code> parser, so we shall not cover it here again. In short, <code>branchOnly</code> consumes a string containing just a branch name and has no remote tracking branch. To see this in an actual git repo, simply do a <code>git checkout -b some-crazy-weird-branch-name</code> and run <code>git status --porcelain --branch</code>. This first line in the output will look similar to:</p>
<div class="highlight"><pre><span></span>## some-crazy-weird-branch-name
</pre></div>

<p>Because this overlaps with what the <code>try branchRemoteTracking</code> and <code>try branchRemote</code> parsers consume, we have to attempt those before the <code>branchOnly</code> parser.</p>
<p>With that, we have completed our coverage of <code>branchParser</code>.</p>
<h2 id="summary-of-branchparser">Summary of <code>branchParser'</code></h2>
<div class="highlight"><pre><span></span><span class="nf">branchParser'</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">MBranchInfo</span>
<span class="nf">branchParser'</span> <span class="ow">=</span>
  <span class="kr">do</span> <span class="c1">-- Parsec</span>
    <span class="n">string</span> <span class="s">&quot;## &quot;</span>
    <span class="n">branchParser</span>

<span class="nf">branchParser</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">MBranchInfo</span>
<span class="nf">branchParser</span> <span class="ow">=</span>
      <span class="n">try</span> <span class="n">noBranch</span>
    <span class="o">&lt;|&gt;</span> <span class="n">try</span> <span class="n">newRepo</span>
    <span class="o">&lt;|&gt;</span> <span class="n">try</span> <span class="n">branchRemoteTracking</span>
    <span class="o">&lt;|&gt;</span> <span class="n">try</span> <span class="n">branchRemote</span>
    <span class="o">&lt;|&gt;</span> <span class="n">branchOnly</span>
</pre></div>

<p>To summarize <code>branchParser'</code>, below, we give one example on each line for each of the parsers that <code>branchParser</code> can use:</p>
<div class="highlight"><pre><span></span>## HEAD (no branch)
## Initial commit on something-that-doesnt-seem-to-work-for-git-2-15-0
## localbranch...remote/remote-tracking-branch [ahead 5, behind 5]
## localbranch...remote-two/another-remote-tracking-branch
## just-a-local-branch
</pre></div>

<h2 id="going-back-to-the-caller-of-branchparser">Going back to the caller of <code>branchParser'</code></h2>
<p>Now that we are done with <code>branchParser</code> (and <code>branchParser'</code>), we go back to what led us down this path:</p>
<div class="highlight"><pre><span></span><span class="nf">branchInfo</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">ParseError</span> <span class="kt">MBranchInfo</span>
<span class="nf">branchInfo</span> <span class="ow">=</span> <span class="n">parse</span> <span class="n">branchParser'</span> <span class="s">&quot;&quot;</span>

<span class="nf">processBranch</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">MBranchInfo</span>
<span class="nf">processBranch</span> <span class="ow">=</span> <span class="n">rightOrNothing</span> <span class="o">.</span> <span class="n">branchInfo</span>
</pre></div>

<p>On parse success, <code>branchInfo</code> returns a <code>Right MBranchInfo</code>. On parse failure, <code>branchInfo</code> returns a <code>Left ParseError</code>. Its calling function <code>processBranch</code> uses <code>rightOrNothing</code>, <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/Utils.hs#L15">defined at line 15 of src/src/Utils.hs</a>:</p>
<div class="highlight"><pre><span></span><span class="nf">rightOrNothing</span> <span class="ow">::</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span>
<span class="nf">rightOrNothing</span> <span class="ow">=</span> <span class="n">either</span> <span class="p">(</span><span class="n">const</span> <span class="kt">Nothing</span><span class="p">)</span> <span class="kt">Just</span>
</pre></div>

<p>to convert a <code>Left ParseError</code> into a <code>Nothing</code>, and convert a <code>Right MBranchInfo</code> into a <code>Just MBranchInfo</code>. The <code>either</code> function is from the <code>Data.Either</code> module:</p>
<div class="highlight"><pre><span></span><span class="nf">either</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span>
<span class="c1">-- Case analysis for the Either type. If the value is Left a, apply the first</span>
<span class="c1">-- function to a; if it is Right b, apply the second function to b.</span>
</pre></div>

<p>while the <code>const</code> function should be a familiar staple:</p>
<div class="highlight"><pre><span></span><span class="nf">const</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="c1">-- const x is a unary function which evaluates to x for all inputs.</span>
<span class="c1">-- For instance,</span>
<span class="c1">-- &gt;&gt;&gt; map (const 42) [0..3]</span>
<span class="c1">-- [42, 42, 42, 42]</span>
</pre></div>

<p>Notice that <code>rightOrNothing</code> will discard the <code>ParseError</code> that is embedded in the <code>Left</code> on a parse failure. In other applications, the <code>ParseError</code> may be used to display a meaningful error message giving some hints as to why parsing failed. But in this case, we do not care for that.</p>
<p><code>processBranch</code> is invoked by <code>processGitStatus</code>, <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/Utils.hs#L21">defined at line 21 of src/src/Utils.hs</a>:</p>
<div class="highlight"><pre><span></span><span class="nf">processGitStatus</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">GitInfo</span>
<span class="nf">processGitStatus</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">Nothing</span>
<span class="nf">processGitStatus</span> <span class="p">(</span><span class="n">branchLine</span><span class="kt">:</span><span class="n">statusLines</span><span class="p">)</span> <span class="ow">=</span>
    <span class="kr">do</span> <span class="c1">-- Maybe</span>
      <span class="n">mbranch</span> <span class="ow">&lt;-</span> <span class="n">processBranch</span> <span class="n">branchLine</span>
      <span class="n">status</span> <span class="ow">&lt;-</span> <span class="n">processStatus</span> <span class="n">statusLines</span>
      <span class="n">return</span> <span class="p">(</span><span class="kt">MkGitInfo</span> <span class="n">mbranch</span> <span class="n">status</span><span class="p">)</span>
</pre></div>

<p>On a successful parse of <code>branchLine</code> by <code>processBranch</code>, <code>mbranch</code> will be a <code>MBranchInfo</code>. Do note that we are in the <code>Maybe</code> monad. On an unsuccessful parse, <code>processBranch branchLine</code> will result in <code>Nothing</code> and the rest of the computations in <code>processGitStatus</code> will not be performed and a <code>Nothing</code> will be its return value.</p>
<p>We shall move on to <code>processStatus</code>, the next major piece of this program.</p>
<h2 id="the-processstatus-function">The <code>processStatus</code> function</h2>
<p><code>processStatus</code> is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/StatusParse.hs#L50">defined at line 50 of src/src/StatusParse.hs</a>:</p>
<div class="highlight"><pre><span></span><span class="nf">processStatus</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">Status</span> <span class="kt">Int</span><span class="p">)</span>
<span class="nf">processStatus</span> <span class="n">statLines</span> <span class="ow">=</span>
  <span class="kr">do</span> <span class="c1">-- Maybe</span>
    <span class="n">statList</span> <span class="ow">&lt;-</span> <span class="n">for</span> <span class="n">statLines</span> <span class="n">extractMiniStatus</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">countStatus</span> <span class="n">statList</span><span class="p">)</span>
</pre></div>

<p>This function parses all the lines from 2nd line to the final line of the output of <code>git status --porcelain --branch</code>. The function <code>for</code> is defined in the <code>Data.Traversable</code> module:</p>
<div class="highlight"><pre><span></span><span class="nf">for</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Traversable</span> <span class="n">t</span><span class="p">,</span> <span class="kt">Applicative</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">t</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">t</span> <span class="n">b</span><span class="p">)</span>
<span class="c1">-- for is traverse with its arguments flipped. For a version that ignores the</span>
<span class="c1">-- results see for_</span>

<span class="nf">traverse</span> <span class="ow">::</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">t</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">t</span> <span class="n">b</span><span class="p">)</span>
<span class="c1">-- Map each element of a structure to an action, evaluate these actions from</span>
<span class="c1">-- left to right, and collect the results. For a version that ignores the</span>
<span class="c1">-- results see traverse_</span>
</pre></div>

<p><code>traverse</code> is part of the <code>Traversable</code> type class. We include it here because <code>for</code> is defined in terms of <code>traverse</code>.</p>
<p>When we fit <code>for statLines extractMiniStatus</code> to the type signature of <code>for</code>, we get:</p>
<div class="highlight"><pre><span></span><span class="nf">for</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Applicative</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">[]</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">String</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="kt">[]</span> <span class="n">b</span><span class="p">)</span>
</pre></div>

<p>The <code>Traversable</code> here is the <code>[]</code> constructor (not to be confused with the empty list). <code>extractMiniStatus</code> is the <code>String -&gt; f b</code> function. It is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/StatusParse.hs#L45">defined at line 45 of src/src/StatusParse.hs</a> and has the following type signature:</p>
<div class="highlight"><pre><span></span><span class="nf">extractMiniStatus</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">MiniStatus</span>
</pre></div>

<p><code>Maybe</code> is an Applicative, and we see that our <code>b</code> is <code>MiniStatus</code>. Using this new found information about the types, we have:</p>
<div class="highlight"><pre><span></span><span class="nf">for</span> <span class="ow">::</span> <span class="kt">[]</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">MiniStatus</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">[]</span> <span class="kt">MiniStatus</span><span class="p">)</span>
</pre></div>

<p>Hence, <code>statList</code> in:</p>
<div class="highlight"><pre><span></span><span class="nf">statList</span> <span class="ow">&lt;-</span> <span class="n">for</span> <span class="n">statLines</span> <span class="n">extractMiniStatus</span>
</pre></div>

<p>has type <code>[MiniStatus]</code>.</p>
<p><code>MiniStatus</code> is a type constructor <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/StatusParse.hs#L14">defined at line 14 of the same file</a>. To better explain things, we include the comment above it as well:</p>
<div class="highlight"><pre><span></span><span class="cm">{- The two characters starting a git status line: -}</span>
<span class="kr">data</span> <span class="kt">MiniStatus</span> <span class="ow">=</span> <span class="kt">MkMiniStatus</span> <span class="kt">Char</span> <span class="kt">Char</span>
</pre></div>

<p>Here is the definition of <code>extractMiniStatus</code>:</p>
<div class="highlight"><pre><span></span><span class="nf">extractMiniStatus</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">MiniStatus</span>
<span class="nf">extractMiniStatus</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">Nothing</span>
<span class="nf">extractMiniStatus</span> <span class="p">[</span><span class="kr">_</span><span class="p">]</span> <span class="ow">=</span> <span class="kt">Nothing</span>
<span class="nf">extractMiniStatus</span> <span class="p">(</span><span class="n">index</span><span class="kt">:</span><span class="n">work</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="kt">MkMiniStatus</span> <span class="n">index</span> <span class="n">work</span><span class="p">)</span>
</pre></div>

<p>We see that if a string has less than 2 characters, it returns a <code>Nothing</code>. Otherwise, it uses pattern matching to extract the first 2 characters and pass them to the <code>MkMiniStatus</code> data constructor. The author uses <code>index</code> and <code>work</code> for the name bindings for the first and second characters respectively, which is a hint that this has something to do with the git index and the work tree.</p>
<p>To understand the behavior of <code>for</code>, we look at <a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/src/Data.Traversable.html#for">its definition</a>:</p>
<div class="highlight"><pre><span></span><span class="nf">for</span> <span class="ow">=</span> <span class="n">flip</span> <span class="n">traverse</span>
</pre></div>

<p>It is as the documentation says. This is not very meaningful, so we have to look at the <a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/src/Data.Traversable.html#line-235">definition of traverse for lists</a>:</p>
<div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Traversable</span> <span class="kt">[]</span> <span class="kr">where</span>
    <span class="cm">{-# INLINE traverse #-}</span> <span class="c1">-- so that traverse can fuse</span>
    <span class="n">traverse</span> <span class="n">f</span> <span class="ow">=</span> <span class="kt">List</span><span class="o">.</span><span class="n">foldr</span> <span class="n">cons_f</span> <span class="p">(</span><span class="n">pure</span> <span class="kt">[]</span><span class="p">)</span>
      <span class="kr">where</span> <span class="n">cons_f</span> <span class="n">x</span> <span class="n">ys</span> <span class="ow">=</span> <span class="n">liftA2</span> <span class="p">(</span><span class="kt">:</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span> <span class="n">ys</span>
</pre></div>

<p>In our case, <code>extractMiniStatus</code> is the <code>f</code>. Notice the <code>liftA2 (:) (f x) ys</code>. If <code>f x</code> returns a <code>Nothing</code> at some point, then we have:</p>
<div class="highlight"><pre><span></span><span class="nf">liftA2</span> <span class="p">(</span><span class="kt">:</span><span class="p">)</span> <span class="kt">Nothing</span> <span class="n">ys</span>
</pre></div>

<p>which should stay a <code>Nothing</code> for the remaining of the computation and there is no escape from it. But let us verify whether this is the case, by looking at <a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/src/GHC.Base.html#line-716">the definition of <code>liftA2</code> in the <code>Applicative</code> instance of <code>Maybe</code></a>:</p>
<div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">Maybe</span> <span class="kr">where</span>
    <span class="n">pure</span> <span class="ow">=</span> <span class="kt">Just</span>

    <span class="kt">Just</span> <span class="n">f</span>  <span class="o">&lt;*&gt;</span> <span class="n">m</span>       <span class="ow">=</span> <span class="n">fmap</span> <span class="n">f</span> <span class="n">m</span>
    <span class="kt">Nothing</span> <span class="o">&lt;*&gt;</span> <span class="n">_m</span>      <span class="ow">=</span> <span class="kt">Nothing</span>

    <span class="n">liftA2</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">y</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">liftA2</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Nothing</span>

    <span class="kt">Just</span> <span class="n">_m1</span> <span class="o">*&gt;</span> <span class="n">m2</span>      <span class="ow">=</span> <span class="n">m2</span>
    <span class="kt">Nothing</span>  <span class="o">*&gt;</span> <span class="n">_m2</span>     <span class="ow">=</span> <span class="kt">Nothing</span>
</pre></div>

<p><code>liftA2 (:) Nothing ys</code> is covered by the case</p>
<div class="highlight"><pre><span></span>    <span class="n">liftA2</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Nothing</span>
</pre></div>

<p>Therefore, once we get a <code>Nothing</code> in <code>traverse</code>, this definition of <code>liftA2</code> ensures that we will always get a <code>Nothing</code>. Which means that <code>extractMiniStatus</code> is banking on its final pattern match:</p>
<div class="highlight"><pre><span></span><span class="nf">extractMiniStatus</span> <span class="p">(</span><span class="n">index</span><span class="kt">:</span><span class="n">work</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="kt">MkMiniStatus</span> <span class="n">index</span> <span class="n">work</span><span class="p">)</span>
</pre></div>

<p>for any meaningful computation to be done. The other pattern matches (which return <code>Nothing</code>) all indicate failure.</p>
<p>If the 2nd till the final line of <code>git status --porcelain --branch</code> <strong>all</strong> pattern match against the final pattern match in <code>extractMiniStatus</code>, then <code>for statusList extractMiniStatus</code> returns a <code>Just [MiniStatus]</code>. If even one line doesn’t pattern match against the final pattern match, then <code>for statusList extractMiniStatus</code> returns a <code>Nothing</code>.</p>
<p>To understand what <code>extractMiniStatus</code> is pattern matching on, we quote some relevant documentation from the <a href="https://git-scm.com/docs/git-status/2.15.0#_short_format">short format section of the git status manpage for git 2.15.0</a>:</p>
<div class="highlight"><pre><span></span>In the short-format, the status of each path is shown as

    XY PATH1 -&gt; PATH2

where PATH1 is the path in the HEAD, and the &quot; -&gt; PATH 2&quot; part is shown only
when PATH1 corresponds to a different path in the index/worktree (i.e. the file
is renamed). The XY is a two-letter status code.

For paths with merge conflicts, X and Y show the modification states of each
side of the merge. For paths that do not have merge conflicts, X shows the
status of the index, and Y shows the status of the work tree. For untracked
paths, XY are ??. Other status codes can be interpreted as follows:

...omitted...
</pre></div>

<p>Indeed the first character of each line shows the state of the file in the index, while the second character shows the state of the file in the work tree. Notice how <code>extractMiniStatus</code> does not care about the rest of the characters on each line.</p>
<p>The final line of <code>processStatus</code>:</p>
<div class="highlight"><pre><span></span>    <span class="n">return</span> <span class="p">(</span><span class="n">countStatus</span> <span class="n">statList</span><span class="p">)</span>
</pre></div>

<p>calls the <code>countStatus</code> on the <code>[MiniStatus]</code> gathered, assuming all went well. If <code>for statusList extractMiniStatus</code> returns <code>Nothing</code>, then <code>processStatus</code> also returns a <code>Nothing</code>. Let us look at the <code>countStatus</code> function next.</p>
<h3 id="the-countstatus-function">The <code>countStatus</code> function</h3>
<p>The <code>countStatus</code> function is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/StatusParse.hs#L36">defined at line 36 of src/src/StatusParse.hs</a>:</p>
<div class="highlight"><pre><span></span><span class="nf">countStatus</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">MiniStatus</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Status</span> <span class="kt">Int</span>
<span class="nf">countStatus</span> <span class="n">l</span> <span class="ow">=</span> <span class="kt">MakeStatus</span>
  <span class="p">{</span>
  <span class="n">staged</span><span class="ow">=</span><span class="n">countByType</span> <span class="n">isStaged</span> <span class="n">l</span><span class="p">,</span>
  <span class="n">conflict</span><span class="ow">=</span><span class="n">countByType</span> <span class="n">isConflict</span> <span class="n">l</span><span class="p">,</span>
  <span class="n">changed</span><span class="ow">=</span><span class="n">countByType</span> <span class="n">isChanged</span> <span class="n">l</span><span class="p">,</span>
  <span class="n">untracked</span><span class="ow">=</span><span class="n">countByType</span> <span class="n">isUntracked</span> <span class="n">l</span>
  <span class="p">}</span>
</pre></div>

<p>It returns a <code>Status Int</code>. The <code>Status</code> type constructor is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/StatusParse.hs#L7">defined at line 7 of the same file</a>. But we include the comment at line 6 as well:</p>
<div class="highlight"><pre><span></span><span class="cm">{- Full status information -}</span>
<span class="kr">data</span> <span class="kt">Status</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">MakeStatus</span> <span class="p">{</span>
  <span class="n">staged</span> <span class="ow">::</span> <span class="n">a</span><span class="p">,</span>
  <span class="n">conflict</span> <span class="ow">::</span> <span class="n">a</span><span class="p">,</span>
  <span class="n">changed</span> <span class="ow">::</span> <span class="n">a</span><span class="p">,</span>
  <span class="n">untracked</span> <span class="ow">::</span> <span class="n">a</span><span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</pre></div>

<p>With <code>Status Int</code>, all the fields in <code>MakeStatus</code> will be <code>Int</code>. This seems to be used to count the number of files in the git repo that are not in a “clean” state.</p>
<p>We see that the <code>countStatus</code> function uses the <code>countByType</code> function to compute each of the fields in <code>MakeStatus</code>. The <code>countByType</code> function is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/StatusParse.hs#L33">defined at line 33 of the same file</a>:</p>
<div class="highlight"><pre><span></span><span class="nf">countByType</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">MiniStatus</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">MiniStatus</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">countByType</span> <span class="n">isType</span> <span class="ow">=</span> <span class="n">length</span> <span class="o">.</span> <span class="n">filter</span> <span class="n">isType</span>
</pre></div>

<p><code>countByType</code> counts the number of lines in the <code>[MiniStatus]</code> computed by <code>for statusList extractMiniStatus</code> that fulfil the <code>isType</code> predicate. Based on the usage of <code>countByType</code> that we see in the <code>MakeStatus</code> data constructor, the <code>isStaged</code>, <code>isConflict</code>, <code>isChanged</code> and <code>isUntracked</code> predicates are used as the <code>isType</code> argument to <code>countByType</code>. Let’s take a look at <code>isStaged</code>, <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/StatusParse.hs#L21">defined at line 21 of src/src/StatusParse.hs</a>:</p>
<div class="highlight"><pre><span></span><span class="nf">isStaged</span> <span class="ow">::</span> <span class="kt">MiniStatus</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">isStaged</span> <span class="p">(</span><span class="kt">MkMiniStatus</span> <span class="n">index</span> <span class="n">work</span><span class="p">)</span> <span class="ow">=</span>
    <span class="p">(</span><span class="n">index</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="s">&quot;MRC&quot;</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="sc">'D'</span> <span class="o">&amp;&amp;</span> <span class="n">work</span> <span class="o">/=</span> <span class="sc">'D'</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="sc">'A'</span> <span class="o">&amp;&amp;</span> <span class="n">work</span> <span class="o">/=</span> <span class="sc">'A'</span><span class="p">)</span>
</pre></div>

<p>There are 3 distinct cases where <code>isStaged</code> returns <code>True</code>:</p>
<ol style="list-style-type: decimal">
<li>First character of a status line is one of <code>M</code>, <code>R</code>, <code>C</code></li>
<li>First character of a status line is <code>D</code> and the second character is not <code>D</code></li>
<li>First character of a status line is <code>A</code> and the second character is not <code>A</code></li>
</ol>
<p>The code is simple enough, but what exactly do these characters stand for? To find out, we consult the <a href="https://git-scm.com/docs/git-status/2.15.0#_short_format">documentation for the short-format of <code>git status</code></a>:</p>
<div class="highlight"><pre><span></span>In the short-format, the status of each path is shown as

    XY PATH1 -&gt; PATH2

where PATH1 is the path in the HEAD, and the &quot; -&gt; PATH 2&quot; part is shown only
when PATH1 corresponds to a different path in the index/worktree (i.e. the file
is renamed). The XY is a two-letter status code.

For paths with merge conflicts, X and Y show the modification states of each
side of the merge. For paths that do not have merge conflicts, X shows the
status of the index, and Y shows the status of the work tree. For untracked
paths, XY are ??. Other status codes can be interpreted as follows:

- '' = unmodified
- M = modified
- A = added
- D = deleted
- R = renamed
- C = copied
- U = updated but unmerged

Ignored files are not listed, unless --ignored option is in effect, in which
case XY are !!.

X          Y     Meaning
-------------------------------------------------
          [MD]   not updated
M        [ MD]   updated in index
A        [ MD]   added to index
D         [ M]   deleted from index
R        [ MD]   renamed in index
C        [ MD]   copied in index
[MARC]           index and work tree matches
[ MARC]     M    work tree changed since index
[ MARC]     D    deleted in work tree
-------------------------------------------------
D           D    unmerged, both deleted
A           U    unmerged, added by us
U           D    unmerged, deleted by them
U           A    unmerged, added by them
D           U    unmerged, deleted by us
A           A    unmerged, both added
U           U    unmerged, both modified
-------------------------------------------------
?           ?    untracked
!           !    ignored
-------------------------------------------------
</pre></div>

<p>The table on the codes for <code>X</code> and <code>Y</code> are very useful to us and allows us to show some of the cases covered by the <code>isStaged</code> function.</p>
<p><code>index `elem` &quot;MRC&quot;</code> covers these cases:</p>
<div class="highlight"><pre><span></span>M        [ MD]   updated in index
R        [ MD]   renamed in index
C        [ MD]   copied in index
[MARC]           index and work tree matches
</pre></div>

<p><code>(index == 'D' &amp;&amp; work /= 'D')</code> covers these cases:</p>
<div class="highlight"><pre><span></span>D         [ M]   deleted from index
D           U    unmerged, deleted by us
</pre></div>

<p>while <code>(index == 'A' &amp;&amp; work /= 'A')</code> covers these cases:</p>
<div class="highlight"><pre><span></span>A        [ MD]   added to index
[MARC]           index and work tree matches
[ MARC]     M    work tree changed since index
[ MARC]     D    deleted in work tree
A           U    unmerged, added by us
</pre></div>

<p>But based on first principles, <code>index `elem` &quot;MRC&quot;</code> covers the case where the file in the index has been modified, renamed, or copied, relative to HEAD. Starting from a clean repository, <code>M</code> can be achieved by making a change to a file tracked by git and then using <code>git add</code> on that file. <code>R</code> can be achieved by using <code>git mv</code>. I have no idea how we can get a <code>C</code> but I am guessing it might have something to do with one of <code>git rebase</code>, <code>git merge</code>, <code>git am</code> and similar.</p>
<p>One way to satisfy <code>(index == 'D' &amp;&amp; work /= 'D')</code> is to use <code>git rm</code> on a tracked file. To be precise, that shows a <code>&quot;D &quot;</code> for the first character and a space for the second character. If the table is exhaustive, it seems that we are ok with every entry that has a <code>D</code> in the first character, except for this one case:</p>
<div class="highlight"><pre><span></span>D           D    unmerged, both deleted
</pre></div>

<p>which seems that it will only arise during a git merge when there’s a merge conflict in another file that’s awaiting the user to resolve manually or a similar situation involving some merge conflict - this is just a guess and I am not certain if I am correct.</p>
<p>One way to satisfy <code>(index == 'A' &amp;&amp; work /= 'A')</code> is to <code>git add</code> a previously untracked file. That gives us a <code>&quot;A &quot;</code> to be precise. It seems that we are trying to avoid this case:</p>
<div class="highlight"><pre><span></span>A           A    unmerged, both added
</pre></div>

<p>which once again seems that it will only arise during a merge conflict pending human resolution.</p>
<p>Whether these cases covered by the <code>isStaged</code> function are exhaustive, they all indicate that the file has changed in the index, relative to HEAD, except for in the case of merge conflicts.</p>
<p>We shall do a quick walkthrough of <code>isConflict</code>, <code>isChanged</code> and <code>isUntracked</code>.</p>
<div class="highlight"><pre><span></span><span class="nf">isConflict</span> <span class="ow">::</span> <span class="kt">MiniStatus</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">isConflict</span> <span class="p">(</span><span class="kt">MkMiniStatus</span> <span class="n">index</span> <span class="n">work</span><span class="p">)</span> <span class="ow">=</span>
    <span class="n">index</span> <span class="o">==</span> <span class="sc">'U'</span> <span class="o">||</span> <span class="n">work</span> <span class="o">==</span> <span class="sc">'U'</span> <span class="o">||</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="sc">'A'</span> <span class="o">&amp;&amp;</span> <span class="n">work</span> <span class="o">==</span> <span class="sc">'A'</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="sc">'D'</span> <span class="o">&amp;&amp;</span> <span class="n">work</span> <span class="o">==</span> <span class="sc">'D'</span><span class="p">)</span>
</pre></div>

<p>As its name suggests, <code>isConflict</code> covers the case where a file has a merge conflict.</p>
<div class="highlight"><pre><span></span><span class="nf">isChanged</span> <span class="ow">::</span> <span class="kt">MiniStatus</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">isChanged</span> <span class="p">(</span><span class="kt">MkMiniStatus</span> <span class="n">index</span> <span class="n">work</span><span class="p">)</span> <span class="ow">=</span>
    <span class="n">work</span> <span class="o">==</span> <span class="sc">'M'</span> <span class="o">||</span> <span class="p">(</span><span class="n">work</span> <span class="o">==</span> <span class="sc">'D'</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">/=</span> <span class="sc">'D'</span><span class="p">)</span>
</pre></div>

<p><code>isChanged</code> takes care of files which are modified in the work tree relative to HEAD (<code>work == 'M'</code>) and files deleted from the work tree but not deleted in the index (can be gotten by using <code>rm</code> to remove a tracked file).</p>
<div class="highlight"><pre><span></span><span class="nf">isUntracked</span> <span class="ow">::</span> <span class="kt">MiniStatus</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">isUntracked</span> <span class="p">(</span><span class="kt">MkMiniStatus</span> <span class="n">index</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span>
    <span class="n">index</span> <span class="o">==</span> <span class="sc">'?'</span>
</pre></div>

<p>and finally, <code>isUntracked</code> takes care of files which are not tracked by git.</p>
<p>Returning to <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/StatusParse.hs#L50">processStatus</a> and <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/StatusParse.hs#L36">countStatus</a>:</p>
<div class="highlight"><pre><span></span><span class="nf">processStatus</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">Status</span> <span class="kt">Int</span><span class="p">)</span>
<span class="nf">processStatus</span> <span class="n">statLines</span> <span class="ow">=</span>
  <span class="kr">do</span> <span class="c1">-- Maybe</span>
    <span class="n">statList</span> <span class="ow">&lt;-</span> <span class="n">for</span> <span class="n">statLines</span> <span class="n">extractMiniStatus</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">countStatus</span> <span class="n">statList</span><span class="p">)</span>

<span class="nf">countStatus</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">MiniStatus</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Status</span> <span class="kt">Int</span>
<span class="nf">countStatus</span> <span class="n">l</span> <span class="ow">=</span> <span class="kt">MakeStatus</span>
  <span class="p">{</span>
  <span class="n">staged</span><span class="ow">=</span><span class="n">countByType</span> <span class="n">isStaged</span> <span class="n">l</span><span class="p">,</span>
  <span class="n">conflict</span><span class="ow">=</span><span class="n">countByType</span> <span class="n">isConflict</span> <span class="n">l</span><span class="p">,</span>
  <span class="n">changed</span><span class="ow">=</span><span class="n">countByType</span> <span class="n">isChanged</span> <span class="n">l</span><span class="p">,</span>
  <span class="n">untracked</span><span class="ow">=</span><span class="n">countByType</span> <span class="n">isUntracked</span> <span class="n">l</span>
  <span class="p">}</span>
</pre></div>

<p>we see that <code>for statLines extractMiniStatus</code> computes a list of <code>MkMiniStatus</code> from the output of <code>git status --porcelain --branch</code>. Then, <code>countStatus</code> is used to create a <code>Status</code> with 4 fields that counts the number of files which are modified in the index relative to the work tree (staged), in a merge conflict, modified in the work tree relative to HEAD (changed) and untracked. This <code>Status</code> is then wrapped in a <code>Just</code> and returned by <code>processStatus</code>.</p>
<p>In the event that some line in the output of <code>git status --porcelain --branch</code> has less than 2 characters, <code>for statLines extractMiniStatus</code> results in a <code>Nothing</code> and it is returned by <code>processStatus</code>, without running <code>return (countStats statList)</code>, because we are inside the <code>Maybe</code> monad.</p>
<p>That finishes our coverage of <code>processStatus</code>.</p>
<h2 id="going-back-to-processgitstatus">Going back to <code>processGitStatus</code></h2>
<div class="highlight"><pre><span></span><span class="nf">processGitStatus</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">GitInfo</span>
<span class="nf">processGitStatus</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">Nothing</span>
<span class="nf">processGitStatus</span> <span class="p">(</span><span class="n">branchLine</span><span class="kt">:</span><span class="n">statusLines</span><span class="p">)</span> <span class="ow">=</span>
    <span class="kr">do</span> <span class="c1">-- Maybe</span>
      <span class="n">mbranch</span> <span class="ow">&lt;-</span> <span class="n">processBranch</span> <span class="n">branchLine</span>
      <span class="n">status</span> <span class="ow">&lt;-</span> <span class="n">processStatus</span> <span class="n">statusLines</span>
      <span class="n">return</span> <span class="p">(</span><span class="kt">MkGitInfo</span> <span class="n">mbranch</span> <span class="n">status</span><span class="p">)</span>
</pre></div>

<p>In the final line, <code>MkGitInfo mbranch status</code> constructs a <code>GitInfo</code> (<a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/Utils.hs#L11">defined at line 11 of src/src/Utils.hs</a>):</p>
<div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">GitInfo</span> <span class="ow">=</span> <span class="kt">MkGitInfo</span> <span class="kt">MBranchInfo</span> <span class="p">(</span><span class="kt">Status</span> <span class="kt">Int</span><span class="p">)</span>
</pre></div>

<p>which wraps over the <code>MBranchInfo</code> from <code>processBranch branchLine</code> and the <code>Status Int</code> from <code>processStatus statusLines</code>. Assuming everything went smoothly and both <code>processBranch</code> and <code>processStatus</code> returned <code>Just</code>s, the <code>GitInfo</code> itself will be wrapped inside <code>Just</code>. Otherwise, <code>processGitStatus</code> returns a <code>Nothing</code>.</p>
<p>The <code>GitInfo</code> value captures all the information obtained from the output of <code>git status --porcelain --branch</code>.</p>
<h2 id="going-back-to-stringsfromstatus">Going back to <code>stringsFromStatus</code></h2>
<div class="highlight"><pre><span></span><span class="nf">stringsFromStatus</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Hash</span>
                  <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="c1">-- status</span>
                  <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
<span class="nf">stringsFromStatus</span> <span class="n">h</span> <span class="n">status</span> <span class="ow">=</span> <span class="kr">do</span> <span class="c1">-- List</span>
    <span class="n">processed</span> <span class="ow">&lt;-</span> <span class="n">processGitStatus</span> <span class="p">(</span><span class="n">lines</span> <span class="n">status</span><span class="p">)</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">showGitInfo</span> <span class="n">h</span> <span class="n">processed</span><span class="p">)</span>
</pre></div>

<p><code>stringsFromStatus</code> lives inside the <code>Maybe</code> monad. <code>processGitStatus</code> returns either a <code>Just GitStatus</code> or a <code>Nothing</code>. If it is a <code>Nothing</code>, everything else is skipped and <code>stringsFromStatus</code> returns a <code>Nothing</code>. If it is a <code>Just GitStatus</code>, the <code>GitStatus</code> is bound to <code>processed</code>. That, along with <code>h</code>, is passed to <code>showGitInfo</code>, <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/Utils.hs#L57">defined at line 57 of src/src/Utils.hs</a>:</p>
<div class="highlight"><pre><span></span><span class="nf">showGitInfo</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Hash</span>
      <span class="ow">-&gt;</span> <span class="kt">GitInfo</span>
      <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
<span class="nf">showGitInfo</span> <span class="n">mhash</span> <span class="p">(</span><span class="kt">MkGitInfo</span> <span class="n">bi</span> <span class="n">stat</span><span class="p">)</span> <span class="ow">=</span> <span class="n">branchInfoString</span> <span class="o">++</span> <span class="n">showStatusNumbers</span> <span class="n">stat</span>
  <span class="kr">where</span>
    <span class="n">branchInfoString</span> <span class="ow">=</span> <span class="n">showBranchInfo</span> <span class="p">(</span><span class="n">branchOrHashWith</span> <span class="sc">':'</span> <span class="n">mhash</span> <span class="n">bi</span><span class="p">)</span>
</pre></div>

<p>This pattern matches the <code>GitInfo</code> argument using its only <code>MkGitInfo</code> constructor and binds its 2 components to the names <code>bi</code> and <code>stat</code>.</p>
<p>Because the return type of <code>ShowGitInfo</code> is <code>[String]</code> and a <code>++</code> is used to concatenate <code>branchInfoString</code> and <code>showStatusNumbers stat</code>, this means that <code>branchInfoString</code> is a <code>[String]</code>.</p>
<p>Let’s look at the <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/Utils.hs#L50">definition of <code>branchOrHashWith</code>, along with its comment at line 50</a>:</p>
<div class="highlight"><pre><span></span><span class="cm">{- Combine status info, branch info and hash -}</span>

<span class="nf">branchOrHashWith</span> <span class="ow">::</span> <span class="kt">Char</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Hash</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">BranchInfo</span> <span class="ow">-&gt;</span> <span class="kt">BranchInfo</span>
<span class="nf">branchOrHashWith</span> <span class="kr">_</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">bi</span><span class="p">)</span> <span class="ow">=</span> <span class="n">bi</span>
<span class="nf">branchOrHashWith</span> <span class="n">c</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">hash</span><span class="p">)</span> <span class="kt">Nothing</span> <span class="ow">=</span> <span class="kt">MkBranchInfo</span> <span class="p">(</span><span class="kt">MkBranch</span> <span class="p">(</span><span class="n">c</span> <span class="kt">:</span> <span class="n">getHash</span> <span class="n">hash</span><span class="p">))</span> <span class="kt">Nothing</span>
<span class="nf">branchOrHashWith</span> <span class="kr">_</span> <span class="kt">Nothing</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">MkBranchInfo</span> <span class="p">(</span><span class="kt">MkBranch</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="kt">Nothing</span>
</pre></div>

<p>The first pattern match ignores the first 2 arguments and tries to pattern match against the <code>MBranchInfo</code> inside the <code>GitInfo</code>. Recall that this is the result of the <code>processBranch</code> function and captures all the important information about the current git branch. Also recall that <code>MBranchInfo</code> is a type synonym for <code>Maybe BranchInfo</code>. If this is a <code>Just</code>, then <code>branchOrHashWith</code> simply returns the <code>BranchInfo</code> value that’s wrapped inside the <code>Just</code>.</p>
<p>The second pattern match covers the case where the return value from <code>processBranch</code> is a <code>Nothing</code>. This happens when parsing the branch line fails and we have no information on the current git branch. The second argument passed to <code>branchOrHashWith</code> is originally from the <code>main</code> function:</p>
<div class="highlight"><pre><span></span><span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> <span class="c1">-- IO</span>
  <span class="n">status</span> <span class="ow">&lt;-</span> <span class="n">getContents</span>
    <span class="n">mhash</span> <span class="ow">&lt;-</span> <span class="n">unsafeInterleaveIO</span> <span class="n">gitrevparse</span> <span class="c1">-- defer the execution until we know we need the hash</span>
    <span class="c1">-- omitted</span>

<span class="nf">gitrevparse</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="kt">Hash</span><span class="p">)</span>
<span class="nf">gitrevparse</span> <span class="ow">=</span> <span class="kr">do</span> <span class="c1">-- IO</span>
    <span class="n">mresult</span> <span class="ow">&lt;-</span> <span class="n">safeRun</span> <span class="s">&quot;git&quot;</span> <span class="p">[</span><span class="s">&quot;rev-parse&quot;</span><span class="p">,</span> <span class="s">&quot;--short&quot;</span><span class="p">,</span> <span class="s">&quot;HEAD&quot;</span><span class="p">]</span>
    <span class="kr">let</span> <span class="n">rev</span> <span class="ow">=</span> <span class="kr">do</span> <span class="c1">-- Maybe</span>
      <span class="n">result</span> <span class="ow">&lt;-</span> <span class="n">mresult</span>
      <span class="n">return</span> <span class="p">(</span><span class="kt">MkHash</span> <span class="p">(</span><span class="n">init</span> <span class="n">result</span><span class="p">))</span>
    <span class="n">return</span> <span class="n">rev</span>
</pre></div>

<p>to be exact, it is the result of <code>unsafeInterleaveIO gitrevparse</code>, which is a deferred run of <code>git rev-parse --short HEAD</code>. This command shows the git commit SHA1 of the top most commit on the current git branch. We covered this early on and noted that the result of <code>unsafeInterleaveIO gitrevparse</code> will be a <code>Just Hash</code> if the <code>git rev-parse --short HEAD</code> runs successfully and a <code>Nothing</code> otherwise. So we finally see the purpose of this deferred computation: it allows us to obtain a git commit SHA1 as a fallback in the event that we cannot obtain any information about the git branch. The <code>unsafeInterleaveIO</code> will prevent it from running until it is actually needed.</p>
<p>Returning to the second pattern match of <code>branchOrHashWith</code>:</p>
<div class="highlight"><pre><span></span><span class="nf">branchOrHashWith</span> <span class="n">c</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">hash</span><span class="p">)</span> <span class="kt">Nothing</span> <span class="ow">=</span> <span class="kt">MkBranchInfo</span> <span class="p">(</span><span class="kt">MkBranch</span> <span class="p">(</span><span class="n">c</span> <span class="kt">:</span> <span class="n">getHash</span> <span class="n">hash</span><span class="p">))</span> <span class="kt">Nothing</span>
</pre></div>

<p>The <code>(Just hash)</code> will only pattern match on a successful executation of <code>git rev-parse --short HEAD</code>. The <code>c</code> here is a colon character. The <code>getHash</code> function is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/Utils.hs#L9">defined at line 9 of src/src/Utils.hs</a>:</p>
<div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">Hash</span> <span class="ow">=</span> <span class="kt">MkHash</span> <span class="p">{</span><span class="n">getHash</span> <span class="ow">::</span> <span class="kt">String</span><span class="p">}</span>
</pre></div>

<p><code>getHash hash</code> extracts the <code>String</code> that is wrapped by the <code>MkHash</code> newtype constructor, which is used by the <code>gitrevparse</code> function to wrap around the git commit SHA1 (except for the newline character).</p>
<p>Overall, this second pattern match of <code>branchOrHashWith</code> returns a <code>BranchInfo</code> value whose <code>Branch</code> component is the git commit SHA1 prepended with a colon character, and whose <code>Maybe Remote</code> component is a <code>Nothing</code>.</p>
<p>The third and final pattern match of <code>branchOrHashWith</code>:</p>
<div class="highlight"><pre><span></span><span class="nf">branchOrHashWith</span> <span class="kr">_</span> <span class="kt">Nothing</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">MkBranchInfo</span> <span class="p">(</span><span class="kt">MkBranch</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="kt">Nothing</span>
</pre></div>

<p>covers the case where both parsing the branch line failed and the command <code>git rev-parse --short HEAD</code> failed. In this case, a <code>BranchInfo</code> object is created with the <code>Branch</code> component being a <code>MkBranch &quot;&quot;</code> and whose <code>Maybe Remote</code> component is a <code>Nothing</code>.</p>
<p>Going back to <code>showGitInfo</code>, we see that the <code>BranchInfo</code> returned by <code>branchOrHasWith</code> is passed to <code>showBranchInfo</code>.</p>
<div class="highlight"><pre><span></span>    <span class="n">branchInfoString</span> <span class="ow">=</span> <span class="n">showBranchInfo</span> <span class="p">(</span><span class="n">branchOrHashWith</span> <span class="sc">':'</span> <span class="n">mhash</span> <span class="n">bi</span><span class="p">)</span>
</pre></div>

<p>which is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/Utils.hs#L47">defined at line 47 of src/src/Utils.hs</a>:</p>
<div class="highlight"><pre><span></span><span class="nf">showBranchInfo</span> <span class="ow">::</span> <span class="kt">BranchInfo</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
<span class="nf">showBranchInfo</span> <span class="p">(</span><span class="kt">MkBranchInfo</span> <span class="n">branch</span> <span class="n">mremote</span><span class="p">)</span> <span class="ow">=</span> <span class="n">show</span> <span class="n">branch</span> <span class="kt">:</span> <span class="n">showRemoteNumbers</span> <span class="n">mremote</span>
</pre></div>

<p>This first runs <code>show branch</code> to convert the <code>Branch</code> value within <code>MkBranchInfo</code> into a <code>String</code>. The <code>Show</code> instance of <code>Branch</code> is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L40">defined at line 40 of src/src/BranchParse.hs</a>:</p>
<div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">Branch</span> <span class="kr">where</span>
    <span class="n">show</span> <span class="p">(</span><span class="kt">MkBranch</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="n">b</span>
</pre></div>

<p>Because <code>Branch</code> is just a newtype wrapper over <code>String</code>, this is essentially just returns the <code>String</code> that is being wrapped. The value of this <code>String</code> can be the current git branch name or if parsing the branch line fails, the current git commit SHA1 prepended by a colon, or if that fails, it will be the empty string.</p>
<p>This <code>String</code> is prepended to the <code>[String]</code> created by <code>showRemoteNumbers mremote</code>. The <code>showRemoteNumbers</code> function is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/Utils.hs#L35">defined at line 35 of src/src/Utils.hs</a>:</p>
<div class="highlight"><pre><span></span><span class="nf">showRemoteNumbers</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Remote</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
<span class="nf">showRemoteNumbers</span> <span class="n">mremote</span> <span class="ow">=</span>
    <span class="kr">do</span> <span class="c1">-- List</span>
      <span class="n">ab</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="n">ahead</span><span class="p">,</span> <span class="n">behind</span><span class="p">]</span>
      <span class="n">return</span> <span class="p">(</span><span class="n">show</span> <span class="n">ab</span><span class="p">)</span>
  <span class="kr">where</span>
    <span class="p">(</span><span class="n">ahead</span><span class="p">,</span> <span class="n">behind</span><span class="p">)</span> <span class="ow">=</span> <span class="n">fromMaybe</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="n">distance</span>  <span class="c1">-- the script needs some value, (0,0) means no display</span>
    <span class="n">distance</span> <span class="ow">=</span> <span class="kr">do</span> <span class="c1">-- Maybe</span>
      <span class="n">remote</span> <span class="ow">&lt;-</span> <span class="n">mremote</span>
      <span class="n">dist</span> <span class="ow">&lt;-</span> <span class="n">getDistance</span> <span class="n">remote</span>
      <span class="n">return</span> <span class="p">(</span><span class="n">pairFromDistance</span> <span class="n">dist</span><span class="p">)</span>
</pre></div>

<p>And it makes use of the list monad. The idea is simple. <code>ahead</code> and <code>behind</code> will each be bound to <code>ab</code> (one at a time) and then <code>show ab</code> converts it to a <code>String</code>, which will be in the resulting <code>[String]</code>. Hence the return value of <code>showRemoteNumbers</code> will always be a list of 2 strings.</p>
<p><code>ahead</code> and <code>behind</code> are defined in the <code>where</code> clause by <code>fromMaybe (0,0) distance</code>. The <code>fromMaybe</code> function is part of the <code>Data.Maybe</code> module. We covered it earlier but to refresh our memory, here is its documentation:</p>
<div class="highlight"><pre><span></span><span class="nf">fromMaybe</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="c1">-- The fromMaybe function takes a default value and a Maybe value. If the Maybe</span>
<span class="c1">-- is a Nothing, it returns the default values; otherwise, it returns the value</span>
<span class="c1">-- contained in the Maybe.</span>
</pre></div>

<p>If <code>distance</code> is a <code>Just _</code>, then we will be taking <code>(ahead, behind)</code> from inside it. Otherwise, <code>ahead</code> and <code>behind</code> will both be 0. <code>distance</code> is defined as follows:</p>
<div class="highlight"><pre><span></span>    <span class="n">distance</span> <span class="ow">=</span> <span class="kr">do</span> <span class="c1">-- Maybe</span>
      <span class="n">remote</span> <span class="ow">&lt;-</span> <span class="n">mremote</span>
      <span class="n">dist</span> <span class="ow">&lt;-</span> <span class="n">getDistance</span> <span class="n">remote</span>
      <span class="n">return</span> <span class="p">(</span><span class="n">pairFromDistance</span> <span class="n">dist</span><span class="p">)</span>
</pre></div>

<p>It lives in the <code>Maybe</code> monad. The <code>mremote</code> is the <code>Maybe Remote</code> part of the bigger <code>BranchInfo</code> value passed to <code>showBranchInfo</code>. If it is a <code>Nothing</code>, all bets are off and <code>fromMaybe (0,0) distance</code> will return <code>(0,0)</code>. This applies for the case where there is no information on the number of commits the current branch is ahead and/or behind its remote tracking branch, or perhaps the current branch does not have a remote tracking branch.</p>
<p>If there is a <code>Remote</code> value, it is bound to the name <code>remote</code> and passed to the <code>getDistance</code> function, <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L58">defined at line 58 of src/src/BranchParse.hs</a>:</p>
<div class="highlight"><pre><span></span><span class="nf">getDistance</span> <span class="ow">::</span> <span class="kt">Remote</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Distance</span>
<span class="nf">getDistance</span> <span class="p">(</span><span class="kt">MkRemote</span> <span class="kr">_</span> <span class="n">md</span><span class="p">)</span> <span class="ow">=</span> <span class="n">md</span>
</pre></div>

<p>Here is the definition of the <code>Remote</code> data type:</p>
<div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Remote</span> <span class="ow">=</span> <span class="kt">MkRemote</span> <span class="kt">Branch</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="kt">Distance</span><span class="p">)</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</pre></div>

<p>so <code>getDistance</code> is essentially extracting the <code>Maybe Distance</code> part. This will only be a <code>Just</code> if parsing the branch line was successful and it is one of the following variants:</p>
<div class="highlight"><pre><span></span>## master...origin/feat [ahead 7]
## bourbon...origin/rice-noodles [ahead 10, behind 4]
## fix-a-pesky-bug...workplace/nice-feature-work [behind 2]
</pre></div>

<p>which will be parsed by the <code>branchParser'</code> parser using the <code>branchParser</code> parser which goes down the route of the <code>branchRemoteTracking</code> parser, all of which we covered earlier.</p>
<p>The <code>Distance</code> type is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L21">defined at line 21 of src/src/BranchParse.hs</a>:</p>
<div class="highlight"><pre><span></span>data Distance = Ahead Int | Behind Int | AheadBehind Int Int deriving (Eq)
</pre></div>

<p>If <code>getDistance</code> extracts a <code>Just Distance</code> value, the <code>Distance</code> value is bound to the name <code>dist</code>, which is then passed to the <code>pairFromDistance</code> function, <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L153">defined at line 153 of src/src/BranchParse.hs</a>:</p>
<div class="highlight"><pre><span></span><span class="nf">pairFromDistance</span> <span class="ow">::</span> <span class="kt">Distance</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span>
<span class="nf">pairFromDistance</span> <span class="p">(</span><span class="kt">Ahead</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="nf">pairFromDistance</span> <span class="p">(</span><span class="kt">Behind</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
<span class="nf">pairFromDistance</span> <span class="p">(</span><span class="kt">AheadBehind</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
</pre></div>

<p>which covers all the different data constructors of <code>Distance</code>. It returns a 2 tuple, with each element being the number of commits the current branch is ahead or behind of its remote tracking branch, respectively.</p>
<div class="highlight"><pre><span></span><span class="nf">showRemoteNumbers</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Remote</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
<span class="nf">showRemoteNumbers</span> <span class="n">mremote</span> <span class="ow">=</span>
    <span class="kr">do</span> <span class="c1">-- List</span>
      <span class="n">ab</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="n">ahead</span><span class="p">,</span> <span class="n">behind</span><span class="p">]</span>
      <span class="n">return</span> <span class="p">(</span><span class="n">show</span> <span class="n">ab</span><span class="p">)</span>
  <span class="kr">where</span>
    <span class="p">(</span><span class="n">ahead</span><span class="p">,</span> <span class="n">behind</span><span class="p">)</span> <span class="ow">=</span> <span class="n">fromMaybe</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="n">distance</span>  <span class="c1">-- the script needs some value, (0,0) means no display</span>
    <span class="n">distance</span> <span class="ow">=</span> <span class="kr">do</span> <span class="c1">-- Maybe</span>
      <span class="n">remote</span> <span class="ow">&lt;-</span> <span class="n">mremote</span>
      <span class="n">dist</span> <span class="ow">&lt;-</span> <span class="n">getDistance</span> <span class="n">remote</span>
      <span class="n">return</span> <span class="p">(</span><span class="n">pairFromDistance</span> <span class="n">dist</span><span class="p">)</span>
</pre></div>

<p>With our newfound knowledge, what <code>showRemoteNumbers</code> does is pretty obvious. It returns a list of 2 strings indicating how many commits the current branch is ahead or behind its remote tracking branch respectively, if applicable. Otherwise, both elements will be <code>&quot;0&quot;</code>.</p>
<p>Backtracking to <code>showBranchInfo</code>:</p>
<div class="highlight"><pre><span></span><span class="nf">showBranchInfo</span> <span class="p">(</span><span class="kt">MkBranchInfo</span> <span class="n">branch</span> <span class="n">mremote</span><span class="p">)</span> <span class="ow">=</span> <span class="n">show</span> <span class="n">branch</span> <span class="kt">:</span> <span class="n">showRemoteNumbers</span> <span class="n">mremote</span>
</pre></div>

<p>We see that it returns a list of 3 strings:</p>
<ul>
<li>the current git branch / SHA1 / the empty string</li>
<li>the number of commits the current git branch is ahead of its remote tracking branch</li>
<li>the number of commits the current git branch is behind its remote tracking branch</li>
</ul>
<p>And backtracking to <code>showGitInfo</code>:</p>
<div class="highlight"><pre><span></span><span class="nf">showGitInfo</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Hash</span>
      <span class="ow">-&gt;</span> <span class="kt">GitInfo</span>
      <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
<span class="nf">showGitInfo</span> <span class="n">mhash</span> <span class="p">(</span><span class="kt">MkGitInfo</span> <span class="n">bi</span> <span class="n">stat</span><span class="p">)</span> <span class="ow">=</span> <span class="n">branchInfoString</span> <span class="o">++</span> <span class="n">showStatusNumbers</span> <span class="n">stat</span>
  <span class="kr">where</span>
    <span class="n">branchInfoString</span> <span class="ow">=</span> <span class="n">showBranchInfo</span> <span class="p">(</span><span class="n">branchOrHashWith</span> <span class="sc">':'</span> <span class="n">mhash</span> <span class="n">bi</span><span class="p">)</span>
</pre></div>

<p>After having generated the list of 3 strings in <code>branchInfoString</code>, we concatenate it with the result of <code>showStatusNumbers stat</code>, <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/Utils.hs#L29">defined at line 29 of src/src/Utils.hs</a>:</p>
<div class="highlight"><pre><span></span><span class="nf">showStatusNumbers</span> <span class="ow">::</span> <span class="kt">Status</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
<span class="nf">showStatusNumbers</span> <span class="p">(</span><span class="kt">MakeStatus</span> <span class="n">s</span> <span class="n">x</span> <span class="n">c</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=</span>
    <span class="kr">do</span> <span class="c1">-- List</span>
      <span class="n">nb</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span>
      <span class="n">return</span> <span class="p">(</span><span class="n">show</span> <span class="n">nb</span><span class="p">)</span>
</pre></div>

<p>Looking at the definition of the <code>Status</code> data type:</p>
<div class="highlight"><pre><span></span><span class="cm">{- Full status information -}</span>
<span class="kr">data</span> <span class="kt">Status</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">MakeStatus</span> <span class="p">{</span>
  <span class="n">staged</span> <span class="ow">::</span> <span class="n">a</span><span class="p">,</span>
  <span class="n">conflict</span> <span class="ow">::</span> <span class="n">a</span><span class="p">,</span>
  <span class="n">changed</span> <span class="ow">::</span> <span class="n">a</span><span class="p">,</span>
  <span class="n">untracked</span> <span class="ow">::</span> <span class="n">a</span><span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</pre></div>

<p>we see that <code>showStatusNumbers</code> extracts the number of staged, conflicted, changed and untracked files, converts each of them to <code>String</code>, then packs them into a list.</p>
<div class="highlight"><pre><span></span><span class="nf">showGitInfo</span> <span class="n">mhash</span> <span class="p">(</span><span class="kt">MkGitInfo</span> <span class="n">bi</span> <span class="n">stat</span><span class="p">)</span> <span class="ow">=</span> <span class="n">branchInfoString</span> <span class="o">++</span> <span class="n">showStatusNumbers</span> <span class="n">stat</span>
</pre></div>

<p>and <code>showGitInfo</code> combines all the information into one list of 7 elements, which are <code>String</code> versions of the following:</p>
<ul>
<li>the branch name / git commit sha1 / the empty string</li>
<li>the number of commits the current git branch is ahead of its remote tracking branch</li>
<li>the number of commits the current git branch is behind its remote tracking branch</li>
<li>the number of files that are modified in the index relative to HEAD</li>
<li>the number of files that are in a merge conflict</li>
<li>the number of files that are modified in the work tree relative to HEAD</li>
<li>the number of untracked files</li>
</ul>
<p>Backtracking to <code>stringsFromStatus</code>:</p>
<div class="highlight"><pre><span></span><span class="nf">stringsFromStatus</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Hash</span>
                  <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="c1">-- status</span>
                  <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
<span class="nf">stringsFromStatus</span> <span class="n">h</span> <span class="n">status</span> <span class="ow">=</span> <span class="kr">do</span> <span class="c1">-- List</span>
    <span class="n">processed</span> <span class="ow">&lt;-</span> <span class="n">processGitStatus</span> <span class="p">(</span><span class="n">lines</span> <span class="n">status</span><span class="p">)</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">showGitInfo</span> <span class="n">h</span> <span class="n">processed</span><span class="p">)</span>
</pre></div>

<p>If <code>processGitStatus</code> returns a <code>Just GitInfo</code>, the <code>GitInfo</code> is bound to the name <code>processed</code>, then <code>showGitInfo h processed</code> is executed and the list it returns is wrapped inside a <code>Just</code> and returned by <code>stringsFromStatus</code>. If <code>processGitStatus</code> returns a <code>Nothing</code>, then <code>stringsFromStatus</code> returns a <code>Nothing</code>.</p>
<h2 id="backtracking-to-the-main-function">Backtracking to the <code>main</code> function</h2>
<div class="highlight"><pre><span></span><span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> <span class="c1">-- IO</span>
  <span class="n">status</span> <span class="ow">&lt;-</span> <span class="n">getContents</span>
  <span class="n">mhash</span> <span class="ow">&lt;-</span> <span class="n">unsafeInterleaveIO</span> <span class="n">gitrevparse</span> <span class="c1">-- defer the execution until we know we need the hash</span>
  <span class="kr">let</span> <span class="n">result</span> <span class="ow">=</span> <span class="kr">do</span> <span class="c1">-- Maybe</span>
    <span class="n">strings</span> <span class="ow">&lt;-</span> <span class="n">stringsFromStatus</span> <span class="n">mhash</span> <span class="n">status</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">unwords</span> <span class="n">strings</span><span class="p">)</span>
  <span class="n">putStr</span> <span class="p">(</span><span class="n">fromMaybe</span> <span class="s">&quot;&quot;</span> <span class="n">result</span><span class="p">)</span>
</pre></div>

<p>If <code>stringsFromStatus</code> returns a <code>Just [String]</code>, the <code>[String]</code> is bound to <code>strings</code>. The <code>unwords</code> function then joins the <code>String</code>s in the list together into one big <code>String</code>, with each <code>String</code> in the list separated by a space character. This <code>Maybe String</code> is then bound to the <code>result</code> let binding. If <code>result</code> is a <code>Just String</code>, then <code>putStr (fromMaybe &quot;&quot; result)</code> will print the <code>String</code> to standard output; otherwise it will print the empty string to standard output.</p>
<p>And… we are done with our main function.</p>
<p>The rest of the post covers how the output of this Haskell program is used to generate a prompt containing information about the git repo.</p>
<h2 id="generating-the-prompt">Generating the prompt</h2>
<p>Very early on, we briefly covered the <code>update_current_git_vars</code> function <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/zshrc.sh#L43">defined in line 43 of zshrc.sh</a>:</p>
<div class="highlight"><pre><span></span><span class="k">function</span> update_current_git_vars<span class="o">()</span> <span class="o">{</span>
    <span class="nb">unset</span> __CURRENT_GIT_STATUS

    <span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;</span><span class="nv">$GIT_PROMPT_EXECUTABLE</span><span class="s2">&quot;</span> <span class="o">==</span> <span class="s2">&quot;python&quot;</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
        <span class="nb">local</span> <span class="nv">gitstatus</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$__GIT_PROMPT_DIR</span><span class="s2">/gitstatus.py&quot;</span>
        <span class="nv">_GIT_STATUS</span><span class="o">=</span><span class="sb">`</span>python <span class="si">${</span><span class="nv">gitstatus</span><span class="si">}</span> <span class="m">2</span>&gt;/dev/null<span class="sb">`</span>
    <span class="k">fi</span>
    <span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;</span><span class="nv">$GIT_PROMPT_EXECUTABLE</span><span class="s2">&quot;</span> <span class="o">==</span> <span class="s2">&quot;haskell&quot;</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
        <span class="nv">_GIT_STATUS</span><span class="o">=</span><span class="sb">`</span>git status --porcelain --branch <span class="p">&amp;</span>&gt; /dev/null <span class="p">|</span> <span class="nv">$__GIT_PROMPT_DIR</span>/src/.bin/gitstatus<span class="sb">`</span>
    <span class="k">fi</span>
     <span class="nv">__CURRENT_GIT_STATUS</span><span class="o">=(</span><span class="s2">&quot;</span><span class="si">${</span><span class="p">(@s: :)_GIT_STATUS</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">)</span>
  <span class="nv">GIT_BRANCH</span><span class="o">=</span><span class="nv">$__CURRENT_GIT_STATUS</span><span class="o">[</span><span class="m">1</span><span class="o">]</span>
  <span class="nv">GIT_AHEAD</span><span class="o">=</span><span class="nv">$__CURRENT_GIT_STATUS</span><span class="o">[</span><span class="m">2</span><span class="o">]</span>
  <span class="nv">GIT_BEHIND</span><span class="o">=</span><span class="nv">$__CURRENT_GIT_STATUS</span><span class="o">[</span><span class="m">3</span><span class="o">]</span>
  <span class="nv">GIT_STAGED</span><span class="o">=</span><span class="nv">$__CURRENT_GIT_STATUS</span><span class="o">[</span><span class="m">4</span><span class="o">]</span>
  <span class="nv">GIT_CONFLICTS</span><span class="o">=</span><span class="nv">$__CURRENT_GIT_STATUS</span><span class="o">[</span><span class="m">5</span><span class="o">]</span>
  <span class="nv">GIT_CHANGED</span><span class="o">=</span><span class="nv">$__CURRENT_GIT_STATUS</span><span class="o">[</span><span class="m">6</span><span class="o">]</span>
  <span class="nv">GIT_UNTRACKED</span><span class="o">=</span><span class="nv">$__CURRENT_GIT_STATUS</span><span class="o">[</span><span class="m">7</span><span class="o">]</span>
<span class="o">}</span>
</pre></div>

<p>This is the line that runs the Haskell program to process the output of <code>git status --porcelain --branch</code>:</p>
<div class="highlight"><pre><span></span>        <span class="nv">_GIT_STATUS</span><span class="o">=</span><span class="sb">`</span>git status --porcelain --branch <span class="p">&amp;</span>&gt; /dev/null <span class="p">|</span> <span class="nv">$__GIT_PROMPT_DIR</span>/src/.bin/gitstatus<span class="sb">`</span>
</pre></div>

<p>and the output of the Haskell program is stored in the <code>_GIT_STATUS</code> variable. The line</p>
<div class="highlight"><pre><span></span><span class="nv">__CURRENT_GIT_STATUS</span><span class="o">=(</span><span class="s2">&quot;</span><span class="si">${</span><span class="p">(@s: :)_GIT_STATUS</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">)</span>
</pre></div>

<p>splits the <code>_GIT_STATUS</code> variable using space as the delimiter and stores the result as an array in the <code>__CURRENT_GIT_STATUS</code> variable. Right after that</p>
<div class="highlight"><pre><span></span>  <span class="nv">GIT_BRANCH</span><span class="o">=</span><span class="nv">$__CURRENT_GIT_STATUS</span><span class="o">[</span><span class="m">1</span><span class="o">]</span>
  <span class="nv">GIT_AHEAD</span><span class="o">=</span><span class="nv">$__CURRENT_GIT_STATUS</span><span class="o">[</span><span class="m">2</span><span class="o">]</span>
  <span class="nv">GIT_BEHIND</span><span class="o">=</span><span class="nv">$__CURRENT_GIT_STATUS</span><span class="o">[</span><span class="m">3</span><span class="o">]</span>
  <span class="nv">GIT_STAGED</span><span class="o">=</span><span class="nv">$__CURRENT_GIT_STATUS</span><span class="o">[</span><span class="m">4</span><span class="o">]</span>
  <span class="nv">GIT_CONFLICTS</span><span class="o">=</span><span class="nv">$__CURRENT_GIT_STATUS</span><span class="o">[</span><span class="m">5</span><span class="o">]</span>
  <span class="nv">GIT_CHANGED</span><span class="o">=</span><span class="nv">$__CURRENT_GIT_STATUS</span><span class="o">[</span><span class="m">6</span><span class="o">]</span>
  <span class="nv">GIT_UNTRACKED</span><span class="o">=</span><span class="nv">$__CURRENT_GIT_STATUS</span><span class="o">[</span><span class="m">7</span><span class="o">]</span>
</pre></div>

<p>we see that the author makes the assumption that there are 7 elements in the <code>__CURRENT_GIT_STATUS</code> array and assigns each element to a variable. These are the same 7 elements in the list created by the <code>showGitInfo</code> Haskell function.</p>
<p>We go back to the <code>git_super_status</code> function, <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/zshrc.sh#L64">defined at line 64 of zshrc.sh</a>:</p>
<div class="highlight"><pre><span></span>git_super_status<span class="o">()</span> <span class="o">{</span>
  precmd_update_git_vars
  <span class="k">if</span> <span class="o">[</span> -n <span class="s2">&quot;</span><span class="nv">$__CURRENT_GIT_STATUS</span><span class="s2">&quot;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nv">STATUS</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$ZSH_THEME_GIT_PROMPT_PREFIX$ZSH_THEME_GIT_PROMPT_BRANCH$GIT_BRANCH</span><span class="s2">%{</span><span class="si">${</span><span class="nv">reset_color</span><span class="si">}</span><span class="s2">%}&quot;</span>
    <span class="c1"># omitted</span>
<span class="o">}</span>
</pre></div>

<p>In the <code>if</code> statement, <code>__CURRENT_GIT_STATUS</code> variable is checked for non emptiness. If so, <code>STATUS</code> is assigned a value which begins with <code>$ZSH_THEME_GIT_PROMPT_PREFIX</code>, <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/zshrc.sh#L96">defined at line 96 of zshrc.sh</a>:</p>
<div class="highlight"><pre><span></span><span class="nv">ZSH_THEME_GIT_PROMPT_PREFIX</span><span class="o">=</span><span class="s2">&quot;(&quot;</span>
</pre></div>

<p>followed by <code>$ZSH_THEME_GIT_PROMPT_BRANCH</code>, <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/zshrc.sh#L99">defined at line 99 of the same file</a>:</p>
<div class="highlight"><pre><span></span><span class="nv">ZSH_THEME_GIT_PROMPT_BRANCH</span><span class="o">=</span><span class="s2">&quot;%{</span><span class="nv">$fg_bold</span><span class="s2">[magenta]%}&quot;</span>
</pre></div>

<p>This changes the foreground color (text color) to magenta.</p>
<p>This is followed by <code>$GIT_BRANCH</code>, which gives us the branch name produced by the Haskell program. Then we have a <code>%{${reset_color}%}</code> which resets the foreground color.</p>
<p>If the current directory is in a git repo and the branch is named <code>my-branch</code>, the <code>STATUS</code> variable will have the following value:</p>
<div class="highlight"><pre><span></span>(my-branch
</pre></div>

<p>Next up, we have the following code inside the overall <code>if</code> branch in <code>git_super_status</code>:</p>
<div class="highlight"><pre><span></span>    <span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$GIT_AHEAD</span><span class="s2">&quot;</span> -ne <span class="s2">&quot;0&quot;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
      <span class="nv">STATUS</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$STATUS$ZSH_THEME_GIT_PROMPT_AHEAD$GIT_AHEAD</span><span class="s2">%{</span><span class="si">${</span><span class="nv">reset_color</span><span class="si">}</span><span class="s2">%}&quot;</span>
    <span class="k">fi</span>
</pre></div>

<p>This appends extra stuff to <code>STATUS</code>, <strong>but only if <code>GIT_AHEAD</code> is a non-zero value</strong>. It starting with <code>ZSH_THEME_GIT_PROMPT_AHEAD</code>, <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/zshrc.sh#L104">defined at line 104 of zshrc.sh</a>:</p>
<div class="highlight"><pre><span></span><span class="nv">ZSH_THEME_GIT_PROMPT_AHEAD</span><span class="o">=</span><span class="s2">&quot;%{UpArrow%G%}&quot;</span>
</pre></div>

<p>There is an up arrow character ↑ which I have replaced with the text <code>UpArrow</code> because of some technical issues that prevents it from rendering in a code block.</p>
<p>This is then followed by <code>GIT_AHEAD</code>, which is the number of git commits the current branch is ahead of its remote tracking branch (if any). Then we have another <code>%{${reset_color}%}</code>.</p>
<p>The <code>%{UpArrow%G%}</code> is used to include a ‘glitch’ to output the ↑ character. According to <a href="http://zsh.sourceforge.net/Doc/Release/Prompt-Expansion.html">zsh documentation</a>:</p>
<blockquote>
<p>%G</p>
<p>Within a %{…%} sequence, include a ‘glitch’: that is, assume that a single character width will be output. This is useful when outputting characters that otherwise cannot be correctly handled by the shell, such as the alternate character set on some terminals. The characters in question can be included within a %{…%} sequence together with the appropriate number of %G sequences to indicate the correct width. An integer between the ‘%’ and ‘G’ indicates a character width other than one. Hence %{seq%2G%} outputs seq and assumes it takes up the width of two standard characters.</p>
<p>Multiple uses of %G accumulate in the obvious fashion; the position of the %G is unimportant. Negative integers are not handled.</p>
<p>Note that when prompt truncation is in use it is advisable to divide up output into single characters within each %{…%} group so that the correct truncation point can be found.</p>
</blockquote>
<p>Building on our hypothetical example, if <code>my-branch</code> is 5 commits ahead of its remote tracking branch, the <code>GIT_AHEAD</code> variable will have value 5 and the <code>STATUS</code> variable will have the value <code>(my-branch↑5</code>. However, if <code>my-branch</code> is not ahead of its remote tracking branch, then <code>GIT_AHEAD</code> will be zero and <code>STATUS</code> will still be <code>(my-branch</code>.</p>
<p>The next line in <code>git_super_status</code>:</p>
<div class="highlight"><pre><span></span>    <span class="nv">STATUS</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$STATUS$ZSH_THEME_GIT_PROMPT_SEPARATOR</span><span class="s2">&quot;</span>
</pre></div>

<p>appends <code>ZSH_THEME_GIT_PROMPT_SEPARATOR</code>, which is <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/zshrc.sh#L98">defined at line 98</a>:</p>
<div class="highlight"><pre><span></span><span class="nv">ZSH_THEME_GIT_PROMPT_SEPARATOR</span><span class="o">=</span><span class="s2">&quot;|&quot;</span>
</pre></div>

<p>so it is a pipe character. This separates the (git branch, number of commits ahead and number of commits behind) from the rest of the information.</p>
<p>The rest of the code in <code>git_super_status</code> is of a similar nature and we shall not go through them here. We make an exception for line 91, where <code>echo &quot;$STATUS&quot;</code> prints the prompt that is built. For zsh-git-prompt to display iinformation about a git repo, code which calls the <code>git_super_status</code> function has to be at the user’s <code>~/.zshrc</code> (or included by it). <a href="https://github.com/olivierverdier/zsh-git-prompt/tree/v0.5#install">Example code from the README</a>:</p>
<div class="highlight"><pre><span></span><span class="nb">source</span> path/to/zshrc.sh
<span class="c1"># an example prompt</span>
<span class="nv">PROMPT</span><span class="o">=</span><span class="s1">'%B%m%~%b$(git_super_status) %# '</span>
</pre></div>

<p>The prompt from the <code>STATUS</code> variable printed by the <code>git_super_status</code> function will be part of the <code>PROMPT</code> variable, which presumably forms the actual prompt that the user sees. Thus when the user is in a directory which is a git repository, information about that repository will be shown.</p>
<p>Note that in <code>git_super_status</code>, if <code>__CURRENT_GIT_STATUS</code> is empty, which can happen from either a failure to parse the branch line or a failure to parse any of the status lines from the output of <code>git status --porcelain --branch</code>, then <code>git_super_status</code> will not print anything and hence in</p>
<div class="highlight"><pre><span></span><span class="nv">PROMPT</span><span class="o">=</span><span class="s1">'%B%m%~%b$(git_super_status) %# '</span>
</pre></div>

<p>the <code>$(git_super_status)</code> part will interpolate to nothing. A “conventional” prompt will be shown.</p>
<p>With that, our deep dive into zsh-git-prompt has come to an end.</p>
<h2 id="conclusion-ramblings">Conclusion / Ramblings</h2>
<p>We have not covered all the important code in the zsh-git-prompt repo, only the code that is actually run during normal usage. There are some <a href="https://github.com/olivierverdier/zsh-git-prompt/tree/v0.5/src/test">test code in the src/test directory</a> that the reader might want to take a look at, along with supporting code that is littered throughout the main code but used in tests as well. For instance, line 28 of <a href="https://github.com/olivierverdier/zsh-git-prompt/blob/v0.5/src/src/BranchParse.hs#L28">src/src/BranchParse.hs</a>. This code offers some insight on how one can use the venerable <a href="https://hackage.haskell.org/package/QuickCheck">QuickCheck library</a> for testing Haskell code. I could go through that in a follow up post, or maybe not, because it has taken me about a week of my free time to write this post and I need to get back to other stuff I was working on.</p>
<p>This is a pretty intense post (hence I called it a deep dive) and sometimes even I was lost in the details (but I managed to find my way back). The parts where I pasted previously discussed code was more for myself to refresh my memory than for you the reader. If you have made it all the way here and understood most of the content, then you deserve a pat on the back and my mission was successful.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="https://github.com/olivierverdier/zsh-git-prompt" class="uri">https://github.com/olivierverdier/zsh-git-prompt</a> (zsh-git-prompt GitHub repo)</li>
<li><a href="https://unix.stackexchange.com/a/129184" class="uri">https://unix.stackexchange.com/a/129184</a> (Unix &amp; Linux Stack Exchange: Redirect output of a command to two different files)</li>
<li><a href="https://unix.stackexchange.com/a/345508" class="uri">https://unix.stackexchange.com/a/345508</a> (Unix &amp; Linux Stack Exchange: how to redirect output to multiple log files)</li>
<li><a href="http://zsh.sourceforge.net/Doc/Release/Redirection.html" class="uri">http://zsh.sourceforge.net/Doc/Release/Redirection.html</a> (The Z Shell Manual chapter 7: Redirection)</li>
<li><a href="https://stackoverflow.com/q/13263692" class="uri">https://stackoverflow.com/q/13263692</a> (Stack Overflow: When is unsafeInterleaveIO unsafe?)</li>
<li><a href="http://hackage.haskell.org/package/base-4.10.1.0/docs/System-IO-Unsafe.html#v:unsafeInterleaveIO" class="uri">http://hackage.haskell.org/package/base-4.10.1.0/docs/System-IO-Unsafe.html#v:unsafeInterleaveIO</a> (unsafeInterleaveIO documentation)</li>
<li><a href="http://hackage.haskell.org/package/process-1.6.2.0/docs/System-Process.html#v:readProcessWithExitCode" class="uri">http://hackage.haskell.org/package/process-1.6.2.0/docs/System-Process.html#v:readProcessWithExitCode</a> (readProcessWithExitCode documentation)</li>
<li><a href="http://hackage.haskell.org/package/process-1.6.2.0/docs/System-Process.html#v:readProcess" class="uri">http://hackage.haskell.org/package/process-1.6.2.0/docs/System-Process.html#v:readProcess</a> (readProcess documentation)</li>
<li><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:unwords" class="uri">http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:unwords</a> (unwords documentation)</li>
<li><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#v:fromMaybe" class="uri">http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#v:fromMaybe</a> (fromMaybe documentation)</li>
<li><a href="http://hackage.haskell.org/package/base-4.10.1.0/docs/Prelude.html#v:lines" class="uri">http://hackage.haskell.org/package/base-4.10.1.0/docs/Prelude.html#v:lines</a> (lines documentation)</li>
<li><a href="https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html#v:parse" class="uri">https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html#v:parse</a> (parse documentation)</li>
<li><a href="https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html#v:-60--124--62-">https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html#v:-60–124–62-</a> ((&lt;|&gt;) documentation)</li>
<li><a href="https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html#v:try" class="uri">https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html#v:try</a> (try documentation)</li>
<li><a href="https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html#v:manyTill" class="uri">https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html#v:manyTill</a> (manyTill documentation)</li>
<li><a href="https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec-Char.html#v:anyChar" class="uri">https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec-Char.html#v:anyChar</a> (anyChar documentation)</li>
<li><a href="https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html#v:eof" class="uri">https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html#v:eof</a> (eof documentation)</li>
<li><a href="https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec-Char.html#v:noneOf" class="uri">https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec-Char.html#v:noneOf</a> (noneOf documentation)</li>
<li><a href="https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html#v:between" class="uri">https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html#v:between</a> (between documentation)</li>
<li><a href="https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html#v:many1" class="uri">https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html#v:many1</a> (many1 documentation)</li>
<li><a href="https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec-Char.html#v:digit" class="uri">https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec-Char.html#v:digit</a> (digit documentation)</li>
<li><a href="http://hackage.haskell.org/package/base-4.10.1.0/docs/Prelude.html#v:either" class="uri">http://hackage.haskell.org/package/base-4.10.1.0/docs/Prelude.html#v:either</a> (either documentation)</li>
<li><a href="http://hackage.haskell.org/package/base-4.10.1.0/docs/Prelude.html#v:const" class="uri">http://hackage.haskell.org/package/base-4.10.1.0/docs/Prelude.html#v:const</a> (const documentation)</li>
<li><a href="http://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Traversable.html#v:for" class="uri">http://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Traversable.html#v:for</a> (for documentation)</li>
<li><a href="http://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Traversable.html#v:traverse" class="uri">http://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Traversable.html#v:traverse</a> (traverse documentation)</li>
<li><a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/src/Data.Traversable.html#line-235" class="uri">https://hackage.haskell.org/package/base-4.10.1.0/docs/src/Data.Traversable.html#line-235</a> (definition of traverse for lists)</li>
<li><a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/src/GHC.Base.html#line-716" class="uri">https://hackage.haskell.org/package/base-4.10.1.0/docs/src/GHC.Base.html#line-716</a> (Applicative instance for Maybe)</li>
<li><a href="https://git-scm.com/docs/git-status/2.15.0" class="uri">https://git-scm.com/docs/git-status/2.15.0</a> (git status manpage, for git 2.15.0)</li>
<li><a href="http://zsh.sourceforge.net/Doc/Release/Prompt-Expansion.html" class="uri">http://zsh.sourceforge.net/Doc/Release/Prompt-Expansion.html</a> (The Z Shell Manual, Chapter 13: Prompt Expansion)</li>
</ul>
</div>
<div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'pangyanhan'; // required: replace example with your forum shortname
        var disqus_identifier = "posts/haskell-deep-dive-zsh-git-prompt.md";
        var disqus_url = "http://blog.pangyanhan.com/posts/haskell-deep-dive-zsh-git-prompt.html";

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

          </div>
        </div>

        <div class="row footer">
          <div class="medium-12 columns">
            <div class="footer-item">
              <span>Github</span>
              <a href="https://github.com/yanhan/">github.com/yanhan</a>
            </div>
            <div class="hakyll-line">
              Site proudly generated by
              <a href="http://jaspervdj.be/hakyll" target="_blank">Hakyll</a>
            </div>
          </div>
        </div>
      </div>

      <script src="../js/vendor/jquery.js"></script>
      <script src="../js/foundation.min.js"></script>
      <script>
        $(document).foundation();
        var navigation = responsiveNav(".nav-collapse", {
          animate: true,
          transition: 284,
          label: "",
          insert: "after",
          openPos: "relative",
          navActiveClass: "js-nav-active"
        });
      </script>
      <script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create', 'UA-49506023-1', 'pangyanhan.com');ga('send', 'pageview');</script>
    </body>
</html>
